 
 <div class="d-flex" id="wrapper">
   <div class="bg-light border-right" id="sidebar-wrapper">
      <div class="list-group list-group-flush">
        <a (click)="languagefundamentals()" class="list-group-item list-group-item-action bg-light">Language Fundamentals</a>
        <a (click)="declareandaccesscontrol()" class="list-group-item list-group-item-action bg-light">Declar. & Access Control</a>
        <a (click)="flowcontrol()" class="list-group-item list-group-item-action bg-light">Flow Control</a>
        <a (click)="exceptionhandling()" class="list-group-item list-group-item-action bg-light">Exception Handling</a>
        <a (click)="assertions()" class="list-group-item list-group-item-action bg-light">Assertions</a>
        <a (click)="ooconcepts()" class="list-group-item list-group-item-action bg-light">OO Concepts</a>
        <a (click)="innerclasses()" class="list-group-item list-group-item-action bg-light">Inner Classes</a>
        <a (click)="threadconcurrency()" class="list-group-item list-group-item-action bg-light">Thread and Concurrency</a>
        <a (click)="fundamentalclasses()" class="list-group-item list-group-item-action bg-light">Fundamental Classes</a>
        <a (click)="ioserialization()" class="list-group-item list-group-item-action bg-light">I/O & Serialization</a>
        <a (click)="garbagecollector()" class="list-group-item list-group-item-action bg-light">Garbage Collection</a>
        <a (click)="collectionfw()" class="list-group-item list-group-item-action bg-light">Collections FW & Generics</a>
      </div>
   </div>

   <div class="container-fluid">
     <div class="languagefundamentals" *ngIf="languagefundamental1">  
        <h1 class="mt-4">LANGUAGE FUNDAMENTALS</h1>
      <ol>
        <li>Identifiers</li>
        <li>Keywords</li>
        <li>Datatypes</li>
        <li>Literals</li>
        <li>Arrays</li>
        <li>Types of variables</li>
        <li>var – arg methods</li>
        <li>command line arguments & main method</li>
        <li>java coding standards</li>
      </ol> 
     <p><b>Identifiers:</b><br>
      A name in the program is an identifier it may be class name or method name,variable name or label name.</p>
       <p>Ex:- <br>
              <img src="assets/images/identifier.png">
       </p>
        <p><b>Rules for defining Identifiers</b></p>
        <ol>
           <li>A java identifier is a sequence of characters, where each character may be a letter from a-z or A-Z
or a digit form 0-9 or currency symbol $ or connecting punctuation – , if we are using any other
symbol we will get Compile time error “IllegalCharacter”.</li>
         <li>Identifier should not be starts with digit.</li>
         <li>There is no length limit for java identifiers but it is not recommended to take more than 15
length.</li>
        <li>Java Identifiers are case sensitive</li>
        <img src="assets/images/identifier1.png" id="identifier1">
        <img src="assets/images/identifier2.png" id="identifier1">
        </ol>
        
         <p><b>Reserved Words</b></p>
<p>Some identifiers are reserved to associate some functionality or to represent values, such type of reserved
identifiers are called “ReservedWords”.</p>
<img src="assets/images/reserved.png" id="reserved">

<p><b>Keywords for Datatypes</b></p>
 
   <ul>
       <li>byte  |  short</li>
       <li>int   | long</li>
       <li>float | double</li>
       <li>char  | boolean</li>
        
   </ul>

   <p><b>Keywords for FlowControl</b></p>
      <ul>
         <li>if | else | switch | case | default | do | while | for | break  | continue | return</li>
      </ul>

   <p><b>Keywords for ExceptionHandling</b></p>
      <ul>
         <li>try | catch | finally | throw | throws | assert (JAVA 1.4V)</li>
      </ul>
   <p><b>Keywords for Modifiers</b></p>
      <ul>
         <li>public | private | protected | final | abstract | static | native | synchronized | volatile | transient | strictfp</li>
      </ul>
     <p><b>Class Related Keywords</b></p>
      <ul>
         <li>class | interface | package | extends | implements | import</li>
      </ul>
      <p><b>Object Related Keywords</b></p>
      <ul>
         <li>new | instanceof | super | this</li>
      </ul>

     <p><b>void return type Keywords</b></p>
     <p>if a method doesn’t return anything compulsory that method should be with void return type.</p>

    <p><b>UnUsed Keywords</b></p>
        <ul>
           <li>goto -> in java usage is considered as harmful.</li>
           <li>const -> alternatively we should use final keyword.</li>
        </ul>

      <p><b>Enum Keyword</b></p>
      <p>This keyword has introduced in 1.5 version, to define user defined data types.</p>
      <img src="assets/images/enum.png" id="enum">
      <img src="assets/images/reservedliterals.png" id="enum">

      <p><b>Datatypes</b></p>
      <p>In java every variable has a type, every expression has a type and all types are strictly defined.
All the assignments should be checked by the compiler for the type compatibility. Hence java language
considers as strongly typed language.
Java is not considered as pure object oriented programming language because several OOP features(like
multiple inheritance, operator overloading) are not supported by java. Even java contains non-object
primitive datatypes.</p>
<img src="assets/images/primitivedatatypes.png" id="primitivedatatype">

<p>Except boolean and char all the remaining datatypes are signed datatypes i.e we can represent both +ve and
–ve numbers.</p>

  <p><b>byte</b><br>
Size : 8-bits<br>
Range: -128 to 127<br>
-ve numbers can represented in 2’s compliment form.<br>
Ex:<br>
byte b = 10;<br>
byte b = 127;<br>
byte b = 130; <i class="fa fa-arrow-right"></i><span style="color:red">C.E: possible loss of precision</span><br>
byte b = true; <i class="fa fa-arrow-right"></i><span style="color:red">C.E: Incompatible types found: boolean required: byte</span><br>
byte datatype is best suitable if we are handling data either from file or form network.</p>


<p><b>short</b> <br>
size = 2 bytes<br>
range = -215 to 215 -1 (-32768 to 32767)<br>
Ex:<br>
short s = 10;<br>
short s = 32767;<br>
short s = 65535;<i class="fa fa-arrow-right"></i> C.E: possible loss of precision.<br>
short s = true; <i class="fa fa-arrow-right"></i> C.E: Incompatible types<br>
short is best suitable datatype for 16-bit process. But currently these are completely out dated and
hence the corresponding datatypes also no one is using.</p>

<p><b>int</b><br>
The most commonly used datatype is int.<br>
size = 4 bytes<br>
range = -231 to 231 – 1(-2147483648 to 2147483747)<br>
The size of int is always fixed irrespective of platform hence the chance of failing java program is
very less if u r changing the platform hence the java is considered as Robust.</p>
<p><b>long</b><br>
if int is not enough to hold big values then we should go for long-datatype<br>
size = 8 bytes<br>
range = -263 to 263 – 1<br>
Ex:
The amount of distance traveled by light in 1000days can be represented by long
datatype only and int is not enough.</p>

<img src="assets/images/floating.png" id="floating">

<p><b>boolean datatye</b><br>
size = not applicable(virtual machine dependent).<br>
range = not applicable but allowed values are true/false.<br>
Which of the following boolean declarations are valid<br>
boolean b1 = true;<i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
boolean b2 = 0; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i><i class="fa fa-arrow-right" style="margin-left: 20px;"></i> Incompatible types found:int required : boolean<br>
boolean b3 = TRUE; <i class="fa fa-close" style="color: red;margin-left: 10px;"></i><i class="fa fa-arrow-right" style="margin-left: 20px;"></i> capital TRUE is not valid.</p>

    <textarea rows="11" cols="60" class="textArea" readonly>
      Ex:
      int x = 0;
      if(x)
      {
      System.out.println("Hello");
      }
      else
      {
      System.out.println("Hai");
      }
    </textarea>
     <p>
      <b>OUTPUT</b><i class="fa fa-arrow-right" style="margin-left: 10px;"></i><span class="output"> C.E: Incompatible types found :int required: boolean.</span>
     </p>
     <img src="assets/images/char.png" id="floating">
     <p><b>Comparison table for java primitive datatypes</b></p>
          
     <table class="table table-bordered">
      <thead>
        <tr>
          <th scope="col">datatype</th>
          <th scope="col">size</th>
          <th scope="col">range</th>
          <th scope="col">Default value</th>
          <th scope="col">Wrapper class</th>
        </tr>
      </thead>
      <tbody>
        <tr>
         <th scope="row">byte</th>
         <td>1 byte</td>
         <td>-128 to 127</td>
         <td>0</td>
         <td>Byte</td>
      </tr>
        <tr>
         <th scope="row">short</th>
          <td>2 bytes</td>
          <td>-32768 to 32767</td>
          <td>0</td>
          <td>Short</td>
        </tr>
        <tr>
         <th scope="row">int</th>
          <td>4 bytes</td>
          <td>-231 to 231-1</td>
          <td>0</td>
          <td>Integer</td>
        </tr>
        <tr>
         <th scope="row">long</th>
         <td>8 bytes</td>
         <td>-263 to 263-1</td>
         <td>0</td>
         <td>Long</td>
        </tr>
        <tr>
         <th scope="row">float</th>
         <td>4 bytes</td>
         <td>-3.4e38 to 3.4e38</td>
         <td>0.0</td>
         <td>Float</td>
        </tr>
        <tr>
         <th scope="row">double</th>
         <td>8 bytes</td>
         <td>-1.7e308 to
            1.7e308</td>
         <td>0.0</td>
         <td>Double</td>
        </tr>
        <tr>
         <th scope="row">boolean</th>
         <td>NA</td>
         <td>NA(But allowed
            values are true,</td>
         <td>false</td>
         <td>Boolean</td>
        </tr>
        <tr>
         <th scope="row">char</th>
         <td>2 bytes</td>
         <td>0 to 65535</td>
         <td>0(balnk spaces)</td>
         <td>Character</td>
        </tr>
      </tbody>
    </table>


    <p><b>Literals</b><br>
      A literal represents a constant value which can be assigned to the variables<br>
    </p>
    <img src="assets/images/literals.png" id="literals">
     <p><b>Integral Literal</b><br>
      We can specify an integral literal in the following ways.</p>
      <p style="margin-left: 30px;"><b>Decimal literals:</b> allowed digits are 0 to 9 <br>
         <span style="margin-left: 40px;">Ex: int x = 10;</span></p>

         <p style="margin-left: 30px;"><b>Octal literals:</b> allowed digits are 0 to 7 but here literal value should be prefixed with 0(zero) <br>
            <span style="margin-left: 40px;">Ex: int x = 010;</span></p>
            <p style="margin-left: 30px;"><b>Hexadecimal literals: </b> the allowed digits are 0 to 9, A- F (Both lower, Upper case) literals
         should be prefixed with 0x or oX<br>
         <span style="margin-left: 40px;">Ex: int x = 0x10;</span></p>

         <textarea rows="11" cols="60" class="textArea" readonly>
            Ex:
            class Test{
              public static void main(String arg[]){
               int x = 10;
               int y = 010;
               int z = 0x10;
               System.out.println(x + "..." + y + "..." + z);
              }
            }
            O/P:- 10…8…16
          </textarea>
         <p>Except decimal, octal, hexadecimal there is no other way to represents constant values      for the integral datatype.<br>
            By default every integral lateral is of int datatype we can specify explicitly. An   
             integral literal is of long type by suffixing with l or L.</p>
             <p style="margin-left: 80px;">Ex: <br>
             <span style="margin: 30px;">10 <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> int value.</span><br>
               <span style="margin: 30px;">10l <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> long value.</span><br>
                  <span style="margin: 30px;">long l = 10l; </span><br>
                     <span style="margin: 30px;">int i = 10l;</span><br>
                        <span style="margin: 30px; color: red;">C.E: possible loss of precision found : long Required:int </span></p>

                        <img src="assets/images/integralLitrals.png" id="integralLitrals"> 
                        
         <p>There is no way to specify explicitly an integral literal is of type byte and short.
               If the integral literal is with in the range of byte then the JVM by default treats it as byte literal.
               Similarly short literal also.</p>
         <p><b>Floating – point literals</b><br>
            By default floating-point literals are double type we can specify explicitly as float type by suffixing with ‘f’ or ‘F’.
         </p>                     
         <p><b>Which of the following are valid declarations</b><br></p>
           <ol>
             <li>float f = 10.5; <i class="fa fa-close" style="color: red; margin-left: 5px;"></i>
               <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> C.E possible loss of precision</li>
             <li>float f = 10.5f; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
             <li>double d = 10.5; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
             <li>double d = 10.5f; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
             <li>double d = 10.5D; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
           </ol>
          <p>we can specify explicitly a floating point literal of double type by suffixing with d or D. we can also represent float-point literals by using scientific notation.<br>
         
          Ex: <br>
            double d = 10e23; <br>
            int i = 10e23; <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> C.E possible loss of precision found : double required : int. </p>

       <p>Floating point literals can be specified only in decimal form. i.e we can’t use octal and hexa decimal representation for floating point literals.<br>
       Ex: <br>
       Double d = 0x123.456; <br>
       C.E: Malformed floating-point literal.</p>

       <p><b>Which of the following are valid declarations</b></p>
       <ol>
          <li>float f = 123.456; <i class="fa fa-close" style="color: red; margin-left: 5px;"></i></li>
          <li>float f = 0x123.456F; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
          <li>float f = 0x123; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
          <li>float f = 1.2e36; <i class="fa fa-close" style="color: red; margin-left: 5px;"></i></li>
          <li>double d = 1.2e36; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
       </ol>
      
      <p><b>Boolean Literals</b><br>
         The only allowed values for boolean datatype are true, false.<br>
         <b>Which of the following are valid declarations</b><br>
         <span style="margin-left: 30px;"> 1. boolean b = true; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></span><br>
         <span style="margin-left: 30px;"> 2. boolean b = FALSE; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></span><br>
         <span style="margin-left: 30px;"> 3. boolean b = 0; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></span><br>
      </p>
      <p><b>character literal</b><br>
       A char literal can be represented as a single character with in single quotes.</p>
       <ol>
          <li>char ch = 'a'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
          <li>char ch = 'ab'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i> <span style="margin-left: 20px;">C.E: unclosed character literal.</span></li>
          <li>char ch = a; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
         </ol>
          <span>we can represent a char literal by using it’s Unicode value. For the allowed Unicode  values are 0 to 65535.</span><br>
          <p>Ex:<br>
            char ch = 97; <br>
            System.out.println(ch); <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> O/P: a <br>
            char ch = 65535; <br>
            char ch = 65536; <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> C.E : possible loss of precision found : int required :char </p>
         
            <p>we can represent a char literal by using Unicode representation which is nothing but \uxxxx’ <br>
            
                  Ex: <br>
                  char ch = '\u0061' <br>
                  System.out.println(ch); <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> O/P:a <br>
                  char ch = '\ubeef'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
                  char ch = '\uface'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
                  char ch = '\iface'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i><br>
                  char ch = '\uface'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i><br>
               </p>
            <p>we can also represent a char literal by using escape character. <br>
               Ex: <br>
               char ch = '\b'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
               char ch = '\n'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
               char ch = '\l'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i>
            </p>
        
            <p>The following is the list of all possible escape characters in java. <br>
               \b  <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> backspace <br>
               \n <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> new line <br>
               \r <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> carriage return <br>
               \f <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> formfeed <br>
               \t <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> horizontal tab <br>
               \’ <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> single quote <br>
               \” <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> double quote <br>
               \\ <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> back slash
            </p>
           <p><b>Which of the following char declarations are valid?</b></p>
              <ol>
                 <li>char ch = 'c'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
                 <li>char ch = 'abc'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
                 <li>char ch = a ; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
                 <li>char ch = 65123; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
                 <li>char ch = 65537; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
                 <li>char ch = \uabcd; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
                 <li>char ch = '\uanuska'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
                 <li>char ch = '\ubeef'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
                 <li>char ch = '\r'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
                 <li>char ch = '\t'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
                  <li>char ch = '\d'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
              </ol>
 
              <p><b>String literal</b></p>
              <ol>
                 <li>String s = "Durga"; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
                 <li>String s = 'software'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
                 <li>String s = 'a'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
              </ol>

              <p><b>Arrays</b></p>
                   <p>An array is a data structure that represents an index collection of fixed no of homogeneous data
                        elements. The main advantage of arrays is we can represent a group of values with single name
                        hence readability of the code will be improved. The main limitation of arrays is they are fixed in size.
                        i.e once we constructed an array there is no chance of increasing or decreasing bases on our
                        requirement hence with respect to memory arrays shows worst performance we can overcome this
                        problem by using collections.</p>

            <p><b>Array Declaration</b> <br>
               The following are the ways to declare an array. <br>
               1) int [] a; <br>
               2) int a[]; <br>
               3) int [] a; <br>

               The first one is recommended to use because the type is clearly separated from the name. At the first time of declarations we are not allowed to specify the size. Violation leads to C.E. <br>

               Ex: <br>
                int[] a; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
                int[6] a; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i>
            </p>  
            <p><b>Declaring Multidimensional Arrays</b><br>
               The following are the valid declarations for multidimensional arrays. <br>
               int[][] a; <br>
               int a[][]; <br>
               int [][]a; <br>
               int[] a[]; <br>
               int[] []a; <br>
               we can specify the dimension before name of variable also, but this facility is available only for the first variable.  <br>
               int[] a[],b[]; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
               int[] []a,[]b; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i>
            </p> 
            
            <p><b>Which of the following declarations are valid?</b></p>
             <ol>
                <li>int[2][3] a; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
                <li>int[] a,b; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
                <li>int[] a[],b[]; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
                <li>int []a,[]b; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
                <li>int []a,b[]; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
             </ol>

             <p><b>Construction of Arrays <br>Single Dimension :</b>Arrays are internally implemented as object hence by using new operator we can
               construct an array.<br>Compulsory at the time of construction we should specify the size otherwise compile time error.<br>

               Ex: <br>
int[] a = new int[10]; <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
int[] a = new int[]; <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> C.E <br>
It is legal to have an error with size 0 there is no C.E or R.E <br>
int[] a = new int[0]; <br>
If we are specifying array size with some –ve integer <br>
int[] a = new int[-10]; <br>
we will get R.E saying NegativeArraySizeException.</p>
<p>The only allowed Data type to allow the size are byte, short, char, int. if we are using any other datatype we will get a C.E.</p>
 <ul>
     <li>int[] a = new int[10];  <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
     <li>int[] a1 = new int[10l];  <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
     <li>int[] a = new int[10l]; <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> C.E possible loss of precision found: long required: int
     <li>int[] a = new int[10.5]; <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> C.E </li>
     <li>int[] a = new int[true]; <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> C.E Incompatible types found : boolean required:int.</li>
 </ul>
 <span>The maximum allowed Array Size in java is 2147483648.</span>


      </div>
     
     <div class="exceptionhandling" *ngIf="exception">
         <h1 class="mt-4">EXCEPTIONHANDLING</h1>
         <b>Introduction</b><br>
          It is an unexpected unwanted event which disturbs entire flow of the program.<br>
          RealTimeExample:<br>
          <ol>
            <li>SleepingException</li>
            <li>TirePuncharedException</li>
          </ol>  
      
        <p>If we are not handling exception, the program may terminate abnormally with out releasing allocated
resources. This is not a graceful termination. Being a good programming practice compulsory we should
handle exceptions for graceful termination of the program.</p>

<p>Exception handling means it is not repairing an exception we are providing alternative way to continue the
program normally. For example if out programming requirement is to read the data from London file, if at
runtime London file is not available, we have to provide a local file as the part of exception handling. So that respect of the program will be continued normally.</p>

<p><b>Runtime Stack Mechanism</b></p>
<p>For every thread JVM will create a runtime stack. All the method calls performed by the thread will be
sorted in the corresponding runtime stack. If a method terminates normally the corresponding entry from the
stack will be removed.</p>
<p>After completing all the method calls the stack is empty. Just before terminating the thread JVM will destroy
the corresponding stack.</p>

<img src="assets/images/exception.jpg">

  

     </div>
     <div class="declareandaccesscontrol" *ngIf="decandaccess">
         <h1 class="mt-4">DECLARATION AND ACCESS CONTROL</h1>

         
     </div>

     <div class="flowcontrol" *ngIf="flwc">
         <h1 class="mt-4">FLOW CONTROL</h1>
     </div>

     <div class="assertions" *ngIf="assertion">
         <h1 class="mt-4">ASSERTIONS</h1> 
      </div>

      <div class="ooconcepts" *ngIf="ooconcept">
         <h1 class="mt-4">OO CONCEPTS</h1>
         <ol>
            <li>Data hiding</li>
            <li>Abstraction</li>
            <li>Encapsulation</li>
            <li>Tightly Encapsulated class</li>
            <li>Is – A Relation Ship</li>
            <li>HAS – A Relation ship</li>
            <li>method signature</li>
            <li>overloading</li>
            <li>overriding</li>
            <li> method hiding</li>
            <li>static control flow</li>
            <li>instance control flow</li>
      
            <li>constructors</li>
            <li>coupling</li>
            <li>cohesion</li>
            <li>typecasting</li>
      
         </ol>
         <p><b>Data Hiding:</b><br>
            The data should not go out directly i.e outside person is not allowed to access the data this is nothing but<br />
            <span class="italic"><b>&ldquo;Data Hiding&rdquo;</b></span><br />    
         
            The main advantage of data hiding is we can achieve security.<br />
            By using private modifier we can achieve this.</p>
         <div class=row>
        
            <div class="col-lg-2">
      
               <textarea rows="9" cols="55" class="textArea" readonly>
               Ex:
               
                     Class datademo
                     {
                     private double amount;
                     ………
                     }
                     O/P:- 10…8…16
             </textarea>
            </div>
      
         </div>
         <p>It is highly recommended to declare data members with private modifier.</p>
      
      </div>
    

      <p><b>Abstraction:</b><br>
      
         Hiding implementation details is nothing but abstraction. The main advantages of abstraction are we can
         achieve <b>security</b> as we r not highlighting internal implementation.
         <b>Enhancement</b> will become easy. With out effecting outside person we can change our internal
         implementation.</p>
      <p class="improves">It improves <b>maintainability</b></p>
      <b>Note:- </b>1. If we don’t know about implementation just we have to represent the specification then we
      should
      go for <b class="Abstraction">interface</b>
      <ol start="2" class="NoteAbstraction">
         <li> If we don’t know about complete implementation just we have partial implementation then we
            should go for <b class="Abstraction">abstract.</b></li>
         <li>If we know complete implementation and if we r ready to provide service then we should go for
            concrete class</li>
      </ol>


      <p><b>Encapsulation:</b><br>
         If a class follows data hiding and abstraction such type of class is said to be ‘Encapsulated’ class.</p>
  <b class="EncapsulationDataHiding">Encapsulation = Data Hiding + Abstraction</b><br/><br/>
  
  <textarea rows="12" cols="55" class="textArea" readonly>
Ex:
            class Account
            {
            private int balance;
            public void setBalance(int balance)
            {
            //validating the user & his permissions.
            this.balance = balance;
            }
            public int getBalance()
            {
            //validating the user and his permissions.
            return balance;
            }
            }
           
 </textarea>
 <p>The data members we have to declared as private. So that outside person is not allowed to access to directly
   we have to provide Access to our data by defining setter and getter methods. i.e hiding data behind methods
   is the central concept of encapsulation.</p>
   <p class="pEncapsulation">The main advantages of encapsulation are security, enhancement, maintainability</p>
   <p><b>Tightly Encapsulated Class:</b><br>A class is said to be tightly encapsulated iff all the data members declared as private. 
</p>

<textarea rows="12" cols="55" class="textArea" readonly>
Ex:-
            class student
            {
            private String name;
            public void setName(String name)
            {
            this.name = name;
            }
            public String getName()
            {
            return name;
            }
            }
</textarea>
<br/>
<p><b>Q) which of the following classes are tightly encapsulated classes?</b></p>

<textarea rows="12" cols="55" class="textArea" readonly>
            class x
            {
            private int i =10;
            private int getI();<i class="fa fa-arrow-right" style="color: red; margin-left: 10px;"></i>
            {
            return i;
            }
            }
            class y extends x  
            {
            public int i = 30; <i class="fa fa-close" style="margin-left: 20px;"></i>
            }
            class z extends x
            {
            private int k = 40;
            }
            }
   
</textarea>
<p><b>Q)
</b></p>
<textarea rows="12" cols="55" class="textArea" readonly>

         class x
         {
         int i = 0;
         }
         class y extends x
         {
         private int j = 20;
         }
         class z extends y
         {
         private int k = 30;
         }
         }
</textarea>
<p>no class is tightly encapsulated if the parent class is not tightly encapsulated then no child class is tightly
   encapsulated.</p>
   <p><b>IS – A RelationShip
   </b></p>


   <p><b>Rules for overriding</b></p>

   <ol>
      <li>The method names and arguments(including order) must be same. i.e signatures of the methods must be same. </li>
      <li>In overriding the return types must be same but this rule is applicable only until 1.4 version but from 1.5 version onwards co-variant return types also allowed. i.e the child class method return type need not to be same as parent class method return type it’s child class also allowed. </li>
   </ol>

   <textarea rows="10" cols="60" class="textArea" readonly>
   Ex:     
            Parent  : Object(covariant returntype).           &#x2713;
            Child : String, StringBuffer, Object….. 
         
            Parent : String    Child : Object                    &#x2717;  
            Because String to Object is not a covariant.              

            Parent : double                                       &#x2717;
             Child : int                                                 
   </textarea>
   <br/>
<p>Because co-variant return types are not applicable for primitive types.</p>
   <br/>
<b>Which of the following are valid overriding methods……?</b>
   <br/>
   <br/>
   <textarea rows="12" cols="60" class="textArea" readonly>
   Ex:
            Parent  : public void m1()          &#x2713;  
            Child : public void m1()  
 
            Parent  : public int m1()            &#x2717;
            Child : public long m1() 
            
            Parent  : public Object m1()        &#x2713;
            Child : public String m1()  
            
            Parent  : public String m1()         &#x2717;
            Child : public Object m1() 
 
      </textarea>
      <br/>
     <p>
3) final method can’t be overridden in child classes. Private methods are not visible in the child classes. Hence they won’t participate in overriding. Based on our requirement we can take exactly same declaration in child class, But It is not overriding. 
 
   </p>
      <textarea rows="12" cols="55" class="textArea" readonly>
      Ex:
               class P
               {
               private void m1()
               {
               
               }
               }
               class C extends P
               {
               private void m1()
               {
               
               }
               }

      </textarea>
<br/>
<p>Here it is not  overriding child class specific method. </p>
<p>4) native methods can be overridden as non-native, similarly we can override abstract methods, synchronized methods.<br/> We can override a non-abstract method as abstract also </p>
         



<textarea rows="20" cols="55" class="textArea" readonly>
   Ex:
               class P
               {
               public void m1() {

               }
               }
               abstract class C extends P
               {
               public abstract void m1();
               }
               abstract class P
               {
               public abstract void m1();
               }
               class C extends P
               {
               public void m1()
               {

               }
               }
</textarea>
<p>The following are possible types </p>
<img src="assets/images/RuleOverriding.PNG">
<p>5) while overriding we are not allowed o decrease access privileges. Otherwise compile time error but we can increase access privileges. The following is the list of valid with respect to access privileges. </p>
<img src="assets/images/RuleOverriding1.PNG">
<p>
6) while overriding the size of checked exceptions we are not allowed to increase in throws class but we can decrease the size of checked exceptions. But there are no restrictions on unchecked exceptions. 
   </p>


   <p><b>Overriding in static methods</b><br>
   
      A static method can’t be overridden as non-static  
   </p>

   <textarea rows="20" cols="55" class="textArea" readonly>
   Ex:
                  class P
                  {
                  public static void m1()
                  {
                  
                  
                  }
                  }
                  class C extends P
                  {
                  public void m1()
                  {
                  
                  }
                  }
</textarea>

<br/>
<img src="assets/images/RuleOverriding2.PNG">
<p>Similarly a non-static method can’t be overridden as static method.</p>

<img src="assets/images/RuleOverriding3.PNG">
<p>If both parent and child class methods are static then there is no compile time error or run time error it seems that overriding is happened but it is not overriding this concept is called “method hiding”. All the rules of method hiding are exactly similar to overriding, except both methods declared as static. 
   <br/>In the case of method hiding method resolution will take care by compiler based on reference type(But not runtime object).</p>
   <textarea rows="20" cols="55" class="textArea" readonly>
      Ex: 
                  class P {
                  public static void m1() {
                  System.out.println("parent method");
                  }
                  }
                  class C extends P {
                  public static void m1() {
                  System.out.println("child method");
                  }
                  }
                  class Test {
                  public static void main(String arg[])
                  {
                  P p = new P();
                  Case1: p.m1(); //parent method
                  
                  
                  C c = new C();
                  Case2: c.m1(); //child method
                  
                  P p1 = new P();
                  Case3: p1.m1(); //parent method
                  }
                  }

</textarea>


<p>In the case of method hiding the method resolution will take care by compiler based on reference type. Hence method hiding is considered as <span class="italic"><b>&ldquo;static polymorphism&rdquo;</b></span> or  <span class="italic"><b>&ldquo;compile time polymorphism&rdquo;</b></span> or  <span class="italic"><b>&ldquo;early binding&rdquo;</b></span>. </p>

<p><b>Overriding in the case of Variable</b><br>Overriding concept is not applicable for variables. And it is applicable only for methods. Variable resolution always takes care by compiler based on reference type. </p>
<textarea rows="20" cols="55" class="textArea" readonly>
   Ex:   
            class P
            {
            int i = 888;
            static
            non-static
            }
            class C extends P
            {
            int i = 999;
            }
            class Test
            {
            public static void main(String arg[])
            {
            P p = new P();
            Case1: System.out.println(p.i); //888
            C c = new C();
            Case2: System.out.println(c.i); //999

            P p1 = new C();
            Case3: System.out.println(p1.i); //888
            }
            }
         </textarea>
            <p><b>Comparison between Overloading and Overriding</b></p>
            <table>
               <tr>
                 <th>Property </th>
                 <th>Overloading </th>
                 <th>Overriding </th>
               </tr>
               <tr>
                 <td>Method names</td>
                 <td>Same</td>
                 <td>Same</td>
               </tr>
               <tr>
                 <td>Arguments</td>
                 <td>Different(at least order)</td>
                 <td>Same(including order)</td>
               </tr>
               <tr>
                 <td>signature</td>
                 <td>Different</td>
                 <td>Same</td>
               </tr>
               <tr>
                 <td>return type</td>
                 <td>No rule or no restriction</td>
                 <td>Must be same until 1.4 version. But from 1.5 version onwards co-variant return types are allowed </td>
               </tr>
               <tr>
                 <td>throws clause</td>
                 <td>No restrictions </td>
                 <td>The size of the checked exception should not be increased. But no restrictions for unchecked exceptions.</td>
               </tr>
               <tr>
                 <td>Access Modifier</td>
                 <td>No restrictions</td>
                 <td>Should be decreased</td>
               </tr>
               <tr>
                  <td> Private/final/static</td>
                  <td>Can’t be overloaded</td>
                  <td>Can’t be overridden</td>
                </tr>
                <tr>
                  <td>Method resolution</td>
                  <td>Method resolution takes care by compiler based on reference type and arguments</td>
                  <td>Takes care by JVM based on runtime object</td>
                </tr>
                <tr>
                  <td>Other names</td>
                  <td>Compile time (or) static polymorphism (or) early binding </td>
                  <td>Runtime (or) dynamic polymorphism (or) late binding </td>
                </tr>
             </table>
<br/>
<p><b>Consider the following parent class method declaration….! </b><br>Parent : public void m1(int i)</p>
<p>Which of the following methods are allowed in the child class. </p>
   Child : 1) private void m1(float f)throws Exception &#x2713;  (overloading) <br/>   
       &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  2) public void m1(int i)throws classCastException &#x2713; (overloading)     
       &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3) public final void m1(int i)   &#x2713;  (overloading)  <br/>     
       &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   4) private abstract void m1(long l)throws Exception &#x2713; (private & abstract) <br/>   
       &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   5) public synchronized int m1() throws IOException &#x2717; (over loading)   <br/>    
       &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  6) public int m1(int i)   &#x2717;<br/>   
       &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   7) public void m1(int i)throws Exception &#x2717; (Exception Increased) 
<br/>
<br/>
<p><b>Static Control Flow </b></p>

<img src="assets\images\StaticControlFlow.PNG">
<br/>
<p><b>Process of static control flow</b></p><br/>
<p>1) Identification of static members from top to bottom <br/>i = 0 (RIWO) Read Indirect Write Only 
<br/>j = 0 (RIWO) <br/>(1-6) Steps.</p>
<p>2) Execution of static variable assignments and static block from top to bottom <br/>i = 0 (R & W) <br/> j = 0 (R & W) <br/>(7-12) Steps. </p>
<p>3) Execution of Main Method.  <br/>  (12-15) Steps. <br/>If the variable is in RIWO state then we r not allowed to perform read operation directly, violation leads to C.E Saying “Illegal forward reference”.</p>

<p><b>static Blocks </b>If we want to perform some activity at the time of class loading, Then we should define that activity at static blocks because these(static blocks) will execute at the time of class loading only.<br/></p>

<p>We have to load native libraries at the time of class loading. Hence we have to define this activity inside the <span class="italic"><b>&ldquo;static block&rdquo;</b></span>.</p>
<textarea rows="10" cols="55" class="textArea" readonly>
   Ex: 
               class Native
               {
               static
               {
               System.loadLibrary("native Library path");
               }
               }
</textarea>
<br/>
<p>After loading database driver compulsory we should register with the driver manager. But it is not required to perform explicitly this registration because in every driver class there should be one static block to perform this registration. 
   <br/> Hence at the time of loading the database driver automatically registration will be performed.</p>
   <textarea rows="8" cols="55" class="textArea" readonly>
   Ex:
            class DatabaseDriver
            {
            static {
            //Register Driver with Driver Manager
            }
            }
</textarea>
<br/>
<p><b>Case1:- </b>with out using main method we can able to print some statement to the console. </p>
<textarea rows="8" cols="55" class="textArea" readonly>
   Ex:
            class StaticDemo
            {
            static
            {
            System.out.println("Hello....I can print ");
            System.exit(0);
            }
            }
</textarea>
<p>With out using main method, static block still we are able  to print some statement on the console.</p>
<textarea rows="16" cols="55" class="textArea" readonly>

   Ex:
               class StaticDemo
               {
               static int i = m1();
               public static int m1()
               {
               System.out.println("Hello ....I am able to print");
               System.exit(0);
               return 1;
               }
               }
</textarea>
<p><b>static control flow in parent and child classes </b></p>
<br/>
<img src="assets\images\StaticControlFlow1.PNG" style="width: 1200px; height: 600px;">
<br/>
<p><b>E:\></b>&#10142; javac StaticDemo.java <br/> Then it generates two class files Parent.class and Child.class. </p>
<p><b>What is the O/P if I am execute java Child?</b></p>

<p><b>Process:</b></p>
<p>1) Identification of static members from parent to child. <br/>
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = 0(RIWO) <br/>
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = 0(RIWO) <br/>
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = 0(RIWO)<br/>
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = 0(RIWO) <br/>
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0 - 11) steps.<br/>
           </p>

<p>2) Execution of static variable assignments and static blocks from parent to child<br/>
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = 10(R&W) <br/>
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = 20(R&W) <br/> 
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = 100(R&W) <br/>
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = 200(R&W) <br/>  
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(12 - 22) steps.

</p>
<p>3) Execution of child class main method.</p>

<p><b>O/P:- 0 
   <br/> 
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Base static Block <br/>  
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 Derived First static Block<br/>   
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derived Second static Block <br/>  
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;200<br/>   
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derived Main Method</b></p>
   <br/>

   <p>If we execute java Parent<br/>
       Executes only Parent class members. <br/>If we remove main method in child, parent main is available because it is not overriding concept. </p>

<div class="innerclasses" *ngIf="innerclass">
          <h1 class="mt-4">INNER CLASSES</h1> 
      </div>
      <div class="threadconcurrency" *ngIf="threadcon">
            <h1 class="mt-4">THREADS AND CONCURRENCY</h1> 
      </div>
<p><b>Instance Control Flow</b></p>
<br/>
<img src="assets\images\InstanceControlFlow.PNG">
<br/>
<p><b>Process of static control flow </b><br/>
   Instance control flow will execute at the time of object creation the following is the sequence of statements <br/> which will execute at the time of object creation.<br/> 1) Identification of Instance members  <br/>
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = 0 (RIWO) Read Indirect Write Only <br/>
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = 0 (RIWO)<br/> 
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1-8) Steps.
</p>
<p>2) Execution of Instance variable assignments and Instance block from top to bottom <br/>
   i = 0 (R & W) <br/> 
   j = 0 (R & W) <br/>
   (9-14) Steps. </p>

   <p>3) Execution of Main Method. 
      <br/>   
      &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(15) Steps. </p>
<p><b>Note:-</b>  Static control flow is only one time activity and that will execute at the time of class loading. But instance control flow is not one time activity. And it will execute for every object creation separately.</p>
<p>If the variable is in RIWO state then we r not allowed to perform read operation directly, violation leads to C.E Saying <span class="italic"><b>&ldquo;Illegal forward reference&rdquo;</b></span>. </p>
<br/>
<p><b>Instance control flow in parent and child classes</b></p>
<br/>
<div class="InstanceControlFlow1">
<img src="assets\images\InstanceControlFlow1.PNG" style="width: 1100px;height: 600px;">
</div>
<br/>
<p><b>E:\> </b>
   <br/>javac StaticDemo.java  Then it generates two class files Parent.class and Child.class. 
   <br/> What is the O/P if I execute java Child?</p>

<p><b>Process:</b>1) Identification of Instance members from parent to child<br/>   

&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = 0(RIWO) <br/>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = 0(RIWO)<br/> 
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = 0(RIWO)<br/> 
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = 0(RIWO)<br/> 
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1 - 15) steps.<br/> 


</p>
<p>2) Execution of Instance variable assignments and instance blocks only in parent class.
   <br/>
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = 10(R&W)<br/>
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = 20(R&W)<br/>
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(16 - 20) steps.<br/>

</p>

<p>3) Execution of Parent class constructor. 
   <br/>
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;21 step<br/>
</p>

<p>4) Execution of Instance variable assignments and instance blocks in the child class  <br/> 
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = 100  <br/> 
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = 200 <br/> 
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(22-27) steps.  </p>
<p></p>
<p>5) Execution of child class constructor. <br/>  
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;28 step </p>
   <p><b>O/P:- </b></p>
   <img src="assets\images\InstanceControlFlow3.PNG">
   <br/>
   <p><b>Note:-</b><br/>Object Creation is the most costly operation. Unnecessarily we r not allowed to create more no of Objects. It will effect performance of the system. 
   </p>
   <p><b>Constructor</b><br/>
      After Creation of Object compulsory we should perform initialization then only that object in a position to provide service to others. 
      <br/>
      At the time of Object Creation some peace of code will execute automatically to perform initialization that
      <br/> peace of code is nothing but “Constructor”. Hence the main Objective of constructor is to perform initialization. If we don’t have constructor we will face burden. For example see the following code. 
   </p>
   <textarea rows="23" cols="60" class="textArea" readonly>

      Ex: 
               class Student
               {
               String name;
               int rollno;
               public static void main(String[] args)
               {
               Student s1 = new Student();
               Student s2 = new Student();
               Student s3 = new Student();
               Student s4 = new Student();
               s1.name = "Malli";s1.rollno = 101;
               s2.name = "Sankar";s2.rollno = 102;
               s3.name = "Kiran";s3.rollno = 103;
               s4.name = "Sai";s4.rollno = 104;
               System.out.println(s1.name+"-----"+s1.rollno);
               System.out.println(s2.name+"-----"+s2.rollno);
               System.out.println(s3.name+"-----"+s3.rollno);
               System.out.println(s4.name+"-----"+s4.rollno);
               }
               }
   </textarea>
   
   <p>To over come this type of burden constructor was introduced.  </p>

   <textarea rows="20" cols="55" class="textArea" readonly>

      Ex:-
                  class Student {
                  String name;
                  int rollno;
                  Student(String name, int rollno)
                  {
                  this.name = name;
                  this.rollno = rollno;
                  }
                  public static void main(String[] args)
                  {
                  Student s1 = new Student("raju",101);
                  Student s2 = new Student("mani",102);
                  System.out.println(s1.name+"-----"+s1.rollno);
                  System.out.println(s2.name+"-----"+s2.rollno);
                  }
                  }
   </textarea>
 <p><b>o/p:-</b></p>

   

   <div class="result">
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roju---101
   <br/>
   &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nami---102

   </div>

<br/>
<p><b>Rules for Constructor</b>
<br/>
   While writing constructors we should follow the following rules. <br/>
   1) The name of the constructor and name of the class must be same.<br/>
   2) The only allowed modifiers for the constructors are public, private, protected, &#62;default&#60; If we are using any other modifier we will get C.E(Compiler Error). 
</p>
<textarea rows="10" cols="55" class="textArea" readonly>

   Ex:
               class Test
               {
               static Test()
               {
               ----
               }
               }
</textarea>
<p><b>C.E:-</b>modifier static not allowed here.</p>
<p>3) return type is not allowed for the constructors even void also. If we r declaring return type then the compiler treats it as a method and hence there is no C.E and R.E(RuntimeError). </p>
     
<textarea rows="15" cols="55" class="textArea" readonly>
   Ex:
            class Test
            {
            void Test()
            {
            System.out.println("Hai .....");
            }
            public static void main(String arg[])
            {
            Test t = new Test();
            }
            }
</textarea>
<p>It is legal(But Stupid) to have a method whose name is exactly same as class name.  Here it was treated as method. </p>
<p><b>Default Constructor</b>
If we r not writing any constructor then the compiler always generate default constructor.  If we r writing at least one constructor then the compiler won’t generate any constructor. Hence every class contains either programmer written constructor or compiler generated default constructor but not both simultaneously. 
</p>
<p><b> Prototype of default constructor: </b></p>
<ol><li>It is always no-arg constructor.</li>
<li>It contains only one – line <b>super();</b><br/>This is a call to superclass – constructor it is no-argument call only. </li>
<li>The modifier of the default constructor is same as class modifier(either public or default). </li>
</ol>

<br/>
<img src="assets\images\DefaultConstructor.PNG">
<br/>
<p>The first line inside any constructor must be a call to super class constructor(super()) or a call to overloaded constructor of the same class(this()). If we are not taking any thing then the compiler will always place super()</p>
<br/>
<p><b>super() & this() in constructor</b>
   we should use as first statement in constructor. We can use either super or this but not both simultaneously. Outside constructs we can’t use i.e we can invoke a constructor directly from another constructor only.
</p>
<img src="assets\images\DefaultConstructor1.PNG"><br/>
<p><b>Overloaded Constructor </b>
   A class can contain more than one constructors with different arguments. This type of constructors are called <span class="italic"><b>&ldquo;overloaded constructor&rdquo;</b></span>.
</p>

<br/>
<textarea rows="25" cols="55" class="textArea" readonly>
   Ex:-
               class Test {
               Test() {
               this(10);
               System.out.println("No-arg constructor");
               }
               Test(int i)
               {
               this(10.5);
               System.out.println("int-arg");
               }
               Test(double d)
               {
               System.out.println("double-arg")
               }
               public static void main(String arg[])
               {
               Test t1 = new Test();
               Test t2 = new Test(10);
               
               Test t3 = new Test(20.5);
               Test t4 = new Test('a');
               Test t5 = new Test(10l);
               }
               }

</textarea>
<br/>
<p>Inheritance concept is not applicable for constructor and hence overriding is also not applicable.</p>
<textarea rows="20" cols="100" class="textArea" readonly>
   Ex:-
               class Test {                          &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     class Test { 
               public static void m1() {           &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;      Test()  {
               System.out.println("m1 method");     &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;   this(10);
               m2();                                &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;      }
               }                                      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   Test(int i)  {                               
               public static void m2() {              &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;  this();
               System.out.println("m2 method");       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; }
               m1();                                  &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;   public static void main(String arg[])                             
               }                                       &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {  
               public static void main(String arg[])   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;  System.out.println("Hai........hello");    
               {                                        &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
               m1();                                    &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; } 
               System.out.println("Hello......hai");
               }
               }

No Compilar Error and No Runtime Error                 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  C.E: Recursive constructor invokation 
</textarea>
<br/>
<br/>
<p>Recursive Method invocation is runtime exception saying stack over flow error.</p>
<br/>
<img src="assets\images\RecursiveMethod.PNG"><br/>
<p>Because super calls no-argument constructor in parent. when ever we r writing any constructor. It is to provide no-arument constructor also. If the parent class contains some constructors then while writing child class constructor we should take a bit care. 
 <br/>
   If the parent class constructor <span class="italic"><b>&ldquo;throws&rdquo;</b></span> some <span class="italic"><b>&ldquo;checked exception&rdquo;</b></span>. Compulsory the child class constructor should throw the same checked exception or it’s parent other wise compile time error.</p>
  
  <br/> <img src="assets\images\RecursiveMethod1.PNG"><br/>
  <p>If the parent class constructor throws unchecked exception then child class constructor not  required to throw that exception </p>
  <textarea rows="18" cols="55" class="textArea" readonly>

      Ex:
                  class p
                  {
                  p() throws ArithmeticException
                  {
                  
                  }
                  }
                  class c extends p {
                  c()
                  {
                  super();
                  }
                  }
  </textarea>
  <br/>
  <p><b>Which of the following statements are true? </b></p>
  <p>The first line inside constructor either super() or this() but not both simultaneously.&nbsp;&nbsp;&#x2713;</p>
  <p>If we are not taking either super() or this() as the first line in the constructor then the compiler will always place this().&nbsp;&nbsp;&#x2717;</p><p>
   ompiler will always generate default constructor.&nbsp;&nbsp;&#x2717;
</p>
<p>Constructor overriding is possible but overloading is not possible.&nbsp;&nbsp; &#x2717;</p>
<p>Even for constructor also inheritance possible.&nbsp;&nbsp;&#x2717;</p>
<p>If the parent class constructor throws some checked exception compulsory child class constructor 
   should throw same exception or its parent.&nbsp;&nbsp;&#x2713;</p>
   <br/>
   <br/>
   <br/>
  <div class="fundamentalclasses" *ngIf="fundclass">
         <h1 class="mt-4">FUNDAMENTAL CLASSES</h1>
     </div>
    
     <div class="ioserialization" *ngIf="ioseriz">
         <h1 class="mt-4">FILE I/O & SERIALIZATION</h1>
     </div>

     <div class="garbagecollector" *ngIf="garbage">
         <h1 class="mt-4">GARBAGE COLLECTION</h1>
     </div> 
     
     <div class="collectionfw" *ngIf="collection">
         <h1 class="mt-4">COLLECTIONS FRAME WORK</h1>
     </div> 

   </div>
 </div>
