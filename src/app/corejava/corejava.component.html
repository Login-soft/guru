
	  
	  <div class="d-flex" id="wrapper">
   <div class="bg-light border-right" id="sidebar-wrapper">
      <div class="list-group list-group-flush">
         <a (click)="languagefundamentals()" class="list-group-item list-group-item-action bg-light">Language
            Fundamentals</a>
         <a (click)="declareandaccesscontrol()" class="list-group-item list-group-item-action bg-light">Declar. & Access
            Control</a>
         <a (click)="flowcontrol()" class="list-group-item list-group-item-action bg-light">Flow Control</a>
         <a (click)="exceptionhandling()" class="list-group-item list-group-item-action bg-light">Exception Handling</a>
         <a (click)="assertions()" class="list-group-item list-group-item-action bg-light">Assertions</a>
         <a (click)="ooconcepts()" class="list-group-item list-group-item-action bg-light">OO Concepts</a>
         <a (click)="innerclasses()" class="list-group-item list-group-item-action bg-light">Inner Classes</a>
         <a (click)="threadconcurrency()" class="list-group-item list-group-item-action bg-light">Thread and
            Concurrency</a>
         <a (click)="fundamentalclasses()" class="list-group-item list-group-item-action bg-light">Fundamental
            Classes</a>
         <a (click)="ioserialization()" class="list-group-item list-group-item-action bg-light">I/O & Serialization</a>
         <a (click)="garbagecollector()" class="list-group-item list-group-item-action bg-light">Garbage Collection</a>
         <a (click)="collectionfw()" class="list-group-item list-group-item-action bg-light">Collections FW &
            Generics</a>
      </div>
   </div>
   <div class="container-fluid">
      <div class="languagefundamentals" *ngIf="languagefundamental1">
         <h1 class="mt-4">LANGUAGE FUNDAMENTALS</h1>
         <ol>
            <li>Identifiers</li>
            <li>Keywords</li>
            <li>Datatypes</li>
            <li>Literals</li>
            <li>Arrays</li>
            <li>Types of variables</li>
            <li>var – arg methods</li>
            <li>command line arguments & main method</li>
            <li>java coding standards</li>
         </ol>
         <p><b>Identifiers:</b><br>
            A name in the program is an identifier it may be class name or method name,variable name or label name.
         </p>
         <p>Ex:- <br>
            <img src="assets/images/identifier.png">
         </p>
         <p><b>Rules for defining Identifiers</b></p>
         <ol>
            <li>A java identifier is a sequence of characters, where each character may be a letter from a-z or A-Z
               or a digit form 0-9 or currency symbol $ or connecting punctuation – , if we are using any other
               symbol we will get Compile time error “IllegalCharacter”.
            </li>
            <li>Identifier should not be starts with digit.</li>
            <li>There is no length limit for java identifiers but it is not recommended to take more than 15
               length.
            </li>
            <li>Java Identifiers are case sensitive</li>
            <img src="assets/images/identifier1.png" id="identifier1">
            <img src="assets/images/identifier2.png" id="identifier1">
         </ol>
         <p><b>Reserved Words</b></p>
         <p>Some identifiers are reserved to associate some functionality or to represent values, such type of reserved
            identifiers are called “ReservedWords”.
         </p>
         <img src="assets/images/reserved.png" id="reserved">
         <p><b>Keywords for Datatypes</b></p>
         <ul>
            <li>byte | short</li>
            <li>int | long</li>
            <li>float | double</li>
            <li>char | boolean</li>
         </ul>
         <p><b>Keywords for FlowControl</b></p>
         <ul>
            <li>if | else | switch | case | default | do | while | for | break | continue | return</li>
         </ul>
         <p><b>Keywords for ExceptionHandling</b></p>
         <ul>
            <li>try | catch | finally | throw | throws | assert (JAVA 1.4V)</li>
         </ul>
         <p><b>Keywords for Modifiers</b></p>
         <ul>
            <li>public | private | protected | final | abstract | static | native | synchronized | volatile | transient
               | strictfp</li>
         </ul>
         <p><b>Class Related Keywords</b></p>
         <ul>
            <li>class | interface | package | extends | implements | import</li>
         </ul>
         <p><b>Object Related Keywords</b></p>
         <ul>
            <li>new | instanceof | super | this</li>
         </ul>
         <p><b>void return type Keywords</b></p>
         <p>if a method doesn’t return anything compulsory that method should be with void return type.</p>
         <p><b>UnUsed Keywords</b></p>
         <ul>
            <li>goto -> in java usage is considered as harmful.</li>
            <li>const -> alternatively we should use final keyword.</li>
         </ul>
         <p><b>Enum Keyword</b></p>
         <p>This keyword has introduced in 1.5 version, to define user defined data types.</p>
         <img src="assets/images/enum.png" id="enum">
         <img src="assets/images/reservedliterals.png" id="enum">
         <p><b>Datatypes</b></p>
         <p>In java every variable has a type, every expression has a type and all types are strictly defined.
            All the assignments should be checked by the compiler for the type compatibility. Hence java language
            considers as strongly typed language.
            Java is not considered as pure object oriented programming language because several OOP features(like
            multiple inheritance, operator overloading) are not supported by java. Even java contains non-object
            primitive datatypes.
         </p>
         <img src="assets/images/primitivedatatypes.png" id="primitivedatatype">
         <p>Except boolean and char all the remaining datatypes are signed datatypes i.e we can represent both +ve and
            –ve numbers.
         </p>
         <p><b>byte</b><br>
            Size : 8-bits<br>
            Range: -128 to 127<br>
            -ve numbers can represented in 2’s compliment form.<br>
            Ex:<br>
            byte b = 10;<br>
            byte b = 127;<br>
            byte b = 130; <i class="fa fa-arrow-right"></i><span style="color:red">C.E: possible loss of
               precision</span><br>
            byte b = true; <i class="fa fa-arrow-right"></i><span style="color:red">C.E: Incompatible types found:
               boolean required: byte</span><br>
            byte datatype is best suitable if we are handling data either from file or form network.
         </p>
         <p><b>short</b> <br>
            size = 2 bytes<br>
            range = -215 to 215 -1 (-32768 to 32767)<br>
            Ex:<br>
            short s = 10;<br>
            short s = 32767;<br>
            short s = 65535;<i class="fa fa-arrow-right"></i> C.E: possible loss of precision.<br>
            short s = true; <i class="fa fa-arrow-right"></i> C.E: Incompatible types<br>
            short is best suitable datatype for 16-bit process. But currently these are completely out dated and
            hence the corresponding datatypes also no one is using.
         </p>
         <p><b>int</b><br>
            The most commonly used datatype is int.<br>
            size = 4 bytes<br>
            range = -231 to 231 – 1(-2147483648 to 2147483747)<br>
            The size of int is always fixed irrespective of platform hence the chance of failing java program is
            very less if u r changing the platform hence the java is considered as Robust.
         </p>
         <p><b>long</b><br>
            if int is not enough to hold big values then we should go for long-datatype<br>
            size = 8 bytes<br>
            range = -263 to 263 – 1<br>
            Ex:
            The amount of distance traveled by light in 1000days can be represented by long
            datatype only and int is not enough.
         </p>
         <img src="assets/images/floating.png" id="floating">
         <p><b>boolean datatye</b><br>
            size = not applicable(virtual machine dependent).<br>
            range = not applicable but allowed values are true/false.<br>
            Which of the following boolean declarations are valid<br>
            boolean b1 = true;<i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
            boolean b2 = 0; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i><i
               class="fa fa-arrow-right" style="margin-left: 20px;"></i> Incompatible types found:int required :
            boolean<br>
            boolean b3 = TRUE; <i class="fa fa-close" style="color: red;margin-left: 10px;"></i><i
               class="fa fa-arrow-right" style="margin-left: 20px;"></i> capital TRUE is not valid.
         </p>
         <textarea rows="11" cols="60" class="textArea" readonly>
      Ex:
      int x = 0;
      if(x)
      {
      System.out.println("Hello");
      }
      else
      {
      System.out.println("Hai");
      }
    </textarea>
         <p>
            <b>OUTPUT</b><i class="fa fa-arrow-right" style="margin-left: 10px;"></i><span class="output"> C.E:
               Incompatible types found :int required: boolean.</span>
         </p>
         <img src="assets/images/char.png" id="floating">
         <p><b>Comparison table for java primitive datatypes</b></p>
         <table class="table table-bordered">
            <thead>
               <tr>
                  <th scope="col">datatype</th>
                  <th scope="col">size</th>
                  <th scope="col">range</th>
                  <th scope="col">Default value</th>
                  <th scope="col">Wrapper class</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <th scope="row">byte</th>
                  <td>1 byte</td>
                  <td>-128 to 127</td>
                  <td>0</td>
                  <td>Byte</td>
               </tr>
               <tr>
                  <th scope="row">short</th>
                  <td>2 bytes</td>
                  <td>-32768 to 32767</td>
                  <td>0</td>
                  <td>Short</td>
               </tr>
               <tr>
                  <th scope="row">int</th>
                  <td>4 bytes</td>
                  <td>-231 to 231-1</td>
                  <td>0</td>
                  <td>Integer</td>
               </tr>
               <tr>
                  <th scope="row">long</th>
                  <td>8 bytes</td>
                  <td>-263 to 263-1</td>
                  <td>0</td>
                  <td>Long</td>
               </tr>
               <tr>
                  <th scope="row">float</th>
                  <td>4 bytes</td>
                  <td>-3.4e38 to 3.4e38</td>
                  <td>0.0</td>
                  <td>Float</td>
               </tr>
               <tr>
                  <th scope="row">double</th>
                  <td>8 bytes</td>
                  <td>-1.7e308 to
                     1.7e308
                  </td>
                  <td>0.0</td>
                  <td>Double</td>
               </tr>
               <tr>
                  <th scope="row">boolean</th>
                  <td>NA</td>
                  <td>NA(But allowed
                     values are true,
                  </td>
                  <td>false</td>
                  <td>Boolean</td>
               </tr>
               <tr>
                  <th scope="row">char</th>
                  <td>2 bytes</td>
                  <td>0 to 65535</td>
                  <td>0(balnk spaces)</td>
                  <td>Character</td>
               </tr>
            </tbody>
         </table>
         <p><b>Literals</b><br>
            A literal represents a constant value which can be assigned to the variables<br>
         </p>
         <img src="assets/images/literals.png" id="literals">
         <p><b>Integral Literal</b><br>
            We can specify an integral literal in the following ways.
         </p>
         <p style="margin-left: 30px;"><b>Decimal literals:</b> allowed digits are 0 to 9 <br>
            <span style="margin-left: 40px;">Ex: int x = 10;</span>
         </p>
         <p style="margin-left: 30px;"><b>Octal literals:</b> allowed digits are 0 to 7 but here literal value should be
            prefixed with 0(zero) <br>
            <span style="margin-left: 40px;">Ex: int x = 010;</span>
         </p>
         <p style="margin-left: 30px;"><b>Hexadecimal literals: </b> the allowed digits are 0 to 9, A- F (Both lower,
            Upper case) literals
            should be prefixed with 0x or oX<br>
            <span style="margin-left: 40px;">Ex: int x = 0x10;</span>
         </p>
         <textarea rows="11" cols="60" class="textArea" readonly>
            Ex:
            class Test{
              public static void main(String arg[]){
               int x = 10;
               int y = 010;
               int z = 0x10;
               System.out.println(x + "..." + y + "..." + z);
              }
            }
            O/P:- 10…8…16
          </textarea>
         <p>Except decimal, octal, hexadecimal there is no other way to represents constant values for the integral
            datatype.<br>
            By default every integral lateral is of int datatype we can specify explicitly. An
            integral literal is of long type by suffixing with l or L.
         </p>
         <p style="margin-left: 80px;">Ex: <br>
            <span style="margin: 30px;">10 <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> int
               value.</span><br>
            <span style="margin: 30px;">10l <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> long
               value.</span><br>
            <span style="margin: 30px;">long l = 10l; </span><br>
            <span style="margin: 30px;">int i = 10l;</span><br>
            <span style="margin: 30px; color: red;">C.E: possible loss of precision found : long Required:int </span>
         </p>
         <img src="assets/images/integralLitrals.png" id="integralLitrals">
         <p>There is no way to specify explicitly an integral literal is of type byte and short.
            If the integral literal is with in the range of byte then the JVM by default treats it as byte literal.
            Similarly short literal also.
         </p>
         <p><b>Floating – point literals</b><br>
            By default floating-point literals are double type we can specify explicitly as float type by suffixing with
            ‘f’ or ‘F’.
         </p>
         <p><b>Which of the following are valid declarations</b><br></p>
         <ol>
            <li>float f = 10.5; <i class="fa fa-close" style="color: red; margin-left: 5px;"></i>
               <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> C.E possible loss of precision
            </li>
            <li>float f = 10.5f; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
            <li>double d = 10.5; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
            <li>double d = 10.5f; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
            <li>double d = 10.5D; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
         </ol>
         <p>we can specify explicitly a floating point literal of double type by suffixing with d or D. we can also
            represent float-point literals by using scientific notation.<br>
            Ex: <br>
            double d = 10e23; <br>
            int i = 10e23; <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> C.E possible loss of precision
            found : double required : int.
         </p>
         <p>Floating point literals can be specified only in decimal form. i.e we can’t use octal and hexa decimal
            representation for floating point literals.<br>
            Ex: <br>
            Double d = 0x123.456; <br>
            C.E: Malformed floating-point literal.
         </p>
         <p><b>Which of the following are valid declarations</b></p>
         <ol>
            <li>float f = 123.456; <i class="fa fa-close" style="color: red; margin-left: 5px;"></i></li>
            <li>float f = 0x123.456F; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
            <li>float f = 0x123; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
            <li>float f = 1.2e36; <i class="fa fa-close" style="color: red; margin-left: 5px;"></i></li>
            <li>double d = 1.2e36; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
         </ol>
         <p><b>Boolean Literals</b><br>
            The only allowed values for boolean datatype are true, false.<br>
            <b>Which of the following are valid declarations</b><br>
            <span style="margin-left: 30px;"> 1. boolean b = true; <i class="fa fa-check"
                  style="color: blue; margin-left: 10px;"></i></span><br>
            <span style="margin-left: 30px;"> 2. boolean b = FALSE; <i class="fa fa-close"
                  style="color: red; margin-left: 10px;"></i></span><br>
            <span style="margin-left: 30px;"> 3. boolean b = 0; <i class="fa fa-close"
                  style="color: red; margin-left: 10px;"></i></span><br>
         </p>
         <p><b>character literal</b><br>
            A char literal can be represented as a single character with in single quotes.
         </p>
         <ol>
            <li>char ch = 'a'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
            <li>char ch = 'ab'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i> <span
                  style="margin-left: 20px;">C.E: unclosed character literal.</span></li>
            <li>char ch = a; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
         </ol>
         <span>we can represent a char literal by using it’s Unicode value. For the allowed Unicode values are 0 to
            65535.</span><br>
         <p>Ex:<br>
            char ch = 97; <br>
            System.out.println(ch); <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> O/P: a <br>
            char ch = 65535; <br>
            char ch = 65536; <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> C.E : possible loss of
            precision found : int required :char
         </p>
         <p>we can represent a char literal by using Unicode representation which is nothing but \uxxxx’ <br>
            Ex: <br>
            char ch = '\u0061' <br>
            System.out.println(ch); <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> O/P:a <br>
            char ch = '\ubeef'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
            char ch = '\uface'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
            char ch = '\iface'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i><br>
            char ch = '\uface'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i><br>
         </p>
         <p>we can also represent a char literal by using escape character. <br>
            Ex: <br>
            char ch = '\b'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
            char ch = '\n'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
            char ch = '\l'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i>
         </p>
         <p>The following is the list of all possible escape characters in java. <br>
            \b <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> backspace <br>
            \n <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> new line <br>
            \r <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> carriage return <br>
            \f <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> formfeed <br>
            \t <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> horizontal tab <br>
            \’ <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> single quote <br>
            \” <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> double quote <br>
            \\ <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> back slash
         </p>
         <p><b>Which of the following char declarations are valid?</b></p>
         <ol>
            <li>char ch = 'c'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
            <li>char ch = 'abc'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
            <li>char ch = a ; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
            <li>char ch = 65123; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
            <li>char ch = 65537; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
            <li>char ch = \uabcd; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
            <li>char ch = '\uanuska'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
            <li>char ch = '\ubeef'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
            <li>char ch = '\r'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
            <li>char ch = '\t'; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
            <li>char ch = '\d'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
         </ol>
         <p><b>String literal</b></p>
         <ol>
            <li>String s = "Durga"; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
            <li>String s = 'software'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
            <li>String s = 'a'; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
         </ol>
         <p><b>Arrays</b></p>
         <p>An array is a data structure that represents an index collection of fixed no of homogeneous data
            elements. The main advantage of arrays is we can represent a group of values with single name
            hence readability of the code will be improved. The main limitation of arrays is they are fixed in size.
            i.e once we constructed an array there is no chance of increasing or decreasing bases on our
            requirement hence with respect to memory arrays shows worst performance we can overcome this
            problem by using collections.
         </p>
         <p><b>Array Declaration</b> <br>
            The following are the ways to declare an array. <br>
            1) int [] a; <br>
            2) int a[]; <br>
            3) int [] a; <br>
            The first one is recommended to use because the type is clearly separated from the name. At the first time
            of declarations we are not allowed to specify the size. Violation leads to C.E. <br>
            Ex: <br>
            int[] a; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
            int[6] a; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i>
         </p>
         <p><b>Declaring Multidimensional Arrays</b><br>
            The following are the valid declarations for multidimensional arrays. <br>
            int[][] a; <br>
            int a[][]; <br>
            int [][]a; <br>
            int[] a[]; <br>
            int[] []a; <br>
            we can specify the dimension before name of variable also, but this facility is available only for the first
            variable. <br>
            int[] a[],b[]; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
            int[] []a,[]b; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i>
         </p>
         <p><b>Which of the following declarations are valid?</b></p>
         <ol>
            <li>int[2][3] a; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
            <li>int[] a,b; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
            <li>int[] a[],b[]; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
            <li>int []a,[]b; <i class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
            <li>int []a,b[]; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
         </ol>
		 

     <p><b>Construction of Arrays <br>Single Dimension :</b><br>Arrays are internally implemented as object hence by
            using new operator we can
            construct an array.<br>Compulsory at the time of construction we should specify the size otherwise compile
            time error.<br>
            Ex: <br>
			
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int[] a = new int[10]; <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> <i class="fa fa-check"
               style="color: blue; margin-left: 10px;"></i><br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int[] a = new int[]; <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> C.E <br>
            It is legal to have an error with size 0 there is no C.E or R.E <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int[] a = new int[0]; <br>
            If we are specifying array size with some –ve integer <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int[] a = new int[-10]; <br>
            we will get R.E saying NegativeArraySizeException.
         </p>
         <p>The only allowed Data type to allow the size are byte, short, char, int. if we are using any other datatype
            we will get a C.E.</p>
         <ul>
            <li>int[] a = new int[10]; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
            <li>int[] a1 = new int[10l]; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
            <li>int[] a = new int[10l]; <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> C.E possible loss
               of precision found: long required: int
            <li>int[] a = new int[10.5]; <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> C.E </li>
            <li>int[] a = new int[true]; <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> C.E Incompatible
               types found : boolean required:int.</li>
         </ul>
         <span>The maximum allowed Array Size in java is 2147483648.</span>
      </div>
      <p><b>Multi Dimension:</b> In java multidimensional arrays are implemented as single dimension arrays. This
approach improves performance with respect to memory<p>
<br>
<img src="assets/images/MultiDimension.JPG" id="MultiDimension">

<p><b>How to declare an array for the following diagrams?</b></p>
<br>
<img src="assets/images/MultiDimension2.JPG" id="MultiDimension2">
<p><b>Which of the following Array declarations are valid?</b></p>
int [][] a = new int[3][4];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10132; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
int [][] a = new int[3][]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10132;<i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
int [][] a = new int[][4]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10132;<i class="fa fa-close" style="color: red; margin-left: 10px;"></i><br>
int [][] a = new int[][]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10132;<i class="fa fa-close" style="color: red; margin-left: 10px;"></i><br>
int [][][] a = new int[3][4][]; &nbsp;&nbsp;&#10132;<i class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
int [][][] a = new int[3][][5]; &nbsp;&nbsp;&#10132;<i class="fa fa-close" style="color: red; margin-left: 10px;"></i><br>
<p><b>Initialization of arrays</b><br>Once we created an array all it’s elements initialized with default values.</p>
<img src="assets/images/Initializationofarrays.JPG" id="Initializationofarrays">
<br>

<br>
<p>when ever we are trying to access an array with int index which is not in valid range then we will get
runtime exception saying “ArrayIndexOutOfBoundsException”. But there is no C.E.
If we are trying to access an array index with the following datatype we will get C.E.
float, double, long, boolean.
</p>
<p><b>Declaration Construction and Initialization in a single line</b>
</p>

<ul>
<li>int []a;</li>
<li>a = new int[3];</li>
<li>a[0] = 10;</li>
<li>a[1] = 20;
</li>
<li>a[2] = 30;</li>
</ul>
<p>All these statements we can replace with a single line as follows.</p>


<ul>
<li>int[] a = &#10100;10,20,30&#10101;;</li>
<li>String[] s = &#10100;“Chiru”,”Allu”,”Ram”,”Akil”&#10101;
</li>
</ul>
<p>If we want to use the above shortcut technique compulsory we should perform declaration,
construction initialization in a single line only. If we are dividing into 2 lines we will get C.E.
</p>

<textarea rows="7" cols="60" class="textArea" readonly>
      Ex:
               int[] a;
               a = &#10100;10,20,30,40&#10101;;
               C.E: illegal start of expression.
               int[][] a = &#10100;&#10100;10,20&#10101;,&#10100;30,40,50&#10101;&#10101;;
               int[][][] a = &#10100;&#10100;&#10100;10,20},&#10100;30,40&#10101;,&#10100;&#10100;50,60&#10101;,&#10100;70,80&#10101;&#10101;&#10101;;
</textarea>
<p><b>length Vs length();</b></p>
<p><b>length: </b> 1) It is the final variable applicable for array objects.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) It represents the size of the array.</p>
<textarea rows="5" cols="60" class="textArea" readonly>
   Ex:
            int [] a = new int[5];
            System.out.println(a.length()); &#10132; C.E
            System.out.println(a.length);&nbsp;&nbsp; &#10132; 6
</textarea>


<p><b>length: </b> 1) 1) It is the final method applicable only for String Objects.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) It represents the no of characters present in the String.</p>

<textarea rows="5" cols="60" class="textArea" readonly>
   Ex:
            String s = "raju";
            System.out.println(s.length); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10132; C.E
            System.out.println(s.length());&nbsp; &nbsp;&nbsp;&#10132; 4

</textarea>
<p>In the case of Multidimensional array length variable always represent base size but not total no of
elements.
</p>
<textarea rows="5" cols="60" class="textArea" readonly>
   Ex:
            int[][] a = new [3][2];
            System.out.println(a.length);
            System.out.println(a[0].length);


</textarea>
<p>There is no variable which represents the total no of elements present in multidimensional arrays.</p>
<p><b>Anonymous Arrays
</b><br>
Some times we can declare an array with out name also such type of arrays are called anonymous
arrays.<br>
The main objective of anonymous arrays is just for temporary usage. We can create an anonymous
arrays as follows
</p>
<textarea rows="18" cols="60" class="textArea" readonly>
   Ex:
            new int[] {10,20,30} &nbsp; &nbsp;&nbsp;&#9747;
            class Test
            {
            public static void main(String arg[])
            {
            System.out.println(sum(new int[]{10,20,30,40}));
            }
            public static int sum(int[] a)
            {
            int total = 0;
            for(int i = 0; i< a.length;i++)
            {
            total = total + a[i];
            }
            return total;
            }
            }

</textarea>
<p><b>Array Element Assignments</b><br>
In the case of primitive arrays as array element any datatype is allowed which can be implicitly
promoted to the declared type.
</p>
<textarea rows="12" cols="75" class="textArea" readonly>
   Ex:
            int [] a = new int[10];
            in this case the following datatypes are allowed as array elements.
            byte, short, int, char.
            a[0] = 10;
            a[1] = 'a';
            byte b = 20;
            a[2] = b;
            a[3] = 10.5; &nbsp; &nbsp;&nbsp;&#9747; possible loss of precision. found : double
            required: int
</textarea>
<p>in the case of object arrays as array elements we can provide either declared type object or it’s child
class objects.</p>
<ul>
<li>
Number[] n = new Number[6];

</li>
<li>n[0] = new Integer(10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10132; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li>
<li>n[1] = new Long(10l);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10132; <i class="fa fa-check" style="color: blue; margin-left: 10px;"></i>
</li>
<li>n[2] = new String("raju");

&nbsp;&nbsp;&#10132;<i class="fa fa-close" style="color: red; margin-left: 10px;"></i>
 Incompatible types found : String.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;required : Number.</li>


</ul>
<img src="assets/images/ArrayElementAssignments.JPG" id="ArrayElementAssignments">
<p>If we declare an array of interface type we are allowed to provide it’s implementation class object as
elements.<br>
Runnable[] = new Runnable[]<br>
r[0] = new Thread();</p>

<p>If we declare an array of interface type we are allowed to provide it’s implementation class object as
elements.
</p>

<ul>
<li>Runnable[] = new Runnable[]</li>
<li>r[0] = new Thread();
</li></ul>
<p><b>Array Variable Assignments
</b><br>
A char element can be promoted as the int element but a char array can’t be prompted to int array</p>

<textarea rows="10" cols="75" class="textArea" readonly>

Ex:
int [] a = new int[6];
int [] b = a;
char[] ch = {'a','b','c'};
int [] c = ch; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10132; Incompatible types found : char[]
required:int[]
</textarea>

<p><b>which of the following promotions are possible?</b></p>
<ul>
<li>int &#10132; double
</li><i class="fa fa-check" style="color: blue; margin-left: 10px;"></i>
<li>float &#10132; long</li><i class="fa fa-close" style="color: red; margin-left: 10px;"></i>
<li>int[] &#10132; float[]</li><i class="fa fa-close" style="color: red; margin-left: 10px;"></i>
<li>char[] &#10132; int[]</li><i class="fa fa-close" style="color: red; margin-left: 10px;"></i>
<li>boolean &#10132; int</li><i class="fa fa-close" style="color: red; margin-left: 10px;"></i>
<li>int &#10132; Boolean</li><i class="fa fa-close" style="color: red; margin-left: 10px;"></i>


</ul>
<p>when ever we are assigning one array to another array compiler will check only the types instead of
sizes
<ul>
<li>int[] a = &#10100;10,20,30,40&#10101;</li>
<li>int[] b = &#10100;60,70&#10101;</li>
</ul>
<img src="assets/images/JavaImage1.JPG" id="JavaImage1">


<br>
<p>See the following example.</p>

<textarea rows="10" cols="75" class="textArea" readonly>
   Ex:
            int [][] a = new int[3][];
            a[0] = new int[4];
            a[1] = new int[4][5]; &#10132; Incompatible types found: int[][]
            required: int[]
            a[2] = 10; &#10132; Incompatible types found: int
            required: int[]
</textarea>

<p><b>Types of Variables</b><br>
Based on the type of value represented by the variable all the variables are divided into two types.
</p>
<img src="assets/images/TypesofVariables.JPG" id="TypesofVariables">
<p>Base on the purpose and position of declaration all variables are divided into 3 types.<br>
1) instance variables<br>
2) static variables<br>
3) local variables<br>
</p>

<p><b>instance variables
</b><br>
if the value of a variable is varied from object to object. Such type of variables are called
instance variables. For every object a separate copy of instance variables will be created.<br>

Instance variables will be crated at the time of object creation and will be destroyed at the
time of object destruction i.e the scope of instance variables is exactly same as the scope of
object.<br>
We have to declare instance variables with in the class but outside of any method (or)
constructor or block.
</p>
<p>For the instance variables no need to perform initialization. JVM will always provide values.</p>
<textarea rows="12" cols="75" class="textArea" readonly>
   Ex:
            class Test
            {
            int i;
            public static void main(String arg[])
            {
            Test t = new Test();
            System.out.println(t.i);
            }
            }
</textarea>

<p>Instance variables also known as ‘attributes’.</p>
<p><b>static variable</b><br>
if the value of a variable is fixed for all objects then it is not recommended to declare that variable at
instance level. Such type of variables we have to declare at class level by using static keyword.<br>
For the static variables a single copy will be created at class level and shared by all objects of that
class.<br>
Static variables should be declared with in the class but outside of any method or block or
constructor.<br>
Static variables will be created at the time of class loading and destroyed at the time of unloading.
We can access static variables either by using class name or by using object reference using class
name is recommended.<br>

</p>
<textarea rows="15" cols="75" class="textArea" readonly>
   Ex:
            class Test
            {
            int i;
            static int j = 10;
            public static void main(String arg[])
            {
            Test t1 = new Test();
            t1.i = 888;
            t1.j = 999;
            Test t2 = new Test();
            System.out.println(t2.i+" ----"+t2.j);
            }
            }
</textarea>
<p><b>O/P:-</b>10----999</p>
<br>

<img src="assets/images/staticvariables.PNG" id="staticvariables">
<p>For the static variables no need to perform initialization JVM will always provide default values.</p>
<textarea rows="12" cols="75" class="textArea" readonly>
   Ex:
            class Test
            {
            static int i;
            public static void main(String arg[])
            {
            System.out.println(i); &#10132; 0
            }
            }
</textarea>

<p><b>LocalVariables</b><br>

If we are declaring a variable with in a method or constants or block such type of variables are called
local variables. Local variables also known as temporary variable or ‘automatic variable’. Local
variables will be created as the part of method execution and will be destroyed once the method
completes.<br>
For the local variables JVM won’t provide any default values. Before using a local variable
compulsory we should perform initialization explicitly otherwise compile time error.

</p>
<textarea rows="18" cols="90" class="textArea" readonly>
	Ex:
		class Test
		{
		public static void main(String arg[])
		{
		int i;
		System.out.println(i);
		}
		}
		C.E: variable ‘i’ might not have been initialized.
		class Test
		{
		public static void main(String arg[])
		{
		int i;
		System.out.println("Hello");
		}
		}
</textarea>
<p><b>O/P:-</b>Hello</p>
<P>Because we didn’t use ‘i’.</P>
<textarea rows="15" cols="75" class="textArea" readonly>
	Ex:
		class Test
		{
		public static void main(String arg[])
		{
		int i;
		if(arg.length 	&gt; 0)
		{
		i = 10;
		}
		System.out.println(i);
		}
		}
</textarea>
<p>C.E: variable ‘i’ might not have been initialized because we may give or not arguments at
runtime so before that compiler will generate error.</p>

<textarea rows="18" cols="75" class="textArea" readonly>
	Ex:
		class Test
		{
		public static void main(String arg[])
		{
		int i;
		if(arg.length 	&gt; 0)
		{
		i = 10;
		}
		else
		{
		i = 20;
		}
		System.out.println(i);
		}
		}
</textarea>

<p><b>O/P:-</b>





Because if we give arguments 10 will be initialized other wise 20 will be initialized.<br>
It is not good programming practice to perform initialization in logical blocks for local variables
because they may not execute at runtime.<br>
The only applicable modifier for the local variable is final. If we are using any other modifier we will
get compile time error.<br>
For the static and instance variables JVM will always provide default values. But for the local
variables JVM won’t provide default values compulsory we should perform initialization before
using.
</p>



<p><b>Un initialized Arrays</b></p>


<textarea rows="15" cols="75" class="textArea" readonly>
	Ex:
		class Test
		{
		int[] a;
		public static void main(String arg[])
		{
		Test t = new Test();
		System.out.println(t.a); &#10132; null
		System.out.println(t.a[0]); &#10132; NullPointerException
		}
		}
</textarea>
<p><b>Instance Level</b></p>
<p>
1) int[] a;<br>
System.out.println(objectref.a) &#10132; null<br>
System.out.println(objectref.a[0]) &#10132; NullPointerException.<br>

2) int[] a = new int[6];<br>
System.out.println(objectref.a); &#10132; [I@123<br>
System.out.println(objectref.a[0]); &#10132;  0;

</p>

<p><b>Satic level</b></p>
<br>
<img src="assets/images/Locallevel.PNG" id="Locallevel">
<br>
<p><b>Note: </b>If we are creating an array all it’s elements are automatically initialized with default values.
Even though it is local array.</p>


<p><b>var- arg methods</b>

From 1.5 version on words we are allowed to declare a method with variable no of arguments such type of
methods are called var-arg methods.<br>
We can declare a var-arg methoda as follows<br>
m1(int… i);<br>
this methods is applicable for any no of int arguments including zero no of arguments.

</p>

<textarea rows="15" cols="75" class="textArea" readonly>
	Ex:
		class Test
		{
		public static void m1(int... i)
		{
		System.out.println("var-arg methods");
		}
		public static void main(String arg[])
		{
		m1(); &nbsp;&nbsp;&nbsp;&#10132; var-arg methods
		m1(10); &nbsp;&nbsp;&nbsp;&#10132; var-arg methods
		m1(10,20); &nbsp;&nbsp;&nbsp;&#10132; var-arg methods
		m1(10,20,30); &nbsp;&nbsp;&nbsp;&#10132; var-arg methods
		}
		}
</textarea>


<p>

‘var-arg’ methods internally implemented by using single dimensional arrays. Hence we can differentiate
arguments by using index.
</p>
<textarea rows="22" cols="75" class="textArea" readonly>
	Ex:
		class Test
		{
		public static void main(String arg[])
		{
		sum(10,20);
		sum(10,20,30,40);
		sum(10);
		sum();
		}
		public static void sum(int... a)
		{
		int total = 0;
		for (int i=0;i&lt;a.length ;i++ )
		{
		total = total+a[i];
		}
		System.out.println("The sum is:"+total);
		}
		}
</textarea>
<p><b>O/P:-</b></p>
<br>
<img src="assets/images/Localleveloutput.PNG" id="Localleveloutput">
<br>

<p>


We can mix general parameter with var-arg parameter.<br>
Ex:<br>
m1(char ch, int…a)<br>
If we are mixing general parameters with var-arg parameter then var-arg parameter must be the last
parameter otherwise compile time error.<br>
Ex:<br>
m1(int… a, float f) &nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-check"
               style="color: blue; margin-left: 10px;"></i><br>
m1(float f, int… a)&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-close"
               style="color: red; margin-left: 10px;"></i><br>
we can’t take more than one var-arg parameter in var-arg method otherwise C.E.<br>
m1(int… a double… d)&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-close"
               style="color: red; margin-left: 10px;"></i><br>
which of the following are valid var-arg declarations.<br>
m1(int... a)&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-check"
               style="color: blue; margin-left: 10px;"></i><br>
m1(int. ..a) &nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-close"
               style="color: red; margin-left: 10px;"></i>&nbsp;&nbsp;&nbsp;&nbsp;C.E: malformed function<br>
m1(char ch, int... a)&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-check"
               style="color: blue; margin-left: 10px;"></i><br>
m1(int... a, char ch)&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-close"
               style="color: red; margin-left: 10px;"></i><br>
m1(int...a, boolean... b)&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-check"
               style="color: blue; margin-left: 10px;"></i><br>





</p>

<textarea rows="20" cols="75" class="textArea" readonly>
	Ex:
		class Test
		{
		public static void m1(int i)
		{
		System.out.println("General method");
		}
		public static void m1(int... i)
		{
		System.out.println("var-arg method");
		}
		public static void m1(String arg[])
		{
		m1();
		m1(10,20);
		m1(10);
		}
		}
</textarea>
<p>

Var-arg method will always get least priority i.e if no other method matched then only var-arg method will
be executed.</p>


<p><b>Command line arguments & main() metho</b>JVM always calls main method to start the program. Compiler is not responsible to check whether the class
contain main() or not. Hence if we are not the main method we won’t get any C.E. But at runtime JVM
raises NoSuchMethodError:main</p>

<img src="assets/images/commandlineargument.PNG" id="commandlineargument">
<br>

<p>If we perform any changes in main() we will get NoSuchMethodError:main() at runtime. But no C.E.
The main() can be declared as final and synchronized.</p>


<p><b>Which of the following main() are valid?</b></p>

<p>



public static void main(String arg)&#10100;&#10101;&nbsp;&nbsp;&nbsp; &#10132;&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-close"
               style="color: red; margin-left: 10px;"></i><br>
public static void main(String arg[])&#10100;return 10;&#10101; &nbsp;&nbsp;&nbsp;&#10132;&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-close"
               style="color: red; margin-left: 10px;"></i><br>
public void main(String arg[])&#10100;&#10101; ;&nbsp;&nbsp;&nbsp; &#10132; &nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-close"
               style="color: red; margin-left: 10px;"></i><br>
public static final synchronized main(String arg[])&#10100;&#10101; &nbsp;&nbsp;&nbsp;&#10132;&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-close"
               style="color: red; margin-left: 10px;"></i><br>
public static final synchronized void main(String arg[])&#10100;&#10101; &nbsp;&nbsp;&nbsp;&#10132;<i class="fa fa-check"
               style="color: blue; margin-left: 10px;"></i><br>
public static final void main(String arg[])&#10100;&#10101;&nbsp;&nbsp;&nbsp;&#10132;<i class="fa fa-check"
               style="color: blue; margin-left: 10px;"></i><br>

</p>
<p><b>Command line arguments</b>


<br>
We can send command line argument to the main() by using<br>
arg[0] &nbsp;&nbsp;&nbsp;&#10132; first command line argument<br>
arg[0] &nbsp;&nbsp;&nbsp;&#10132; first command line argument<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<br>
args.length &nbsp;&nbsp;&nbsp;&#10132; no of command line arguments<br>
</p>


<p><b>write a code to display all command line arguments?</b></p>

<textarea rows="10" cols="95" class="textArea" readonly>
	Ex:
		for (int i = 0;i < args.length ;i++ )
		{
		System.out.println(arg[i]);
		}
		for (int i = 0;i <= args.length ;i++ )
		{
		System.out.println(arg[i]); &nbsp;&nbsp;&nbsp;&#10132; C.E ArrayIndexOutOfBoundsException
		}
</textarea>


<p><b>Java coding Standards</b></p>
<p><b>Coding standards for classes</b>Usually class name should be noun. Should starts with upper case letter and if it contain multiple
words every inner words also should start with capital letters.</p>
<p>
Ex:<br>
&nbsp;&nbsp;&nbsp;&nbsp;String<br>
&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer<br>
&nbsp;&nbsp;&nbsp;&nbsp;NumberFormat<br>
&nbsp;&nbsp;&nbsp;&nbsp;CustomerInformation
</p>
<p><b>Coding standards for Interfaces</b>

Usually interface named should be adjective, starts with capital letters and if it contains multiple
words, every inner word also should starts with capital letter.
</p>

<p>

Ex:<br>
&nbsp;&nbsp;&nbsp;&nbsp;Runnable<br>
&nbsp;&nbsp;&nbsp;&nbsp;Serializable<br>
&nbsp;&nbsp;&nbsp;&nbsp;Clonable<br>
&nbsp;&nbsp;&nbsp;&nbsp;Movable<br>
&nbsp;&nbsp;&nbsp;&nbsp;Transferable<br>
&nbsp;&nbsp;&nbsp;&nbsp;Workable

</p>


<p><b>Coding standards with methods</b><br>
Values should be either verbs or verb + noun combination.<br>
Starts with lower case and every inner words starts with upper case(this convention is also called
camel case convention).<br>
Ex:<br>
&nbsp;&nbsp;&nbsp;&nbsp;getName(), getMessage(), toString(), show(), display().</p>

<p><b>Coding standards for variables</b><br>


Usually the variable starts with noun and every inner word should start with upper case i.e camel
case convention.<br>
Ex:<br>
&nbsp;&nbsp;&nbsp;&nbsp;Name, rollno, bandwidth, totalNumber.
</p>

<p><b>Coding standards for constants</b><br>

It should be noun, it should contain only upper case letters and works are separated with underscores.<br>
Ex:<br>
&nbsp;&nbsp;&nbsp;&nbsp;MAX_SIZE, MIN_PRIORITY, COLLEGE_NAME.

</p>

<p><b>Java Been Coding Conventions</b><br>

A java bean is a normal java class with private properties & public getter and setter methods.

</p>

<textarea rows="15" cols="75" class="textArea" readonly>
	Ex:
		public class StudentBeen
		{
		private String name;
		public String getName()
		{
		return name;
		}
		public void setName(String name)
		{
		this.name = name;
		}
		}
</textarea>


<p><b>Syntax for getterMethod</b><br>

Compulsory it should be public & should not contain any arguments.<br>
For the non boolean property xxx the following is syntax of getter method<br>
public datatype getXxx()<br>
&#10100;<br>
return xxx;<br>
&#10101;<br>
For the boolean property xxx the following is the syntax<br>
public boolean getXxx() or isXxx()<br>
&#10100;<br>
return xxx;<br>
&#10101;

</p>

<p><b>Syntax of setter Method</b><br>

It should be public and return type should be void. For any propertyxxx<br>
public void setXxx(datatype xxx)<br>
&#10100;<br>
This.xxx = xxx;<br>
&#10101;<br>
</p>


<p><b>To register a listener</b><br>


To register myActionListener x which of the following is valid coding convention.<br>
public void addMyActionListener(myActionListener x);&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-check"
               style="color: blue; margin-left: 10px;"></i><br>
public void addActionListener(myActionListener x);&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-close"
               style="color: red; margin-left: 10px;"></i><br>
public void registerMyActionListener(myActionListener x);&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-close"
               style="color: red; margin-left: 10px;"></i><br>
Similarly to un register myActionListener x which of the following are valid coding convention.<br>
public void removeMyActionListener(myActionListener x);<br>
public void removeActionListener(myActionListener x);<br>
public void registerMyActionListener(myActionListener x);<br>

</p>
	  
	  
	  
	  
	  
	  
	  
      <div class="exceptionhandling" *ngIf="exception">
       
<h1 class="mt-4">EXCEPTIONHANDLING</h1>
<b>Introduction</b><br>
It is an unexpected unwanted event which disturbs entire flow of the program.<br>
RealTimeExample:<br>
<ol>
<li>SleepingException</li>
<li>TirePuncharedException</li>
</ol>
<p>If we are not handling exception, the program may terminate abnormally with out releasing allocated
resources. This is not a graceful termination. Being a good programming practice compulsory we should
handle exceptions for graceful termination of the program.
</p>
<p>Exception handling means it is not repairing an exception we are providing alternative way to continue the
program normally. For example if out programming requirement is to read the data from London file, if at
runtime London file is not available, we have to provide a local file as the part of exception handling. So
that respect of the program will be continued normally.
</p>
<p><b>Runtime Stack Mechanism</b></p>
<p>For every thread JVM will create a runtime stack. All the method calls performed by the thread will be
sorted in the corresponding runtime stack. If a method terminates normally the corresponding entry from the
stack will be removed.
</p>
<p>After completing all the method calls the stack is empty. Just before terminating the thread JVM will destroy the corresponding stack.</p>
<textarea rows="17" cols="80" class="textArea" readonly>
   Ex:
            class ExceptionDemo
            {
            public static void main(String[] args)
            {
            doStuff();
            }
            public static void doStuff()
            {
            doMoreStuff();
            }
            public static void doMoreStuff()
            {
            System.out.println("Hi this is Exception ...........Thread");
            }
            }
</textarea>
<br/>
<br>
<p><img src="assets/images/stackmachenism.png" id="stackmachenism"></p>

<p><b>Default Exception Handling</b></p>
<textarea rows="15" cols="70" class="textArea" readonly>
   Ex:
            class ExceptionDemo
            {
            public static void main(String[] args)
            {
            doStuff();
            }
            public static void doStuff()
            {
            doMoreStuff();
            }
            public static void doMoreStuff()
            {
            System.out.println(10/0);
            }
            }

</textarea>
<br>
<br>
<p><b>O/P:-
</b></p>
<p><img src="assets/images/ExceptionHandling12.JPG"></p>


<p> When ever an exception raised the method in which it is raised is responsible for the preparation of
exception object by including the following information<br>
Name of Exception.<br>
Description.<br>
Location of Exception.</p>

<p>After preparation of Exception Object, The method handovers the object to the JVM, JVM will check for
Exception handling code in that method if the method doesn’t contain any exception handling code then
JVM terminates that method abnormally and removes corresponding entry from the stack.</p>
<p>JVM will check for exception handling code in the caller and if the caller method also doesn’t contain
exception handling code then JVM terminates that caller method abnormally and removes corresponding
entry from the stack.</p>
<p>This process will be continued until main method and if the main method also doesn’t contain any exception
handling code then JVM terminates main method abnormally.</p>
<p>
Just before terminating the program JVM handovers the responsibilities of exception handling to default
exception handler. Default exception handler prints the error in the following format.
Name of Exception : Description
stackTrace</p>

<p><b>Exception Hierarchy</b></p>
<p>Throwable is the parent of entire java exception hierarchy. It has 2 child classes<br>
1) Exception.<br>
2) Error</p>
<p><b>Exception</b></p>
<p>These are recoverable. Most of the cases exceptions are raised due to program code only.</p>

<p><b>Error</b></p>
<p>Errors are non-recoverable. Most of the cases errors are due to lack of system resources but not due
to our programs</p>

<p><b>Checked Vs UnChecked</b></p>
<p>The Exceptions which are checked by the compiler for smooth execution of the program at runtime
are called ‘checked exception’<br>
Ex:- IOException, ServletException, InterruptedException.<br>
The Exceptions which are unable to checked by the compiler are called ‘unchecked exceptions’
Runtimeexception and it’s child classes, Error and it’s child classes are considered as unchecked
exceptions and all the remaining considered as checked.<br>
Whether the exception is checked or unchecked it always occur at runtime only.
</p>

<p><b>Partially checked Vs fully checked</b></p>
<p>A checked exception is said to be fully checked iff all it’s child classes also checked.<br>
Ex:- IOException.<br>
A checked exception is said to be partially checked if some of it’s child classes are not checked.<br> 
Ex:- Exception, Throwable.</p>
<p><img src="assets/images/exceptionHandling10.png"></p>

<p><b>Exception Handling By Using try ,catch</b></p>
<P>We have to place the risky code inside the try block and the corresponding exception handling code inside
catch block.</P>
<textarea rows="10" cols="80" class="textArea" readonly>
   Ex:-
            try
            {
            //Risky code
            }
            catch (X e)
            {
            //handling code
            }

</textarea>

<p><b>Without Exception handling code</b></p>

<p><img src="assets/images/ExceptionHandling13.JPG"></p>
<p><b>Control Flow in try, catch</b></p>
<textarea rows="13" cols="80" class="textArea" readonly>
   Ex:-
            try
            {
            statement 1;
            statement 2;
            statement 3;
            }
            catch (X e)
            {
            statement 4;
            }
            statement 5;
</textarea>
<p>Case1: if there is no exception<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,2,3,5 normal termination.<br>
Case2: if there is an exception raised at statement 2 and the corresponding catch block matched.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,4,5 normal termination.<br>
Case3: if an exception raised at statement 2 but the corresponding catch block is not matched<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 Abnormal termination.<br> 
Case4: if an exception raised at statement 4 or statement 5 it is always abnormal termination.
</p>
<p><b>The Methods to display Exception Information</b></p>
<p>Throwable class contains the following methods to display error information.<br>
<b>printStackTrace:</b> It displays error information in the following format.<br>
Name of Exception : Description<br>
StackTace.<br>
<b>toString:</b> it displays error in the following format.<br>
Name of Exception : Description<br>
<b>getMessage:</b>it displays error information in the following format.<br>
Description</p>
<p><img src="assets/images/ExceptionHandling15.JPG"></p>

<p><b>try with multiple catch blocks</b></p>
<p>The way of handling exception is valid from exception to exception. Hence for every exception we should
define corresponding catch blocks hence try with multiple catch blocks is possible.</p>

<textarea rows="20" cols="80" class="textArea" readonly>
Ex:-
         try
         {
         risky code
         }
         catch (ArithmeticException e )
         {
         //handler to A.E
         }
         catch (NullPointerException e)
         {
         //handler for N.P.E
         }
         catch(IOException e)
         {
         //handler for IOException
         }
         catch(Exception e)
         {
         //handler for Exception
         }
</textarea>
<p>In the case of try with multiple catch blocks the order of catch blocks is important. And it should be from
child to parent other wise Compiler Error. Saying Exception xxx has already been caught</p>
<p><img src="assets/images/ExceptionHandling16.JPG"></p>
<p>C.E java.lang.ArithmeticException has already been caught</p>
<p>If there is no chance of raising an exception in try statement then we r not allowed to maintain catch block
for that exception violation leads to compile time error but this rule is applicable only for fully checked
exceptions.
</p>
<p><img src="assets/images/ExceptionHandling17.JPG"></p>

<p><b>finally</b></p>
<p>It is not recommended to place cleanup code inside try statement because there is no guarantee for
execution of all statements inside try block.</p>
<p>It is not recommended to maintain cleanup code with in the catch block because if there is no execution the
catch blocks won’t be executed.<br>
We required a block to maintain cleanup code which should execute always irrespective of whether the
exception is raised or not whether it is handled or not , such block is nothing but “finally block”
Hence the main objective of finally block is to maintain cleanup code.</p>
<p><img src="assets/images/ExceptionHandling17.JPG"></p>


<p>Hence finally block should always execute irrespective of whether the execution is raised or not raised or
handled or not handled.
The finally block won’t be executed if the system it self exists(JVM shutdown) i.e in the case of
System.exit() finally block won’t be executed.
</p>
<textarea rows="15" cols="80" class="textArea" readonly>
   try
            {
            System.out.println("Hi");
            System.exit(0);
            }
            catch (ArithmeticException e)
            {
            System.out.println("catch");
            }
            finally
            {
            System.out.println("finally");
            }
</textarea>



<p><b>O/P:-</b>Hi</p>
<p>B>Difference Between final, finally, finalize</p>
<p><b>final:</b> It is the modifier applicable for classes methods and variables. For final classes we can’t create
child classes i.e inheritance is not possible.<br>final() methods can’t be override in child classes for final variables reassignments is not possible
because they are constants.
</p>
<p><b>finally:</b> It is a block associated with try catch the main objective of finally block is to maintain
cleanup code which should execute always.
</p>

<p><b>finalize: </b> It is a method should be executed by the “Garbage Collector” just before destroying an
object. The main objective of finalize method is to maintain cleanup code</p>

<p>Note:- when compared with finalize, finally is always recommended to maintain cleanup code because there
is no guarantee for the exact behavior of “Garbage Collector” it is Virtual Machine Dependent.</p>
<p><img src="assets/images/ExceptionHandling19.JPG"></p>
<p><img src="assets/images/ExceptionHandling20.JPG"></p>

<p><b>Control flow in try - catch – finally</b></p>
<p>The following program will demonstrates the control flow in different cases.</p>

<textarea rows="17" cols="80" class="textArea" readonly>
   Ex:
            class ExceptionDemo
            {
            public static void main(String arg[])
            {
            try
            {
            statement1;
            statement2;
            statement3;
            }
            catch (X e)
            {
            statement4;
            }
            finally
            {
            statement5;
            }
            statement6;
            }
            }

</textarea>

<p>Case1: if there is no exception, then the statements 1, 2, 3, 5, 6 will execute with normal termination.<br>
Case2: if an exception raised at statement-2 and the corresponding catch block matched, then the
statements 1, 4, 5, 6 will execute with normal termination.<br>
Case3: if an exception raised at statement-2 but the corresponding catch block not matched then the
statements 1, 5, 6 will execute with abnormal termination.<br>
Case4: if an exception raised at statement-2 and while executing the corresponding catch block at
statement–4 an exception raised then the statements 1, 5 will execute with abnormal termination.<br>
Case5: if an exception raised at statement-5 or at statement-6 then it is always abnormal condition.</p>

<p><b>Control flow in nested try – catch – finally</b></p>
<p>The following program will demonstrates the flow of nested try –catch – finally</p>

<textarea rows="28" cols="80" class="textArea" readonly>
   Ex:
            try
            {
            statement 1;
            statement 2;
            statement 3;
            try
            {
            statement 4;
            statement 5;
            statement 6;
            }
            catch (X e)
            {
            statement 7;
            }
            finally
            {
            statement 8;
            }
            statement 9;
            }
            catch (Y e)
            {
            statement 10;
            }
            finally
            {
            statement 11;
            }
            statement 12;
            }
</textarea>
<p>Case1: if there is no exception then the statements 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12 will execute with
normal termination.<br>
Case2: if an exception raised at statement-2 and the corresponding catch block matched then the
statements 1, 10, 11, 12 will execute with normal termination.<br>
Case3: if an exception raised at statement-2 but the corresponding catch block not matched then the
statements 1, 11, 12 will execute with abnormal termination.<br>
Case4: if an exception raised at statement-5 and the corresponding inner catch has matched then the
statements 1, 2, 3, 4, 7, 8, 9, 11, 12 will execute with normal termination.<br>
Case5: if an exception raised at statement-5 and the inner catch has not matched but outer catch has
matched then the statements 1, 2, 3, 4, 8, 10, 11, 12 will execute with normal termination.<br>
Case6: if an exception raised at statement-5 but the inner and outer catch blocks are not matched
then the statements 1, 2, 3, 4, 8, 11 will execute with abnormal termination.<br>
Case7: if an exception raised at statement-7 and<br>
i) If outer catch block has matched then the statements 1, 2, 3, - - - 8, 10, 11, 12 will
execute with normal termination.<br>
ii) If the outer catch block has not matched then the statements 1, 2, 3, - - - 8, 11 will
execute with abnormal termination.<br>
Case8: if an exception raised at statement-8 and<br>
i) If outer catch has matched then the statements 1, 2, 3, - - - will execute with normal
termination.<br>
ii) If outer catch has not matched then the statements 1, 2, 3, - - - 11 will execute with
abnormal termination.<br>
Case9: if an exception raised at statement-9 and<br>
i) If the outer catch has matched then the statements 1, 2, 3 - - -8, 10, 11, 12 will
execute with normal termination.<br>
ii) If the outer catch has not matched then the statements 1, 2, 3 - - -8, 11 will execute
with abnormal termination.<br>
Case10: if an exception raised at statement-10 it is always abnormal termination but before
termination compulsory the finally block should be executed.<br>
Case11: if an exception raised at statement-11 or 12 it is always abnormal termination.</p>

<p><b>throw keyword</b><br>By using throw we can hand – over exception object to the JVM. The out put of the following two programs
is same.</p>

<p><img src="assets/images/ExceptionHandling21.JPG"></p>
<p>Here in first case main method is responsible for the creation of exception object and hand – over that object
to the JVM.<br>
In the second case we created object explicitly and hand – over that object to the JVM programmatically by
throw key – word.</p>
Syntax:
throw e;
Where ‘e’ &#10132; Any throwable object
<p><img src="assets/images/ExceptionHandling23.JPG"></p>


<p>Here Explicitly we created a object to the ArithmeticExcption class and that object was thrown by thow to
the JVM.</p>
<p><img src="assets/images/ExceptionHandling24.JPG"></p>
<p>Here we didn’t create Object to the AritmeticExcepiton class just we created a reference, so reference
variable is not pointing to any object and we thrown only reference variable that’s why only it shows
NullPointerException.<br>+
After throw keyword we are not allowed to place any statements directly other wise compile time error.</p>
<textarea rows="10" cols="80" class="textArea" readonly>
   Ex:
            class Test
            {
            public static void main(String arg[])
            {
            throw new ArithmeticException();
            System.out.println("After throw statement...!");
            }
            }
</textarea>
<p><img src="assets/images/ExceptionHandling25.JPG"></p>
<p>Directly in the sense indirectly we can place any statements after throw. See the following example.</p>
<textarea rows="12" cols="80" class="textArea" readonly>
Ex:
class Test
{
static ArithmeticException e;
public static void main(String arg[])
{
throw e;
}
}
</textarea>
<p><img src="assets/images/ExceptionHandling26.JPG"></p>

<p><b>throws</b><br>
If our code may be a chance of raising checked exception then compulsory we should handle that checked
exception either by using try, catch or we have to delegate that responsibility to the caller using throws
keyword other wise C.E saying<br>
UnreportedException : XXXException must be caught or declared to be thrown
</p>
<textarea rows="12" cols="80" class="textArea" readonly>
   Ex:
            class Test
            {
            public static void main(String arg[])
            {
            Thread.sleep(1000);
            }
            }

</textarea>
<p><img src="assets/images/ExceptionHandling27.JPG"></p>
<p>We can resolve this problem either by using try catch or by using throws keyword as follows
</p>


<p><img src="assets/images/ExceptionHandling28.JPG"></p>
<p>Hence the main objective of throws keyword is to delegate the responsibilities of exception handling to the
caller
</p>

<textarea rows="15" cols="80" class="textArea" readonly>
   Ex:
            class Test
            {
            public static void main(String arg[]) throws InterruptedException
            {
            doStuff();
            }
            public static void doStuff() throws InterruptedException
            {
            doMoreStuff();
            }
            public static void doMoreStuff() throws InterruptedException
            {
            Thread.sleep(500);
            System.out.println("I am in office");
            }
            }

</textarea>

<p>If we are not taking at least one throws keyword we will get Compiler Error.<br>
If the parent class constructor throws some checked exception then the child class constructor must throw
same checked exception or its parent other wise compiler error. 
</p>
<p><img src="assets/images/ExceptionHandling30.JPG"></p>

<p>We can use throws keyword only for throwable classes other wise C.E</p>
<textarea rows="10" cols="80" class="textArea" readonly>
   Ex:-
            class Test
            {
            public static void main() throws Test
            {
            System.out.println("Hello");
            }
            }
</textarea>
<p><img src="assets/images/ExceptionHandling30.JPG"></p>
<p><b>Summarization of Exception Handling Keywords</b></p>
<p><b>try:</b> &nbsp;&nbsp;&nbsp;&nbsp;To maintain risky code.</p>
<p><b>Catch:</b> &nbsp;&nbsp;&nbsp;&nbsp;To maintain exception handling code.</p>
<p><b>finally:</b> &nbsp;&nbsp;&nbsp;&nbsp;To maintain cleanup code</p>
<p><b>throw:</b> &nbsp;&nbsp;&nbsp;&nbsp;To hand – over exception object to the JVM programmatically.</p>
<p><b>throws:</b> &nbsp;&nbsp;&nbsp;&nbsp;To delegate the responsibilities of exception handling to the caller.</p>

<P><b>Summarization of various compile time errors in Exception Handling</b></P>


<p>1) Exception has already been caught.<br>
2) Exception never thrown in the body of corresponding try statement.<br>
3) try with out catch or finally.<br>
4) catch with out try.<br>
5) finally with out try.<br>
6) unreachable statement.<br>
7) Incompatible types found: types
required: throwable<br>
8) unreported Exception must be caught or declared to be thrown.
</p>
<p>
<b>Customized Exception
</b>
<br>
Based on our programming requirement some times we have to create our own exception, which are nothing
but “Customized Exception”.
</p>

<textarea rows="25" cols="80" class="textArea" readonly>
   Ex:
            
            class TooYoungException extends RuntimeException
            {
            TooYoungException(String s)
            {
            super(s);
            }
            }
            class TooOldException extends RuntimeException
            {
            TooOldException(String s)
            {
            super(s);
            }
            }
            class CustomExceptionDemo
            {
            public static void main(String arg[])
            {
            int age = Integer.parseInt(arg[0]);
            if(age > 60)
            {
            throw new TooOldException("Younger age is already over");
            }

</textarea>
<p><img src="assets/images/ExceptionHandling31.JPG"></p>

<p>
<b>Note: </b>It is recommended to define customized exceptions as unchecked. i.e our custom exceptions class
should extends R.E either directly or indirectly
</p>

<p><b>Top 10 Exceptions</b><br>
All Exceptions are divided into two categories
</p>

<p><b>TJVM Exceptions:</b>
 Raised automatically by the JVM when ever a particular condition occurs.<br>
Ex: ArithmeticException, NullPointerException
</p>
<p><b>ProgramaticExceptions: </b>
These are raised programmatically because of programmers code or API’s
developers Code.<br>
Ex: IllegalArgumentException, NumberFormatException.
</p>
<p><b>1) NullPointerException:- </b>
 It is the direct child class of RuntimeException and it is unchecked. Thrown
automatically by the JVM when ever we are performing any operation on null.<br>
Ex: String s = null<br>
System.out.println(s.length());
</p>
<p><b>2) StackOverFlowError:-</b><br>
 It is the child class of Error and it is unchecked. Raised automatically by the
JVM when ever we are performing recursive method invocation.

</p>

<textarea rows="15" cols="80" class="textArea" readonly>
   Ex:
            class Test
            {
            public static void m1()
            {
            m1();
            }
            public static void main(String arg[])
            {
            m1();
            }
            }
</textarea>


<p><b>3) ArrayIndexOutOfBoundsException:-</b> It is the child class of RuntimeException and it is unchecked
thrown automatically by the JVM when ever we are accessing an array element with invalid int index.(Out
of range index)
</p>


<textarea rows="6" cols="80" class="textArea" readonly>
   Ex:
            int [] a = {10, 20, 30};
            System.out.println(a[0]);
            System.out.println(a[20]); &#10132; ArrayIndexOutOfBoundsException
</textarea>

<p><b>4)ClassCastException:-</b> It is the child class of RuntimeException and it is unchecked. Thrown
automatically by the JVM when ever we are trying to typecast parent class object to the child type.
</p>
<textarea rows="6" cols="80" class="textArea" readonly>
   Ex:
            String s = "raju";
            Object o = (Object)s   &#10004;
            Object o = new Object();
            String s = (String)o;   &#10006;
            R.E: ClassCastException
</textarea>
<p><b>5) NoClassDefFoundError:-</b> It is the child class of Error and it is unchecked. Thrown automatically by the
JVM if the required .class file is not available.<br>
Ex: java beebi<br>
If beebi.class file is not available we will get NoClassDefFoundError.</p>
<p><b>7) IllegalArgumentException:- </b>It is the child class of RuntimeException and it is unchecked thrown
explicitly by the programmer or API developer when ever we are invoking a method with inappropriate or
invalid argument.<br>
Ex:<br>
The valid range of Thread priority is 1 – 10 , if we are trying to invoke setpriority
method with 100 as argument we will get IllegalArgumentException.</p>

<textarea rows="8" cols="80" class="textArea" readonly>
   Ex:-         
            public void setPriority(int i)
            {
            if (i	&#62;10 || i&#60;11)
            {
            throw new IllegalArgumentException();
            }
            }
</textarea>
<p><b>8) NumberFormatException:-</b> It is the child class of Illegal Argument and it is unchecked. Thrown
programmatically when ever we are attempting to convert String to Number type but the String is not
formatted properly
</p>
<textarea rows="7" cols="80" class="textArea" readonly>

   Ex:
            String s = 10;   
            int i = Integer.parseInt(s);    &#10004;
            String s = "ten";   
            int i = Integer.parseInt(s);    &#10006;   &#10140;  NullPointerException

</textarea>


<p><b>9) IlleaglStateExcepiton:- </b>It is the child class of RuntimeException and it is unchecked. Thrown
programmatically to indicate that a method has invoked at an inappropriate time.</p>

<p>

After invalidating a session object we are not allowed to call any method on that
object other wise IllegalStateException.<br>
After comiting the response we are not allowed to redirect or forward otherwise
IlleagalStateException<br>
After starting a thread we are not allowed to start the same thread once again other
wise IlleagalStateException.<br>
MyThread t = new MyThread();<br>
t.start();<br>
t.start(); &#10140; IllegalThreadStateException

</p>
<p>

<b>10) AssertionError:-</b> It is the child class of Error and it is unchecked thrown programmatically to indicate
Assertion fails.<br>
Ex:<br>
Assert(false); &#10140; AssertionError

</p>

<p><b>Top 10 Exceptions in Table Format</b></p>
<p><img src="assets/images/ExceptionHandling33.JPG"></p>










      </div>
      <div class="declareandaccesscontrol" *ngIf="decandaccess">
         <h1 class="mt-4">DECLARATION AND ACCESS CONTROL</h1>
		  <p><b>Introduction</b></p>
         <p>In this chapter the topics going to cover are</p>

         <ol>
            <li> Java Source File Structure</li>
            <li>Class Modifiers
            </li>
            <li>Member Modifiers</li>
            <li>Interface</li>
         </ol>
         <p><b>Java Source File Structure</b></p>
         <p>A java Source file can contain any no of classes but at most one class can be declared as the public. if
            there
            is any public class then compulsory the name of the source file and the name of the public must be matched
            other wise compile time error. It there is no public class then any name we can use for the source file
         </p>
         <textarea rows="11" cols="80" class="textArea" readonly>
            Ex:
                  class A
                  {
                  }
                  public class B
                  {
                  }
                  class c
                  {
                  }
         </textarea>
         <p>If we save this file as B.java we won’t get any compile time error. Other wise will get compile time error.
            For example if we declare ‘c’ class as public we will get Compile time error saying class c is public should
            be declared in a file named c.java.</p>
         <p><b>Note: </b> It is recommended to take only one class for source file</p>

         <p><b>import Statement
            </b></p>
         <p>The following Example will explains the use of import statement.</p>
         <textarea rows="9" cols="60" class="textArea" readonly>
   Ex:
   class Test
   {
   public static void main(String arg[])
   {
   ArrayList l = new ArrayList();
   }
   }
   
 </textarea>
 <p><b>O/P:-</b> 10…8…16</p>
         <p style="color: red;">C.E: can’t find symbol class ArrayList</p>

         <p>We can resolve this problem by using<b>fully qualified</b> name i.e
         </p>
         <p>java.ArrayList = new java.util.ArrayList();
         </p>

         <p>using fully qualified name every time reduces readability of the code. we can resolve this by using
            import statement. just declare import statement only once and use short names directly.</p>
         <textarea rows="11" cols="60" class="textArea" readonly>
   Ex:
   import java.util.ArrayList;
   class Test
   {
   public static void main(String arg[])
   {
   ArrayList l = new ArrayList();
   }
   }
                   </textarea>

         <p>Hence the main objective of import statement is it acts as typing shortcut.</p>

         <p><b>Types of import statement</b></p>
         <p>There are 2 types of import statements</p>
         <ol>
            <li>implicit class import.</li>
            <li>explicit class import.</li>

         </ol>

         <p><b>implicit class imports
            </b></p>
         <p>import java.util.*;</p>


         <ul>
            <li> it reduces readability and hence it is not recommended to use in real time coding.</li>
            <li> It acts as a typing shortcut
            </li>
         </ul>
         <p><b>explicit class imports
            </b></p>
         <p>import java.util.ArrayList;
         </p>
         <p>It is recommended to use because it improves readability.</p>

         <p>Case1: <b>which of the following import statements are valid ?</b></p>

         <ul>

            <li>import java.util.*;<i class="fa fa-check" style="margin-left: 10px; color: blue;"></i> </li>
            <li>import java.util;<i class="fa fa-times" style="margin-left: 10px; color: red;"></i> </li>
            <li>import java.util.ArrayList.*;<i class="fa fa-times" style="margin-left: 10px;color: red;"></i>
            <li>import java.util.ArrayList;<i class="fa fa-check" style="margin-left: 10px;color: blue;"></i> </li>

         </ul>
         <p>Case2: consider the following class</p>
         <textarea rows="8" cols="60" class="textArea" readonly>
         
   class MyObject extends java.util.util.UnicastRemoteObject        
   {
                  
   }
                  </textarea>

         <p>The code compiles fine even though we are not using import statement because we are
            providing fully qualified name.
         </p>
         <p>Case3:
         </p>
         <textarea rows="11" cols="60" class="textArea" readonly>
   import java.util.*;        
   import java.sql.*;
                     
   class Test                     
   {                   
   public static void main(String arg[])                    
   {                    
   Date d = new Date();                    
   }                    
   }
               </textarea>

         <p style="color: red;">C.E: reference to Date is ambiguous even in the list case also we will get the same problem
            because it is available in both util and awt packages.</p>
            <p>Case4:</p>
         <textarea rows="13" cols="80" class="textArea" readonly>
         
   import java.util.Date;
   import java.sql.*;
   class Test
   {
   public static void main(String arg[])
   {
   Date d = new Date();
   }
   }
        
                </textarea>
                <p> Compiler resolves the import statement in the following order.</p>

         <ol>
            <li> Explicit class imports.</li>
            <li>Classes present in current working directory</li>
            <li>Implicit class imports.</li>
         </ol>
         <p>Case5:</p>
         <p>Import statement is totally compile time issue. If more no of imports, more will be
            compile time. But there is no effect on execution time.</p>
         <p>When ever we are importing a package all the classes present in that package will be
            available but not sub package classes.</p>
         <p>Ex:</p>
         <p>To use pattern class compulsory we should use</p>
         <p>import java.util.regex.*;
         </p>
         <p>import java.util.*;
         </p>
         <p><img src="assets/images/explicitcase5.PNG" id="explicitcase5"></p>

         <p><b>static imports</b></p>
         <p>This concept has introduced in 1.5 version. According to sun people static imports improves
            readability of the code but according to world wide java expert static imports increases confusion
            instead of improving readability</p>
         <p>Hence if there is no specific requirement it is not recommended to use static imports. The main
            objective of static imports is to import static members of a particular class. So that with out using
            class name we can access directly static members.</p>

            <p><img src="assets/images/staticimports.PNG" id="staticimports"></p>

            <textarea rows="13" cols="80" class="textArea" readonly>
   Ex:
   import static java.lang.Integer.*;
   import static java.lang.Byte.*;        
   class Test
   {        
   public static void main(String arg[])         
   {        
   System.out.println(MAX_VALUE);         
   }        
   }
         </textarea>

         <p>Reference to MAX_VALUE is ambiguous. Compiler always resolves static members in the
            following order.</p>
         <ol>

            <li>Current class static member</li>
            <li>Explicit static member</li>
            <li>Implicit static member</li>
         </ol>
         <textarea rows="13" cols="80" class="textArea" readonly>
   Ex:

   import static java.lang.Integer.MAX_VALUE; -> 2            
   import static java.lang.Byte.*;           
   class Test            
   {            
   static int MAX_VALUE = 999; -> 1            
   public static void main(String arg[])            
   {            
   System.out.println(MAX_VALUE);            
   }            
   }
         </textarea>
         <p>O/P:- 999</p>

         <p>If we are commenting line 1 then the o/p is 2147483647. if we are commenting both lines 1 & 2 then
            the O/P is 127.</p>
         <p><b>Note:-</b> It is not recommended to extend import concept up to static members because several classes
            can contain static members with same name. which may cause compile time error.
         </p>
         <p>Static imports also reduces readability of the code. It is recommended to access static members by
            using class name only.
         </p>
         <p><b>Which of the following import statements are valid?</b></p>
         <ul>

            <li>import java.lang.Math.*;<i class="fa fa-times" style="margin-left: 10px;color:red"></i> </li>
            <li>import static java.lang.Math.*;<i class="fa fa-check" style="margin-left: 10px;color: blue;"></i> </li>
            <li>import java.lang.Math;
               <i class="fa fa-check" style="margin-left: 10px;color: blue;"></i>
            <li>import static java.lang.Math;
               <i class="fa fa-times" style="margin-left: 10px;color: red;"></i> </li>

         </ul>
         <b>package concept</b>
         <p>package in java is an encapsulation mechanism to group related classes and interfaces into a single
            module. The main objective of package is to resolve naming conflicts.
            There is universally accepted convention to name the package i.e to use internet domain name in
            reverse</p>
            <textarea rows="13" cols="80" class="textArea" readonly>
   Ex:

   com.IBM, com.ICICIBANK, com.AirtelIndia
   package com.rajusoft;
   class Test
   {
   public static void main(String arg[])
   {
   System.out.println("package name");
   }
   }
                           </textarea>
        
         <p>javac Test.java</p>
         <p>The generated .class file will be placed in current working directory.</p>
         <p>javac –d . Test.java
         </p>
         <p>Here ‘.’ Represents current place.</p>
         <p>The generated .class file will be placed in corresponding package structure.</p>
         <p>If the required package structure is not already available this command itself create the needed
            packages.</p>
         <p>If the specified destination is not available we will get compile time error. Saying the system can’t
            find the path specified</p>
         <p>javac –d Z: Test.java</p>
         <p>if Z: is not available we will get C.E
         </p>
         <p>java com.rajusoft Test
         </p>
         <p>for any java source file we are allowed to take at most 1 package statement i.e more than one
            package statement is not allowed violation leads to C.E.</p>
            <textarea rows="10" cols="80" class="textArea" readonly>
   Ex:

   package pack1;
   package pack2;
   class student
   {
            
   }
                           </textarea>
        
         <p>If we are not taking any package statement then the current working directory Acts as default
            package. The first non-comment statement in any java source file is package statement.</p>
            <textarea rows="9" cols="80" class="textArea" readonly>
   import java.util.*;
   package pack1;              
   class Test             
   {
                           
   }
            </textarea>
         <p>The following is the current structure of java source file</p>

         <p><img src="assets/images/packageconcept.PNG" id="packageconcept"></p>

         <p><b>class modifier
            </b></p>
            <p>when ever we are writing our own classes compulsory we should provide information about our class to the
               JVM like.
            </p>
            <ol>
               <li>child class creation is possible or not</li>
               <li>Instantiation is possible or not</li>
               <li>Whether we can access this class from any where</li>


            </ol>

            <p>We can specify this information by declaring the corresponding modifier. The only applicable modifier for
               the top level classes are </p>
               <p><img src="assets/images/classmodifier.PNG" id="classmodifier"></p>
           

            <p>If we are using any other modifier we will get compile time error.</p>
            <p><img src="assets/images/classmodifier1.PNG" id="classmodifier1"></p>
<p style="color: red;">C.E: modifier private not allowed here<br>
   For the inner classes the applicable modifiers are</p>
   <p><img src="assets/images/classmodifier2.PNG" id="classmodifier2"></p>
         
      
            <b>public classes</b>
            <p>If a class declared as the public then we can access that class from any where.
            </p>
            <textarea rows="13" cols="80" class="textArea" readonly>
   Ex:

   package pack1;              
   public class A              
   {           
   public void m1()           
   {             
   System.out.println("Hai hello");          
   }              
   }
            </textarea>
            <br>
            <textarea rows="13" cols="80" class="textArea" readonly>
   package pack2;
   import pack1.A;              
   class B              
   {               
   public static void main(String arg[])              
   {              
   A a1 = new A();             
   a1.m1();            
   }              
               
            </textarea>
            <p>If we are not declaring class A as public then while compiling B class we will get C.E saying
               pack1.A is not public in pack1. cannnot be accessed from outside package.
            </p>
            <p> <b>&#60;default&#62; classes</b></p>
            <p>If a class declared as default then we can access that class only in the current package. default
               access is also known as package level access.</p>
            <p><b>abstract</b></p>
            <p>abstract is the modifier applicable only for classes and methods i.e we can’t use abstract for
               variables</p>
            <p>If we don’t know about implementation still we are allowed to declare methods with abstract
               modifier</p>
               <textarea rows="13" cols="80" class="textArea" readonly>
   Ex:

   abstract class Vehicle                 
   {                
   public abstract int getNoOfWheels();                
   }              
   class Bus extends Vehicle            
   {           
   public int getNoOfWheels()          
   { 
   return 7;      
   }          
   }
         </textarea>

            <p>abstract method should have only declaration but not implementation hence abstract method
               declaration should ends with ;(semicolon)</p>

            <p>Ex:</p>
               <ul>


                  <li>public abstract void m1();
                     <i class="fa fa-check" style="margin-left: 10px;color: blue;"></i>
                  <li>public abstract void m1()&#123;&#125;
                     <i class="fa fa-times" style="margin-left: 10px; color: red;"></i> </li>

               </ul>
               <p>child class is responsible to provide implementation for abstract methods</p>
               <p>abstract never talks about implementation, if any modifier talks about implementation it is
                  considered as illegal combination with abstract.</p>
               <p>Hence the following 6 combinations are illegal.</p>
               <p><img src="assets/images/abstract1.PNG" id="abstract1"></p>

               <p>If we don’t want instantiation for any class such type of classes we have to declare with abstract
                  modifier. i.e for abstract classes instantiation is not possible</p>
               <p>If a class contain at least one abstract method then the corresponding class should be declared as
                  abstract otherwise C.E.</p>
               <p>Even though class doesn’t contain any abstract method still we can declare that class with abstract
                  modifier.</p>
               <p>i.e abstract class can contain zero no of abstract methods.</p>
               <p>Ex:</p>
               <p>   HTTP servlet is a abstract class but it doesn’t contain only abstract method.</p>
               <p> Case1: </p>
               <textarea rows="8" cols="80" class="textArea" readonly>                 
   class Test        
   {     
   public abstract void m1()     
   {
                  
   }
   }
                  </textarea>
               <p style="color: red;">C.E: abstract methods can’t have a body</p>

               <p>Case2:</p>
               <textarea rows="8" cols="80" class="textArea" readonly> 
                  class Test
                  {                  
                  public abstract void m1();                 
                  }
               </textarea>
               <p style="color: red;">C.E: Test is not abstract and doesn’t override abstract method m1 in Test()
               </p>
               <p>Case3:</p>
               <textarea rows="9" cols="80" class="textArea" readonly> 
                  abstract class Test
                  {                 
                  public abstract void m1();                  
                  }                 
                  class SubTest extends Test                 
                  {
                  
                  }
               </textarea>
               <p style="color: red;">C.E: SubTest is not abstract and doesn’t override abstract method m1() in Test</p>
               <p>If we are creating any child class for abstract class then compulsory we should provide
                  implementation for all abstract methods of parent class other wise the child class also should be
                  declared as abstract
               </p>
               <textarea rows="8" cols="80" class="textArea" readonly> 
   Ex:

   abstract class Test                
   {                
   public static void main(String arg[])                
   {                 
   Test t = new Test();                 
   }
   }
               </textarea>
               <p style="color: red;">C.E: Test is abstract can’t be instantiated.
               </p>
               <p><b>final</b></p>
               <p>final is the modifier applicable for classes, methods and variables.
               </p>
               <p>If a method is not allowed to override in the child class then we should declare that method as
                  ‘final’.
                  i.e for the final methods overriding is not possible</p>
                  <textarea rows="13" cols="80" class="textArea" readonly> 
   Ex:

   class P
   {                    
   public final void marry()                     
   {                     
   System.out.println("Bujji");                     
   }                    
   }                    
   class C extends P                    
   {                     
   public void marry()                    
   {                     
   System.out.println("Preeti");                     
   }
   }
               </textarea>
               <p style="color: red;">C.E: marry in ‘C’ can’t override, overridden method is final</p>
               <p>for any class if we are not allow to create child class, such type of classes we have to declare with
                  final i.e for final classes inheritance is not possible.</p>
                  <textarea rows="11" cols="80" class="textArea" readonly> 
   Ex:

   final class P                   
   {
                     
   }
   class C extends P                  
   {
                     
   }
               </textarea>
               <p style="color: red;">C.E: can’t inherit from final ‘p’</p >
               <p><b>Relation Ship between final and abstract</b></p>
               <p>final method should not be overridden but we should override abstract method to provide
                  implementation. Hence final & abstract combination is always illegal.</p>
               <p>public abstract final void m1()&#123;&#125;
               </p>
               <p>Illegal combination of modifiers : abstract, final</p>
               <p>For the final classes we are not allowed to create the child class. But for abstract class we
                  should create child class to provide implementation. Hence abstract and final are Illegal
                  combination of modifiers for that classes</p>
               <p>final classes can’t contain abstract methods but abstract classes can contain final methods</p>
               <p>Ex:</p>
               <p>final class P<br>
                  abstract void m1();<i class="fa fa-times" style="margin-left: 10px; color: red;"></i><br> 
                  }</p>
                  <p style="margin-top: -110px; margin-left: 250px;">abstract class P<br>
                     &#123;<br>
                     final void m1()&#123;&#125;<i class="fa fa-check" style="margin-left: 10px;color: blue;"></i><br>
                     }</p>
               <p>It is a good programming practice to use abstract keyword but If there is no specific
                  requirement it is not recommended to use ‘final’ keyword.</p>
               <p><b>strictfp</b></p>
               <p>This modifier is applicable only for methods and classes but not for variables. If a method declared
                  as a strictfp all floating point calculations in that method IEEE754 standard so that we can get
                  platform independent results</p>
               <p>strictfp and abstract is always illegal combination for methods. If a class declared as strictfp all
                  concrete methods in that class will follow IEEE754 standard for floating point arithmetic</p>
               <p>abstract and strictfp is a legal combination for the classes(Illegal for the methods)
               </p>
               <p><b>member modifiers</b></p>
               <p><b>public members
                  </b></p>
               <p>we can access public members from any where but the corresponding class must be visible.</p>
               <textarea rows="10" cols="80" class="textArea" readonly>

   package pack1;
   public class A
   {
   public void m1()
   {
   System.out.println("To day Sunday");
   }
   }
               </textarea>
               <textarea rows="11" cols="80" class="textArea" readonly>
   package pack1;
   import pack1.A;
   class B
   {
   public static void main(String arg[])
   {
   A a = new A();
   a.m1();
   }
   }
</textarea>
               <p>If class A is not public then we are not allowed to access m1 from outside the package even though
                  m1 is public</p>
               <p><b>&#60;default&#62; members</b></p>
               <p>If a member declared as a default we can access that member only in the current package</p>
               <p>Ex:</p>
               <p>In the above program if we declare m1() as default then we can’t access that method
                  from pack2 even though class A is public.
               </p>
               <p><b>private members</b></p>
               <p>If a member declared as private we can access that member only in the current class.</p>
               <p>Ex: singleton classes we can implement by using private constructor. Private members
                  are not visible in the child class to provide implementation. Hence private and abstract
                  combination is illegal for methods.
               </p>
               <p><b>protected members</b></p>
               <p>If a member declared as protected then we can access that member from any where with in the
                  current package and only in child classes from outside package</p>
                  <p><img src="assets/images/protected.PNG" id="protected"></p>
               <p>We can access protected members from outside package only in child class. And we should use child
                  class reference only. i.e parent class reference is not allowed to access protected members from
                  outside package violation leads to C.E but in the current package we can access protected members
                  either by using parent class reference or by child class reference.</p>
               <textarea rows="10" cols="80" class="textArea" readonly>
   Ex:

   package pack1;
   public class A
   {
   protected void m1()
   {
   protected = <default> + kids(childclasses)
   System.out.println("This is very imp point");
   }
   }

                                             </textarea>
               <textarea rows="14" cols="80" class="textArea" readonly>
   package pack2;
   import pack1.A;
   class B extends A
   {
   public static void main(String arg[])
   {
   Case1: A a1 = new A(); X
   a1.m1();
   Case2: B b1 = new B(); (right)
   b1.m1();
   Case3: A a2 = new B()  (right)
   a2.m1();
   }
   }
</textarea>
               <p>If we can take B- class in the same package pack1, then there is no C.E</p>

               <p><b>Summarization of public, protected, default and private</b></p>
               <p><img src="assets/images/summarization.PNG" id="Summarization"></p>
               <ul>
                  <li>The Most Restricted Modifier is<b> Private</b></li>
                  <li>The Modifier Which provides wide range of access is <b>Public </b>.</li>
                  <li><b>Public > Protected > Default > Private</b></li>
                  <li>Recommended Modifier for data members is Private.</li>
                  <li>And for methods is public .</li>
               </ul>
               <p><b>Final Variables</b></p>
               <p>For the Static and instance variables no need to perform initialization, JVM Will Provide default
                  initialization</p>
               <p>For the local variables compulsory we should perform initialization before using.</p>
               <p><b>Final Instance Variables</b></p>
               <p>For the final instance variables JVM won’t provide any default values, compulsory we should
                  perform initialization<b> before completion of constructor.</b></p>
               <p>The following are the places to perform this</p>
               <ol>
                  <li> At the time of declaration:.
                     final int i = 0;</li>
                  <li>Inside instance initialization class<p>final int i;</p>
                     <p>&#123;</p>
                     <p>i = 0;</p>
                     <p>&#125;</p>
                  </li>
                  <li> Inside constructor<p>final int i;</p>
                     <p>test()</p>
                     <p>&#123;</p>
                     <p>i = 0;</p>
                     <p>&#125;</p>
                  </li>
               </ol>
               <p>If u r performing initialization any where else we will get compile time error.</p>

               <textarea rows="6" cols="80" class="textArea" readonly>

   Ex:
   Class Test
   {
   final int i;
   }

            </textarea>
               <p><b>O/P:-</b> Generates Compile time error, variable “i” might not have been initialized. </p>

               <textarea rows="9" cols="80" class="textArea" readonly>
   Class Test
   {
   final int i;
   public void m1()
   {
   i=20;
   }
   }
            </textarea>
               <p><b>O/P:-</b> Generates Compile time error, can’t assign a value to final variable</p>
               <textarea rows="8" cols="80" class="textArea" readonly>
   Class Test
   {
   final int i;
   {
   i=20;
   }
   }
               
            </textarea>
               <p><b>O/P:-</b> Won’t generate compile time error</p>

               <p><b>Final static Variables</b></p>
               <p>For the final static variables compulsory we should perform initialization</p>
              <textarea rows="6" cols="80" class="textArea" readonly>
   Ex:

   class Test
   {
   final static int i;
   }
   </textarea>
               <p><b>O/P:-</b>generates Compile time error. variable i might not have been assigned.</p>
               <p>We can perform initialization for the final static variables in the following places.</p>

               <ol>
                  <li>At the time of declaration<p>
                        final static int i = 0;</p>
                  </li>
                  <li> Inside static blocks<p>static
                     </p>
                     <p>&#123;</p>
                     <p>i = 0;</p>
                     <p>&#125;</p>
                  </li>

                  <li> If u r performing initialization anywhere else we will get compile time error<p>class Test
                     </p>
                     <p>&#123;</p>
                     <p>final static int i;</p>
                     <p>public static void main(String arg[])
                     </p>
                     <p>&#123;</p>
                     <p>i = 20;</p>
                     <p>&#125;</p>
                     <p>&#125;</p>
                  </li>
               </ol>

               <p><b>O/P:-</b> will produce compile time error.
               </p>

               <P><b>Final local Variables</b></P>
               <p>Before using a local variable(whether it is final or non-final) we should perform initialization. If
                  we
                  are not using local variable then no need of perform initialization even though it is final</p>
               <textarea rows="9" cols="80" class="textArea" readonly>
   Ex:
   class Test
   {
   public static void main(String arg[])
   {
   int i;
   System.out.println("hello");
   }
   }
</textarea>
               <p>This is valid Because we didn’t use “i” here.
               </p>
               <textarea rows="8" cols="80" class="textArea" readonly>
   class Test
   {
   public static void main(String arg[])
   {
   final int i;
   System.out.println("hello");
   }
   }
   </textarea>
               <p>This is also valid because we didn’t use “i” here</p>

               <textarea rows="8" cols="80" class="textArea" readonly>
   class Test
   {
   public static void main(String arg[])
   {
   final int i = 0;
   System.out.println("hello");
   }
   }
    
   </textarea>

               <p>This is valid..</p>

               <textarea rows="8" cols="80" class="textArea" readonly>
   class Test
   {
   public static void main(String arg[])
   {
   final int i;
   System.out.println(i);
   }
   }

      </textarea>
               <p>This is not valid. Because Before going to use we didn’t initialize “i”.
               </p>
               <p>The variables which are declared as formal are acts as local variables of the method.</p>
               <p>if a formal parameter declared as the final then with in the method we are not allowed to change it’s
                  values.</p>
               <textarea rows="15" cols="80" class="textArea" readonly>
   Ex:

   class Test
   {
   public static void main(String arg[])
   {
   m1(10,20);
   }
   public static void m1(final int i,final int j)
   {
   //i=100;
   //j=100;
   System.out.println(i+"----"+j);
   }
   }
            
            </textarea>
               <p>If you use final you can’t change i, j values.</p>
               <p>Final parameter ‘i’ may not be assigned. </p>
               <p>For the local variables the only applicable modifier is final.</p>
               <textarea rows="10" cols="80" class="textArea" readonly>
               Ex:
               class Test
               {
               public static void main(String arg[])
               {
               private int i = 20;
               System.out.println(i);
               }
               }
               
                  </textarea>

               <p><b>O/P:-</b> Provides compile time error because we declare int as private.</p>
               <p><b>static Modifier</b></p>
               <p>static is the modifier is applicable for methods and variables</p>
               <p>we can’t declare top level classes as static but inner classes can be declares as static( static
                  nested class).
                  Instance variables(methods) can’t be accessed from static area directly, But Static members can be
                  accessed
                  from any where</p>

               <textarea rows="11" cols="80" class="textArea" readonly>
   Ex:

   class Test
   {
   int i = 10;
   public static void main(String arg[])
   {
   System.out.println(i);
   }
   }                           
                  </textarea>
               <p><b>O/P:-</b> C.E: non static variable can’t be referred from static context.</p>
               <p><b>Q) Consider the following 4 declarations</b></p>
               <ol>
                  <li>int i = 0;
                  </li>
                  <li>static int i = 0;</li>
                  <li>public void m1()<p>&#123;</p>
                     <p>System.out.println(i)
                     </p>
                     <p>&#125;</p>
                  </li>
                  <li>public static void main()<p>&#123;</p>
                     <p>&#125;</p>
                  </li>
               </ol>

               <p>Which of the following r not allowed to take simultaneously in any class
               </p>
               <p>A) 1 & 3 B) 1 & 4 C) 2 & 3 D) 2 & 4</p>
               <p><b>Ans :</b> B
               </p>

               <p>for static methods compulsory we should provide complete implementation But for Abstract methods we
                  can’t provide implementation hence abstract and static combination is illegal for methods.
                  <b>Overloading</b> is possible for static methods</p>

               <textarea rows="13" cols="80" class="textArea" readonly>
   Ex:-
   class StringTest
   {
   public static void main(String[] args)
   {
   System.out.println("Haiiiiii");
   }
   public static void main(int [] arg)
   {
   System.out.println("Helllllllllllo");
   }
   }
                                       </textarea>

                                       <p><b>inheritance</b> concept is applicable for the static method</p>
                                       <p><b>overriding</b>is not applicable for static methods but seems to be overriding is possible, but it is method hiding</p>

                  <textarea rows="16" cols="80" class="textArea" readonly>
                  
   Ex:

   class Foo
   {
   public static void method()
   {
   System.out.println("in Foo");
   }
   }
   class Bar extends Foo
   {
   public static void method()
   {
   System.out.println("in Bar");
   }
   }
                                                         
                                     </textarea>
                                     <textarea rows="15" cols="80" class="textArea" readonly>
   Ex:

   class Foo
   {
   public static void classMethod()
   {
   System.out.println("classMethod() in Foo");
   }
   public void instanceMethod()
   {
   System.out.println("instanceMethod() in Foo");
   }
   }
   class Bar extends Foo
   {
   public static void classMethod()
   {
   System.out.println("classMethod() in Bar");
   }
   public void instanceMethod()
   {
   System.out.println("instanceMethod() in Bar");
   }
   }
   class Test
   {
   public static void main(String[] args)
   {
   Foo f = new Bar();
   f.instanceMethod();
   f.classMethod();
   }
   }
                                        </textarea>                                 
<p>If you run this, the output is
   instanceMethod() in Bar
   classMethod() in Foo</p>
   <p><b>native method
   </b></p>
   <p>native is the modifier applicable only for methods
      we can’t declare classes and variables as native</p>
      <p>The methods which are implemented in non-java are called<b> “native methods”</b> or <b>“foreign methods”.</b></p>
      <p>The main objectives of native keyword are :</p>
      <P>To improve performance of the system.</P>
      <p>To communicate with already existing legacy systems.</p>
      <p>psudocode:</p>
      <textarea rows="14" cols="80" class="textArea" readonly>
   class Native
   {
   static
   {
   System.loadLibrary("Path of native library");//Loading the nativelibrary.
   }
   public native void m1(); //Declaring a native method.
   }
   class client
   {
   Native n = new Native();
   n.m1();//Invoking a native method.
   }
         </textarea>
         <p>native method should end with ;(semicolon).because we r not responsible to provide implementation, it is
            already available.</p>
            <ul>
               <li>The use of native keyword breaks the platform independent nature of java.</li>
               <li>For the native methods <b>overloading</b>, <b>Inheritance</b> and <b>overriding</b> concepts are applicable.</li>
               <li>For the native methods implementation is already available. But for abstract methods
                  implementation won’t be available. Hence abstract and native is illegal combination of modifiers.</li>


            </ul>
            <p><b>Synchronized
            </b></p>
           <ul>
<li>It is a keyword applicable only for methods and blocks. We can’t declare variables and classes with
   synchronized keyword.
</li>
<li>If a method declared as synchronized at a time only one thread is allowed to execute on the given
   object. Hence the main advantage of synchronized keyword is we can overcome data inconsistency
   problem</li>
   <li>Use of synchronized keyword may effect performance of the system.</li>
   <li>Synchronized and abstract combination is illegal for the methods.
   </li>

           </ul>

           <p><b>Transient Modifier
         </b></p>
         <p>Transient is the keyword applicable only for variables. i.e we can’t apply transient for methods and classes.</p>
         <p><b>Serialization</b> The Process of Saving an object to a file is called “serialization”. But strictly
            speaking serialization is the process of converting an object from java supported format to network
            or file supported format</p>
            <p>By using FileOutPutStream, ObjectOutPutStream classes we can achieve serialization</p>
          
            <p><img src="assets/images/transient.PNG" id="transient"></p>


            <p><b>DeSerialization</b> The process of reading an object from a file is called deserialization. But strictly
               speaking it is the process of Converting an object from network supported format or file supported
               format to java supported format.</p>
               <p>By using FileInputStream, ObjectInputStream we can achieve deserialization.</p>
               <p><img src="assets/images/deserialization1.PNG" id="deserialization1"></p>
               <p><img src="assets/images/deserialization2.PNG" id="deserialization2"></p>
               <p>We can perform serialization only serialization objects.</p>

               <ul>
<li>An Object is said to be serializable if and only if the corresponding class should implement
   serializable interface. serializable interface present in java.io package and doesn’t contain any
   method, it is marker interface.</li>
   <li>If u r trying to perform serialization of a non serialization Object. we will get runtime exception
      saying NonSerializableException.</li>
      <li>While performing serialization if u don’t want to save the value of a particular variable, that
         variable we have declared with transient keyword</li>
         <li>At the time of serialization, JVM ignores the value of transient variable and saves it’s default
            value.</li>
          

               </ul>
               <p><b>i.e Transient means not to serialize.</b></p>
               <ul>

                  <li>static variables never part of object state hence they won’t participate in serialization process.</li>
                  <li> Declaring a static variable as transient there is no impact.</li>
                  <li>Similarly declaring final variables with transient keyword creates no impact.</li>
               </ul>
               <p><img src="assets/images/transient1.PNG" id="transient1"></p>
               <p><b>VolatileModifier</b></p>
               <ul>
                  <li>Volatile is the keyword applicable only for variables. We can’t declare methods and classes with
                     volatile modifier</li>
                     <li>If the value of a variable keep on changing then we have to declare that variable as volatile.</li>
                     <li>For the volatile variable JVM will create a separate local copy for every thread</li>
                     <li>All the intermediate calculation performed by that thread will be referred in local copy instead of
                        master copy ,once the value got finalized just before terminating the thread the local copy value
                        updated in the master copy. So that remaining threads will always get a stable value.</li>
                        <li>The main advantage of volatile keyword is we can overcome “Data Inconsistency” problems.
                           Creating and maintaining separate copy for every thread will increase complexity and effect
                           performance of the system.</li>
                           <li>volatile and final is illegal combination for the variables.
                           </li>
               </ul>
               <p><img src="assets/images/volatile.PNG" id="volatile"></p>
               <p><b>Interfaces</b></p>
               <ol>
<li>Introduction</li>
<li>Declaring Interface.</li>
<li>Interface Methods.</li>
<li>Interface variables.
</li>
<li>Naming conflicts in interface.</li>
<li>Marker/Tag interface.</li>

               </ol>
               <p><b>Intoduction</b></p>
               <p>From the client point of view interface defines the set of services what he is getting. From the service
                  provider point of view an interface defines the set of services what he is offering.
                  Hence an interface acts as a contract between <b>client</b> and <b>service provider</b>.
                  </p>
                  <p>The Main Advantages of interface are</p>
                  <ul>

                     <li> <b>Security :</b> The third party person not-allowed to know internal implementation details.</li>
                     <li> <b>Enhancement:</b> With out effecting end user or client we can perform any modification in the
                        internal implementation</li>
                        <li><b>Improves Maintainability</b></li>
                        <li>We can achieve communication between 2 different systems(A java application can
                           communicate with Dotnet through interfaces.
                           interface never allowed to contain any implementation details. Hence all the methods
                           declared inside interfaces must be abstract and interfaces is considered as 100% pure abstract
                           class.</li>
                  </ul>
                  <p><b>Declaring An Interface</b></p>
                  <textarea rows="6" cols="80" class="textArea" readonly>
                  
   interface sample
   {
   public void m1();
   public void m2();
   }
                                    </textarea>

                                    <p>The allowed modifiers for interface are 
                                    </p>
                                    <p>public 
                                    </p>
                                    <p>abstraction</p>
                                    <p>strictfp</p>
                                    <p>&#60;default&#62;</p>
                                    <p>When ever a class implementing an interface complexity it should provide the implementation for all
                                       the interface methods. Other wise the class must be declared as abstract. Violation leads to compile
                                       time error.</p>

                                       <textarea rows="10" cols="80" class="textArea" readonly>
   interface sample
   {
   public void m1();
   public void m2();
   }
   class test implements sample
   {

   }
                                       </textarea>

                                       <p><b>C.E:-</b> Test is not abstract and does not override abstract methods in same
                                          If test class declared as abstract then we won’t get any compilation error.</p>
         <p>If the test class declared as abstract then the child class of test is responsible to provide
            implementation for m2() method.</p>
            <p>When ever we are implementing an interface method compulsory we should declare that method as
               public otherwise compile time error</p>
               <textarea rows="9" cols="80" class="textArea" readonly>
   interface sample
   {
   void m1();
   }
   class test implements sample
   {
   void m1(){}
   }
                              </textarea>
                              <p>m1() in test can’t implement m1() in sample attempting to assign weaker access privileges was
                                 public.</p>
                                 <p>Public void m1()&#123;&#125;
                                 </p>
                                 <p>If we declared public then no compile time error</p>
                                 <p><b>extends vs implements
                                 </b></p>
                                 <p>A class can extends only one class at a time. But an interface can extends any no of interfaces
                                    simultaneously</p>
                                    <P>But an interface can’t implement another interface.</P>
                                    <p><b>Q) Which of the following statements are valid.</b></p>
                                 

                                    <ul>


                                       <li>A class can extends any no of classes simultaneously.
                                          <i class="fa fa-times" style="margin-left: 10px;color: red;"></i>
                                       <li>A class can extends only one class at a time.
                                          <i class="fa fa-check" style="margin-left: 10px;color: blue;"></i> </li>
                                          <li>An interface can extend only one interface at a time.
                                             <i class="fa fa-times" style="margin-left: 10px;color: red;"></i> </li>
                                             <li>An interface can extend any no of interfaces simultaneously.
                                                <i class="fa fa-check" style="margin-left: 10px;color: blue;"></i> </li>
                                                <li>A class can implement any no of interfaces at a time.
                                                   <i class="fa fa-check" style="margin-left: 10px;color: blue;"></i> </li>
                                                   <li>A class can extend an interface
                                                      <i class="fa fa-times" style="margin-left: 10px;color: red;"></i> </li>
                                                      <li>An interface can implement another interface
                                                         <i class="fa fa-times" style="margin-left: 10px;color: red;"></i> </li>
                                             
                                    </ul>
                                    <p><b>interface Methods
                                    </b></p>
                                    <p>Every Interface method is by default public and abstract whether we r declaring or not.
                                       Hence the following declarations are equal inside interface.</p>
                                       <p>void m1();<br>
                                          public void m1();<br>
                                          public abstract void m1();</p>

                                          <p>As the interface method are by default public and abstract, we r not allowed to use the following
                                             modifiers</p>
                                             <p>private<br>
                                                protected<br>
                                                static<br>
                                                final<br>
                                                native<br>
                                                strictfp<br>
                                                synchronized.</p>
                                                <p><b>Which of the following method declarations are valid inside interface.
                                                </b></p>
                                                <ol>


                                                   <li>private void m1();
                                                      <i class="fa fa-times" style="margin-left: 10px;color: red;"></i>
                                                   <li>void m1()&#123;&#125;
                                                      <i class="fa fa-times" style="margin-left: 10px;color: red;"></i> </li>
                                                      <li>final void m1();
                                                         <i class="fa fa-times" style="margin-left: 10px;color: red;"></i> </li>
                                                         <li>static synchronized void m1();
                                                            <i class="fa fa-times" style="margin-left: 10px;color: red;"></i> </li>
                                                            <li>native void m1(); 
                                                               <i class="fa fa-times" style="margin-left: 10px;color: red;"></i> </li>
                                                               <li>public abstract void m1();
                                                                  <i class="fa fa-check" style="margin-left: 10px;color: blue;"></i> </li>
                                                               
                                                         
                                                </ol>
                                                <p><b>Interface variables</b></p>
                                                <p>An interface can contain variables also every interface variable is by default public static and final
                                                   whether we r declaring or not.<br>
                                                   Hence the following declarations are equal inside interface.</p>
                                                   <p>int i = 10;<br>
                                                      public int i = 10;<br>
                                                      public static int i = 10;<br>
                                                      public static final int i = 10;
                                                     </p>
                                                     <p>As interface variables already public static and final we r not allowed to declare with the following
                                                      modifiers.
                                                      </p>
                                                      <p>private, protected, volatile, transient.</p>
                                                      <p>For the interface variables compulsory we should perform initialization at the time of declarations
                                                         only.</p>
                                    <textarea rows="8" cols="80" class="textArea" readonly>
                  
                                    Eg:-
                                       interface inter
                                       {
                                       int i ; --> C.E = expected.
                                       }
                                                            
                                    </textarea>
                                                         <p><b>Which of the following variable declarations are allowed inside an interface</b></p>

                                                         <ol>


                                                            <li>int i = 10;
                                                               <i class="fa fa-check" style="margin-left: 10px;color: blue;"></i></li>
                                                            <li>private int i = 10 ; 
                                                               <i class="fa fa-times" style="margin-left: 10px;color: red;"></i> </li>
                                                               <li>volatile int i = 10 ;
                                                                  <i class="fa fa-times" style="margin-left: 10px;color: red;"></i> </li>
                                                                  <li>transient int i = 10 ;
                                                                     <i class="fa fa-times" style="margin-left: 10px;color: red;"></i> </li>
                                                                     <li>int i ;  
                                                                        <i class="fa fa-times" style="margin-left: 10px;color: red;"></i> </li>
                                                                        <li>public static final int i = 10 ;
                                                                           <i class="fa fa-check" style="margin-left: 10px;color: blue;"></i> </li>
                                                                        
                                                                  
                                                         </ol>

                                                         <p>interface variables are by default available in the implemented classes.<br>
                                                            From the implementation classes we r allowed to access interface variables but we r not allowed to
                                                            change their values i.e reassignment is not possible because these are final.</p>


<textarea rows="14" cols="80" class="textArea" readonly>
   Ex:
   interface inter
   {
   int i = 10;
   }
   class test implements inter
   {
   public static void main(String arg[])
   {
   //i = 20; -->C.E should not assign final variable.
   System.out.println(i);
   }
   }
=======
>>>>>>> bc74eeaab552a527f26f5aa8b71c14dc10df9a46
   





<<<<<<< HEAD
   interface Left
   {
   int i = 10;
   }
   interface Right
   {
   int i = 100;
   }
   class test implements Left, Right
   {
   public static void main(String ar[])
   {
   //System.out.println(i); --> C.E reference to i is ambiguous
   System.out.println(Left.i);  (right)
   System.out.println(Right.i);  (right)
   }
   }
                        
                        </textarea>
                        <p><b>Marker Interface</b></p>
                        <p>By implementing an interface if our objects will get some ability, Such type of interfaces are called
                           “marker” or “taginterface”.<br>
                           Ex:<br>
                           Serializable, Clonable interfaces are marked for some ability.<br><br>
                           If an interface doesn’t contain any method it is always interface.<br>
                           Even though an interface contains some methods by implementing that interface if our objects will
                           get some ability. Such type of interfaces are called ‘marker’ or ‘taginterfaces’<br>
                           Ex:<br>
                           Comparable, Runnable.</p>
      </div>
      <div class="flowcontrol" *ngIf="flwc">
         <h1 class="mt-4">FLOW CONTROL</h1>
         <div class="Introduction">
            <p><b>Introduction</b></p>
         </div>
         <br>
         <p>Flow control describes the order in which all the statements will execute at run time.
            Flow controls are categorized into 3 types those are
         </p>
         <ol>
            <li>Selection statements</li>
            <li>Iterative statements</li>
            <li>Transfer statements
            </li>
         </ol>
         <p> The following fig will explains the flow controls categories.</p>
         <img src="assets/images/flowcontrol.png">
         <div class="Selectionstatements">
            <h4>Selectionstatements</h4>
         </div>
         <p><b>if-else statement</b></p>
         <p>In the case of if-else statements else part & curly braces are optional.<br>
            Without curly braces we are allowed to take 1 statement under ‘if’, that statement never be
            declarative statement other wise compile time error.
         </p>
         <div class="flowcontrols">
            if(true)<br>
            System.out.println("Hello");<i class="fa fa-check" style="margin-left: 10px;"></i> <br><br>
            if(true)<br>
            int i = 10;<i class="fa fa-close" style="margin-left: 10px;"></i><br><br>
         </div>
         <img src="assets/images/flowcontrol1.png">
         <p><b>switch statement</b></p>
         <textarea rows="11" cols="60" class="textArea" readonly>
            Syntax:-
            switch (i)  
            {
            case 1 :System.out.println("Hi");
            break;
            case 2 :System.out.println("Hello");
            break;
            case 3 :System.out.println("Hai");
            break;
            default :
            }           
                   </textarea>
         <p>Case 1:- The valid arguments to the switch statement are </p>
         <img src="assets/images/valid.png"><br><br>
         <p>The following data types are not allowed for the switch argument<br>
            long<br>
            float<br>
            double<br>
            boolean<br>
            curly braces are mandatory.
         </p>
         <br>
         Inside switch both case and default are optional (i.e)<br>
         <p style="margin-left: 30px;"> Ex:</p>
         <p style="margin-left: 50px;">
            int i = 10;<br>
            switch(i)<i class="fa fa-check" style="margin-left: 10px;"></i><br>
            &#123;<br>
            &#125;<br>
         </p>
         <p>With in switch every statement should be under some case or default i.e independent statements are
            not allowed inside switch.
         </p>
         <textarea rows="9" cols="60" class="textArea" readonly>
            Ex:-
            switch (i)  
            {
            System.out.println("Hello");
            }

            C.E: case or default expected.

            switch(i)
            {
            case 1 : 
            default: System.out.println("Hello");
            }                    
                            </textarea>
         <p>Case labels must be compiled time constants</p>
         <textarea rows="8" cols="60" class="textArea" readonly>
            Ex:

            int i = 10;
            int j = 2;
            switch (i)
            {
            case j :System.out.println("Hello");
            break;
            }                   
                            </textarea>
         <br>
         <b>C.E:</b> <br>
         <img src="assets/images/ceone.png"><br>
         <p>In this example if we declare ‘j’ as final then there is no compile time error</p>
         <textarea rows="8" cols="60" class="textArea" readonly>
            int i = 2;
            final int j = 2;
            switch (i)
            {
            case j :System.out.println("Hello");
            break;
            }                    
                              </textarea>
         <p>The ‘case’ labels must be in the range supported by switch argument.</p>
         <textarea rows="14" cols="60" class="textArea" readonly>
            Ex:
            byte b = 100;
            switch (b)
            {
            case 10 :System.out.println("10");
            break;
            case 100 :System.out.println("100");
            break;
            case 1000 :System.out.println("1000");
            break;
            }                         
                              </textarea>
         <br>
         <b>C.E:</b> <br>
         <img src="assets/images/cetwo.png"><br> <br><br>
         <p>The case labels and the switch arguments can be expressions also but case label must be constant
            expression.
         </p>
         <textarea rows="8" cols="60" class="textArea" readonly>
            byte b = 100;
            switch(b+1)
            {
            case 10:System.out.println("10");
            case 20:System.out.println("20");
            case 30+40:System.out.println("30+40 = 70");
            }                            
                                 </textarea>
         <p>Duplicate case labels are not allowed.</p>
         <textarea rows="8" cols="60" class="textArea" readonly>
            Ex:

            byte b = 100;
            switch(b+1)
            {
            case 10:System.out.println("10");
            case 20:System.out.println("20");
            case 20:System.out.println("Duplicate 20");
            }                           
                                 </textarea>
         <br>
         <b>C.E:</b> <br>
         <img src="assets/images/ce3.png"><br> <br><br>
         <p style="margin-left: 30px;"><b>Caselabel:</b></p>
         <p style="margin-left: 50px;">
            ->case label must be compile time constants.<br>
            ->case label must be in the range of switch argument.<br>
            ->case label can be expression also (only constant expression).<br>
            ->Duplicates are not allowed.
         </p>
         <p style="margin-left: 30px;"><b>default case:</b></p>
         <p style="margin-left: 50px;">In the switch statement we can place default case any where but it is convention
            to take
            default case always at least.
         </p>
         <textarea rows="8" cols="60" class="textArea" readonly>
            Ex:
            switch(x)
            {
            case 0: System.out.println("0");
            case 1: System.out.println("1");break;
            case 2: System.out.println("2");
            default: System.out.println("default");
            }                             
                                    </textarea>
         <p>
            Here if ‘x’ is 0 then output is 0,1.<br>
            if ‘x’ is 1 then output is 1.<br>
            if ‘x’ is 2 then output is 2,default.<br><br><br>
            In side switch once we got matched case from that statement on words all the statements will execute
            from top to bottom until break or end of switch.
         </p>
         <textarea rows="9" cols="60" class="textArea" readonly>
            Ex:
            switch(x)
             {
             default: System.out.println("default");
             case 0: System.out.println("0");break;
             case 1: System.out.println("1");
             case 2: System.out.println("2");
             }                                  
                                       </textarea>
         <p>Here if ‘x’ is 0 then output is 0.<br>
            if ‘x’ is 1 then output is 1,2.<br>
            if ‘x’ is 2 then output is 2.<br>
            if ‘x’ is 3 then output is default.
         </p>
         <h4>Iterative statements</h4>
         <b>while</b><br>
         <textarea rows="6" cols="55" class="textArea" readonly>
            Ex:
         
            1)        while(true)
                      {
                      System.out.println("hi");
                      }
                      System.out.println("Hello");                             
                                          </textarea>
         <br>
         <b>C.E:</b> <br>
         <img src="assets/images/ce4.png"><br> <br>
         <textarea rows="6" cols="55" class="textArea" readonly>
            2)      while(false)
                    {
                    System.out.println("hi");
                    }
                     System.out.println("Hello");
         </textarea>
         <br>
         <b>C.E:</b> <br>
         <img src="assets/images/ce5.png"><br> <br><br>
         <textarea rows="6" cols="55" class="textArea" readonly>
            3) int a = 10;
            int b = 20;
            while(a &#60; b)
            {
            System.out.println("Hi");
            }
            System.out.println("Hello");  
         </textarea>
         <br>
         <p><b>O/P:-</b> Hi<br>
            Hi<br>
            Hi<br>
            .<br>
            .<br>
         </p>
         <textarea rows="6" cols="55" class="textArea" readonly>
            4) final int a = 10;
            final int b = 20;
            while(a &#60; b)
            {
            System.out.println("Hi");
            }
            System.out.println("Hello");
          </textarea>
         <br>
         <b>C.E:</b> <br>
         <img src="assets/images/ce6.png"><br> <br><br>
         <p><b>dowhile loop</b></p>
         <p>In the loop body has to execute at least once then we should go for do-while loop.</p>
         <textarea rows="6" cols="55" class="textArea" readonly>
            Syntax:
            do
            {
            }while (boolean);  
         </textarea>
         <br>
         <p>
            Here ‘;’ is mandatory. But in C++ semicolon(;) is optional.<br>
            Curly braces are optional, with out curly braces we should take only 1 statement b/w do-while, that<br>
            statement never be declarative statement.<br>
         </p>
         <p style="margin-left: 30px;"><b>Ex:</b></p>
         <p>1) int a = 10;<br>
            int b = 20;<br>
            do<br>
            System.out.println("In do while loop");<i class="fa fa-check" style="margin-left: 10px;"></i><br>
            while (a>b);<br>
            2) do<br>
            int i = 10;<i class="fa fa-check" style="margin-left: 10px;"></i><br>
            while();<br>
            3) int a = 10;<br>
            int b = 20;<br>
            do;<br>
            while(a>b);<br>
            Here semicolon(;) after do is equivalent to empty statement in java.
         </p>
         <p><b>Case 1:</b><br> <textarea rows="6" cols="55" class="textArea" readonly>
            do
            {
            System.out.println("Hi");
            }
            while (true);
            System.out.println("Hello");
            </textarea> <br>
         </p>
         <b>C.E:</b> <br>
         <img src="assets/images/ce8.png"><br> <br><br>
         <p><b>Case 2:</b></p>
         <br>
         <textarea rows="6" cols="55" class="textArea" readonly>
               do
               {
               System.out.println("Hi");
               }
               while (false);
               System.out.println("Hello");   
            </textarea>
         <br>
         <b>O/P:-</b> Hi<br>
         Hello<br>
         <p><b>Case 3:</b></p>
         <br>
         <textarea rows="6" cols="55" class="textArea" readonly>
                  int a = 10;
                  int b = 20;
                  do
                  {
                  System.out.println("Hi");
                  }while (a &#60; b);
                  System.out.println("Hello"); 
               </textarea>
         <br>
         <b>O/P:-</b> Hi<br>
         Hi<br>
         Hi<br>
         .<br>
         .<br>
         <p><b>Case 4:</b></p>
         <br>
         <textarea rows="6" cols="55" class="textArea" readonly>
                  final int a = 10;
                  final int b = 20;
                  do
                  {
                  System.out.println("Hi");
                  }
                  while (a &#60; b);
                  System.out.println("Hello");  
               </textarea>
         <br>
         <b>C.E:</b> <br>
         <img src="assets/images/ce8.png"><br> <br><br>
         <p><b>for loop</b></p>
         <img src="assets/images/loopsyntax.png"><br> <br>
         <p><b>Initialization section:</b></p>
         It is not possible to declare more than 1 variable of different types.
         <p><b>Ex:</b>for(int i = 10,j = 20)<i class="fa fa-check" style="margin-left: 10px;"></i><br>
            for(int i = 0, long j = 0)<i class="fa fa-close" style="margin-left: 10px;"></i><br>
            for(int i = 0; long j = 0)<i class="fa fa-close" style="margin-left: 10px;"></i><br>
            for(int i = 0; i+j = 0;)<i class="fa fa-close" style="margin-left: 10px;"></i><br>
            in the initialization section we are allowed to take any valid java statement including sop also.
         </p>
         <textarea rows="6" cols="55" class="textArea" readonly>
            Ex:
            int i = 0;
            for(System.out.println("Hi");i &#60; 5;i++)
            {
            System.out.println("Hello");
            }              
         </textarea>
         <br>
         <img src="assets/images/ce10.png"><br> <br>
         <p><b>Conditional Expression:</b>Any expression which should return boolean value.
            It is optional & default value is true by compiler.
         </p>
         <img src="assets/images/example1.png"><br> <br>
         <p><b>Increment/Decrement section:</b> Any valid java statement is allowed including System.out.println
            also
         </p>
         <textarea rows="6" cols="55" class="textArea" readonly>
            Ex:
            for(System.out.println("Hi");;System.out.println("Hello"))
            {
            System.out.println("xyz");
            }     
               </textarea>
         <br>
         <p> <b>O/P:- </b>Hi<br>
            xyz<br>
            Hello<br>
            .<br>
            .<br>
         </p>
         <p>All the 3 parts of for loop are independent of each other & optional.
            For( ; ;);
         </p>
         <p><b>Case1:</b></p>
         <textarea rows="6" cols="55" class="textArea" readonly>
            for(int i = 0;true;i++)
            {
            System.out.println("Hello");
            }
            System.out.println("Hi");                         
                                 </textarea>
         <br>
         <b>C.E:</b> <br>
         <img src="assets/images/ce11.png"><br> <br><br>
         <p><b>Case2:</b></p>
         <textarea rows="6" cols="55" class="textArea" readonly>
            for(int i = 0; ; i++)
            {
            System.out.println("Hello");
            }
            System.out.println("Hi");                     
                                 </textarea>
         <br>
         <b>C.E:</b> <br>
         <img src="assets/images/ce12.png"><br> <br><br>
         Because by default conditional expression is true.<br>
         <p><b>Case3:</b></p>
         <textarea rows="6" cols="55" class="textArea" readonly>
            for(int i = 0;false;i++)
            {
            System.out.println("Hello");
            }
            System.out.println("Hi");
                                      
                                 </textarea>
         <br>
         <b>C.E:</b> <br>
         <img src="assets/images/ce13.png"><br> <br><br>
         <p><b>Case4:</b></p>
         <textarea rows="6" cols="55" class="textArea" readonly>
            int a = 10,b = 20;
            for(int i = 0;a &#60; b; i++)
            {
            System.out.println("Hello");
            }
            System.out.println("Hi");                         
                                    
                                 </textarea>
         <br>
         <p> <b>O/P:- </b>Hello<br>
            Hello<br>
            Hello<br>
            .<br>
            .<br>
         </p>
         <p><b>Case5:</b></p>
         <textarea rows="6" cols="55" class="textArea" readonly>
            final int a = 10,b = 20;
            for(int i = 0;a &#60; b; i++)
            {
            System.out.println("Hello");
            }
            System.out.println("Hi");  
                                      
               </textarea>
         <br>
         <b>C.E:</b> <br>
         <img src="assets/images/ce14.png"><br> <br><br>
         <p><b>for each loop</b><br>
            The most convenient loop for accessing the elements of only arrays & collections this loop has
            introduced in 1.5 version.
            <img src="assets/images/example2.png"><br> <br>
            for-each loop is the most convenient loop to access the elements of arrays & collections but the
            limitation of this loop is applicable for arrays & collections and it is not general loop.
         </p>
         <h3>Transfer statements</h3>
         It can be used in the following places.<br>
         <ol>
            <li>with in the loops to come out of the loop.</li>
            <li>Inside switch statement to come out of the switch .</li>
            <li>If we are using break any where else we will get a compile time error</li>
         </ol>
         <textarea rows="6" cols="55" class="textArea" readonly>
               Ex:
               int x = 0;
               if(x!=5)
               break;
               System.out.println("if");
            </textarea>
         <br>
         <b>C.E:</b> <br>
         <img src="assets/images/ce15.png"><br> <br><br>
         <p><b>continue</b></p>
         <br>
         <ol>
            <li>we should use ‘continue’ only in the loops to skip current iteration & continue for the next
               iteration
            </li>
            <li>If we are using ‘continue’ any where except loops we will get compile time error saying
               “continue out side of loop”.
            </li>
         </ol>
         <textarea rows="6" cols="55" class="textArea" readonly>
               Ex:
               for(int i=0;i &#60; 10;i++)
               {
               if((i%2) &#61;&#61; 0)
               continue;
               System.out.print(i);
               }
            </textarea>
         <p><b>O/P:- </b>13579</p>
      </div>
      <div class="assertions" *ngIf="assertion">
         <h1 class="mt-4">ASSERTIONS</h1>
         <p><b>Introduction</b></p>
         <p>Assertions has introduced in 1.4 version. The main objective of assertions is to perform debugging.</p>
         <p>The traditional way of debugging is to use System.out.printlnâs. But the main disadvantage of this
            approach
            is compulsory we should remove these S.O.Pâs after fixing the problem other wise these will execute at run
            time. Which may effect performance of the system. It may reduce readability of the code and disturbs
            logging mechanism.
         </p>
         <p>To resolve all these problems sun people has introduces Assertions concept in 1.4 version.</p>
         <p>The main advantage of assertions is we can enable or disable assertions based on our requirement. But by
            default assertions are disabled.
         </p>
         <p>Assertions concept we have to use in Test environment or in Development environment but not in the
            production.
         </p>
         <p><b>Identifier Vs Keyword</b></p>
         <p>Assert keyword has introduced in 1.4 version hence from 1.4 version on words we are not allowed to use
            assert as identifier.
         </p>
         <textarea rows="11" cols="60" class="textArea" readonly>
               Ex:-
               class Test
               {
               public static void main(String[] args)
               {
               int assert = 10;
               System.out.println("assert");
               }
               }


         </textarea>
         <p>in 1.4 or 1.5 if we compile
            javac assert.java then we will get the following C.E as of release 1.4 assert is a keyword and may not used
            as
            an identifier.
            javac âsource 1.3 assert.java
         </p>
         <p><b>Types of assert statement</b></p>
         <p>There are 2 types of assert statement
            1) simple assert.
            2) Augmented assert.
         </p>
         <p><b>Simple assert</b></p>
         <textarea rows="11" cols="60" class="textArea" readonly>Syntax: assert <boolean expression> ;
            assert(b);</textarea>
         <p>If b is true then normal continuation follows. Else the program will terminate abnormally can rise
            assertion error.
         </p>
         <textarea rows="11" cols="60" class="textArea" readonly>Ex:-
                        class Test
                        {
                        public static void main(String[] args)
                        {
                        int x = 10;
                        :
                        :
                        assert(x>10)
                        System.out.println(x);
                        }
                        }
                        </textarea>
         <ol>
            <li>javac Test.java</li>
            <li>java Test
               in this case assert statement wonât be executed because it is disable by default.
            </li>
            <li> java âea Test
               Then generates assertion error.
            </li>
         </ol>
         <p><b>Augmented Version</b></p>
         <textarea rows="11" cols="60" class="textArea" readonly>
      Syntax: assert <boolean expression> : <message expression> ;
            Assert e1:e2;
            âe1â ï  should be boolean type.
            âe2â ï  any thing is allowed including method calls also
            Ex:-
            class Test
            {
            public static void main(String[] args)
            {
            int x = 10;
            ;
            ;
            assert(x>10):"here the value of x should be > 10 but it is "+x;
            System.out.println(x);
            }
            }
            
</textarea>
         <p>javac Test.java
            java âea Test
         </p>
         <p><b>O/P:-</b></p>
         <img src="assets/images/Capture.PNG">
         <p>Note: assert e1:e2
            Here âe2â will be executed iff âe1â is false.
         </p>
         <textarea rows="11" cols="60" class="textArea" readonly>Ex:-
            class Test
            {
            public static void main(String[] args)
            {
            int x = 10;
            ;
            ;
            assert(x==0):++x;
            System.out.println(x);
            }
            }
            </textarea>
         <p>javac Test.java
            java âea Test
         </p>
         <p><b>O/P:-</b></p>
         <img src="assets/images/output.PNG">
         <p><b>-></b></p>
         <p>assert(e1):e2;
            for e2 any thing is allowed including method calls also But void return type method
            calls
            are not allowed. Violation leads to compile time error.
         </p>
         <textarea rows="11" cols="60" class="textArea" readonly> Ex:-
            class Test
            {
            public static void main(String[] args)
            {
            int x = 10;
            ;
            ;
            assert(x>0):m1();
            System.out.println(x);
            }
            public static void m1()
            {
            return;
            }
            }
            </textarea>
         <p>javac Test.java
            java âea Test
         </p>
         <p><b>O/P:-</b></p>
         <img src="assets/images/output5.PNG">
         <p><b>Various Run Time Flags</b></p>
         <ol>
            <li> -ea -> &nbsp; To enable assertions in every non-system class(i.e user defined
               class)
            </li>
            <li> -enableassertions -> &nbsp; To enable assertions in every non-system class(Exactly similar
               to -ea)
            </li>
            <li> -da-> &nbsp; To disable assertions in every non-system class.</li>
            <li>-isableassertions-> &nbsp; To disable assertions in every non-system class.(Exactly similar to -da)</li>
            <li>-esa-> &nbsp; To enable assertions in every system class</li>
            <li>-enablesystemassertion-> &nbsp; similar to -esa</li>
            <li>âdsa -> To disable assertions in every system class</li>
            <li>-disablesystemassertions-> &nbsp; similar to â-dsaâ
            </li>
         </ol>
         <p>Ex:-
            java âea âesa âda âdsa âea Test
            All the flags will execute from left to right and there is no priority difference b/w enabling and disabling
         </p>
         <img src="assets/images/figure.PNG">
         <br />
         <ol>
            <li> <i class="fa fa-arrow-right" style="color:black; margin-left: 10px;"></i> To enable assertions only in
               the âA- Classâ
               java -ea:Pack1.A
            </li>
            <li> <i class="fa fa-arrow-right" style="color:black; margin-left: 10px;"></i> To enable assertions only in
               B and D
               java -ea:Pack1.B -ea:Pack1.Pack2.D
            </li>
            <li> <i class="fa fa-arrow-right" style="color:black; margin-left: 10px;"></i> To enable assertion in all
               classes of Pack1 and its sub package classes also.
               java âea:Pack1â¦
            </li>
            <li> <i class="fa fa-arrow-right" style="color:black; margin-left: 10px;"></i> To enable assertions in all
               classes present in pack1 but not those present in pack2
               java -ea:Pack1â¦ -da:Pack1.Pack2â¦
            </li>
         </ol>
         <p>Note:- we can enable assertions either class wise or package wise also.</p>
         <p><b>Proper and Improper Use of assertions</b></p>
         <ol>
            <li> It is improper to use assert statement for validating the arguments of a public method.</li>
            <textarea rows="11" cols="60" class="textArea" readonly>

         public void withdraw(double amount)
         {
         assert(amount >= 100);
         }
         
   </textarea>
            <li> It is improper to use assertions for validating command line argument also, because these are arguments
               to public main method.
            </li>
            <li> It is proper to use assertions for validating private method argument</li>
            <li> It is improper to mix programming language with assert statement.</li>
            <li> In our code if there is any place where the control is not allowed to reach. It is the best place to
               use the
               assert statement.
            </li>
         </ol>
         <textarea rows="11" cols="60" class="textArea" readonly>Ex:- switch (month)
      {
      case 1:
      ....
      ....
      case 2:
      ....
      ....
      case 3:
      ....
      ....
      case 4:
      ....
      ....
      :
      :
      :
      case 12:
      ....
      ....
      default:
      assert(false);
      }</textarea>
         <p><b>AssertionError</b></p>
         <p>It is the child class of Error and it is unchecked.
            It is not recommended to catch AssertionError by using catch Block. It is stupid type of activity
         </p>
         <textarea rows="11" cols="60" class="textArea" readonly>Ex:-
            class Test
            {
            public static void main(String arg[])
            {
            int x = 10;
            ;
            ;
            ;
            try
            {
            assert(x>10);
            }
            catch (AssertionError e)
            {
            System.out.println("I am stupid...Because I am catching
             Assertion");
            }
            }
            }
            </textarea>
         <p><b>O/P:-</b></p>
         <img src="assets/images/output4.PNG">
      </div>
      <div class="ooconcepts" *ngIf="ooconcept">
         <h1 class="mt-4">OO CONCEPTS</h1>
         <ol>
            <li>Data hiding</li>
            <li>Abstraction</li>
            <li>Encapsulation</li>
            <li>Tightly Encapsulated class</li>
            <li>Is – A Relation Ship</li>
            <li>HAS – A Relation ship</li>
            <li>method signature</li>
            <li>overloading</li>
            <li>overriding</li>
            <li> method hiding</li>
            <li>static control flow</li>
            <li>instance control flow</li>
            <li>constructors</li>
            <li>coupling</li>
            <li>cohesion</li>
            <li>typecasting</li>
         </ol>
         <p><b>Data Hiding:</b><br>
            The data should not go out directly i.e outside person is not allowed to access the data this is nothing
            but<br />
            <span class="italic">&ldquo;Data Hiding&rdquo;</span><br />
            The main advantage of data hiding is we can achieve security.<br />
            By using private modifier we can achieve this.
         </p>
         <textarea rows="9" cols="55" class="textArea" readonly>
               Ex:
               
                     Class datademo
					 {
                     private double amount;
                     ………
                     }
                     O/P:- 10…8…16
             </textarea>
         <p>It is highly recommended to declare data members with private modifier.</p>
         <p><b>Abstraction:</b><br>
            Hiding implementation details is nothing but abstraction. The main advantages of abstraction are we can
            achieve <b>security</b> as we r not highlighting internal implementation.
            <b>Enhancement</b> will become easy. With out effecting outside person we can change our internal
            implementation.
         </p>
         <p class="improves">It improves <b>maintainability</b></p>
         <b>Note:- </b> 1. If we don’t know about implementation just we have to represent the specification then we
         should
         go for <b class="Abstraction">interface</b>
         <ol start="2" class="NoteAbstraction">
            <li> If we don’t know about complete implementation just we have partial implementation then we
               should go for <b class="Abstraction">abstract.</b>
            </li>
            <li>If we know complete implementation and if we r ready to provide service then we should go for
               concrete class
            </li>
         </ol>
         <p><b>Encapsulation:</b><br>
            If a class follows data hiding and abstraction such type of class is said to be ‘Encapsulated’ class.
         </p>
         <b class="EncapsulationDataHiding">Encapsulation = Data Hiding + Abstraction</b><br /><br />
         <textarea rows="17" cols="55" class="textArea" readonly>
Ex:
            class Account
            {
            private int balance;
            public void setBalance(int balance)
            {
            //validating the user & his permissions.
            this.balance = balance;
            }
            public int getBalance()
            {
            //validating the user and his permissions.
            return balance;
            }
            }
           
 </textarea>
         <p>The data members we have to declared as private. So that outside person is not allowed to access to directly
            we have to provide Access to our data by defining setter and getter methods. i.e hiding data behind methods
            is the central concept of encapsulation.
         </p>
         <p class="pEncapsulation">The main advantages of encapsulation are security, enhancement, maintainability</p>
         <p><b>Tightly Encapsulated Class:</b><br>A class is said to be tightly encapsulated iff all the data members
            declared as private. </p>
         <textarea rows="17" cols="55" class="textArea" readonly>
Ex:-
            class student
            {
            private String name;
            public void setName(String name)
            {
            this.name = name;
            }
            public String getName()
            {
            return name;
            }
            }
</textarea>
         <br />
         <p><b>Q) which of the following classes are tightly encapsulated classes?</b></p>
         <textarea rows="20" cols="60" class="textArea" readonly>
            class x
            {
            private int i =10;
            private int getI(); 
            {
            return i;
            }
            }
            class y extends x  
            {
            public int i = 30;
            }
            class z extends x
            {
            private int k = 40;
            }
            }
   
</textarea>
         <p><b>Q)</b></p>
         <textarea rows="12" cols="55" class="textArea" readonly>

         class x
         {
         int i = 0;
         }
         class y extends x
         {
         private int j = 20;
         }
         class z extends y
         {
         private int k = 30;
         }
         }
   </textarea>
         <p>no class is tightly encapsulated if the parent class is not tightly encapsulated then no child class is
            tightly encapsulated.</p>
         <p><b>IS – A RelationShip</b></p>
      </div>
      <div class="innerclasses" *ngIf="innerclass">
         <h1 class="mt-4">INNER CLASSES</h1>
         <h3><b>Introduction</b></h3>
         <p>
            We can declare a class inside another class such type of classes are called innerclasses.
            This innerclasses concept has introduced in 1.1 version as the part of event handling. By observing the
            utilities and functionalities of inner class slowly the programmers are using this concept even in regular
            coding also.
         </p>
         <p> With out existing car object there is no chance of existing wheel object. Hence we
            have to declare wheel class inside car class.
         </p>
         <textarea rows="12" cols="60" class="textArea" readonly>
                  Ex:
                  class car
                  {
                     class wheel
                     
                          {


                          }
                   }
                  
                </textarea>
         <p> A map is a collection of entry objects. With out existing Map object there is no
            chance of existing entry object. Hence we have to define entry interface inside
            map interface.
         </p>
         <textarea rows="12" cols="60" class="textArea" readonly>
                     Ex:
                     interface Map
                     {
                        interface Entity
                        
                             {
   
   
                             }
                      }
                     
                   </textarea>
         <p>Based on the purpose and position of inner class all the inner classes are divided into 4 categories</p>
         <ol>
            <li>Normal/Regular inner classes </li>
            <li>Method local inner classes</li>
            <li>Anonymous inner classes</li>
            <li>static nested classes</li>
         </ol>
         <h3><b>Normal/Regular inner classes
            </b>
         </h3>
         <p>
            A class declared inside another class directly with out static modifier is called normal or regular inner
            class.
         </p>
         <p>Ex.</p>
      </div>
      <div class="threadconcurrency" *ngIf="threadcon">
         <h1 class="mt-4">THREADS AND CONCURRENCY</h1>
         <h4><b>Introduction</b></h4>
         <p ><b>Multitasking</b> &nbsp;&nbsp;&nbsp;&nbsp; Executing several tasks
            simultaneously is called ‘Multitasking’, There are 2 <br>
            types of multitasking.
         </p>
         <ol>
            <li>Process based Multitasking.</li>
            <li>Thread based Multitasking.</li>
         </ol>
         <p ><b>Process based Multi Tasking</b><br>
            Executing several tasks simultaneously where each task is a separate independent process is<br>
            called ‘Process based Multitasking’.<br>
            Ex:<br>
         </p>
         <p style=" margin-top: -15px;">While writing java program in the editor we can run MP3
            player. At the same time we<br>
            can download a file from the net. All these tasks are executing simultaneously and<br>
            independent of each other. Hence it is process based Multitasking. Process based<br>
            Multitasking is best suitable at O.S level.
         </p>
         <p ><b>Thread based Multi Tasking</b><br>
            Executing several tasks simultaneously where each task is a separate independent part of the<br>
            same program is called Thread based Multitasking. This type of multitasking is best suitable<br>
            at programmatic level.<br>
            Java provides in built support for thread based multitasking by providing rich library (Thread,<br>
            ThreadGroup, Runnable ..etc)<br>
            Whether it is Processbased or Threadbased the main objective of multitasking is to reduce<br>
            response time and improve performance of the system.
         </p>
         <p >The main application area of multithreading is videogames implementation,
            ,Multimedia graphics<br>
            …etc.
         </p>
         <h4 ><b>Defining Instantiating, Starting the Thread</b></h4>
         <p >We can define instantiate and starting a thread by using the following 2- ways.
         </p>
         <ol style=" margin-top: -15px;">
            <li>By extending Thread Class.</li>
            <li>By implementing Runnable interface.</li>
         </ol>
         <p ><b>By extending Thread Class</b></p>
         <textarea rows="26" cols="60" class="textArea" readonly>
         Ex:
         class MyThread extends Thread
         {
         public void run()
         {
         for (int i=0; i&#60;10; i++ )
         {
         System.out.println("Child Thread");
         }
         }
         }
         class MultiThreadDemo
         {
         public static void main(String[] args) throws InterruptedException
         {
         MyThread t = new MyThread();
         t.start();
         for(int i = 0; i&#60;10; i++)
         {
         System.out.println("Main Thread");
         }
         }
         }
         </textarea>
         <p style=" font-weight: 500;">Case1 :</p>
         <br>
         <p style=" margin-top: -35px;"><b>Thread Shedular:</b><br>
            If multiple threads are there then which thread will get chance first for execution will be<br>
            decided by “Thread Scheduler”. Thread Scheduler is the post of JVM. The behavior of thread<br>
            scheduler is vendor dependent and hence we can’t expect exact O/P for the above program.<br>
         </p>
         <p >The possible Outputs are:</p>
         <img src="assets/images/threadshedular.PNG" id="threadshedular"><br>
         <br>
         <p style="font-weight: 500;">Case2 :</p>
         <br>
         <p style=" margin-top: -35px;"><b>The difference between t.start() & t.run():</b><br>
            In the case of t.start() a new thread will be created and which is responsible for the execution<br>
            of run. But in the case of t.run() no new thread will be created and run() method will be<br>
            executed just like a normal method by the main thread.<br>
            Hence in the above program if we are replacing t.start() with t.run() then the O/P is<br>
         </p>
         <img src="assets/images/case2.PNG" id="case2"><br>
         <br>
         <p style=" font-weight: 500;">Case3 :</p>
         <br>
         <p style=" margin-top: -35px;"><b>Importance of Thread Class start() method:</b><br>
            After Creating thread object compulsory we should perform registration with the thread<br>
            scheduler. This will take care by start() of Thread class, So that the programmers has to<br>
            concentrate on only job. With out executing Thread class start() method there is no chance of<br>
            start a new Thread in java.<br>
         </p>
         <textarea rows="7" cols="60" class="textArea" readonly>
         start()
         {
         Register our thread with the thread scheduler.
         Invoke run method.
         }
         </textarea>
         <p style=" font-weight: 500;">Case4 :</p>
         <br>
         <p style=" margin-top: -35px;"><b>If we are not overriding run() method:</b><br>
            Then the thread class run method will be executed which has empty implementation.<br>
         </p>
         <textarea rows="15" cols="60" class="textArea" readonly>
         Ex:
         class MyThread extends Thread
         {
         }
         class ThreadDemo
         {
         public static void main(String arg[])
         {
         MyThread t = new MyThread();
         t.start();
         }
         }
         O/P:- no output
         </textarea>
         <p style=" font-weight: 500;">Case5 :</p>
         <br>
         <p style=" margin-top: -35px;"><b>If we are overriding start() method:</b><br>
           <textarea rows="25" cols="60" class="textArea" readonly>
            Ex:
            class MyThread extends Thread
            {
            public void start()
            {
            System.out.println("start() method");
            }
            public void run()
            {
            System.out.println("run method");
            }
            }
            class ThreadDemo
            {
            public static void main(String arg[])
            {
            MyThread t = new MyThread();
            t.start();
            }
            }
            O/P:- start() method
            </textarea>
            <p style=" font-weight: 500;">Case6 :</p>
            <br>
            <textarea rows="27" cols="60" class="textArea" readonly>
         class MyThread extends Thread
         {
         public void start()
         {
         super.start();
         System.out.println("start() method");
         }
         public void run()
         {
         System.out.println("run method");
         }
         }
         class ThreadDemo
         {
         public static void main(String arg[])
         {
         MyThread t = new MyThread();
         t.start();
         System.out.println("main method");
         }
         }
         O/P:- start() method.
         run method.
         main method.
         </textarea>
            <p ><b>Life cycle of Thread</b><br>
               When u write new MyThread()<br>
            </p>
            <img src="assets/images/Life cycle of Thread.PNG"
                  id="lifecycle"><br>
            <p ><b>Note:-</b>&nbsp;we can’t stop a running Thread explicitly. But until 1.2
               version we can achieve this by using
               stop() method but it is deprecated method. Similarly suspend() and resume() methods also
               deprecated.<br>
            </p>
            <p >After starting a thread we are not allowed to restart the same thread once
               again, violation leads to<br>
               Runtime Error saying “IllegalThreadStateException”.<br>
            </p>
            <p style="margin-top: -10px;"> MyThread t = new MyThread();<br>
               t.start();<br>
               t.start(); <i class="fa fa-arrow-right" style="margin-left: 10px;"></i> Illegal Thread state
               Exception.<br>
            </p>
            <p ><b>By Implementing Runnable Interface</b></p>
            <p >We can define a Thread by implementing runnable interface also. Runnable
               interface available in<br>
               java.lang package and contains only one method
            </p>
            <p style=" margin-top: -10px; ">public void run();</p>
            <img src="assets/images/RunnableInterface.PNG" id="interface"><br>
            <textarea rows="27" cols="60" class="textArea" readonly>
         Ex:
         class MyRunnable implements Runnable
         {
         public void run()
         {
         for(int i = 0;i&#60;=10;i++)
         {
         System.out.println("Child Thread");
         }
         }
         }
         class ThreadDemo
         {
         public static void main(String arg[])
         {
         MyRunnable r = new MyRunnable();
         Thread t = new Thread(r);
         t.start();
         for(int i = 0;i&#60;=10;i++)
         {
         System.out.println("Main Thread");
         }
         }
         }
         </textarea><br>
       <img src="assets/images/RunnableInterface1.PNG"
                  id="interface1"><br>
            <textarea rows="7" cols="60" class="textArea" readonly>
         Ex:
         MyRunnable r = new MyRunnable();
         Thread t1 = new Thread();
         Thread t2 = new Thread(r);
         </textarea>
            <br>
            <p style=" font-weight: 500;">Case1 :</p>
            <p style=" margin-top: -10px;">t1.start();</p>
            <p >A new thread will be started and executes thread class run method(Which is
               having empty
               implementation).
            </p>
            <p style=" font-weight: 500;">Case2 :</p>
            <p style=" margin-top: -10px;">t1.run();</p>
            <p >No new thread will be created and thread class run() method will be executed
               just like a
               normal method call.
            </p>
            <p style=" font-weight: 500;">Case3 :</p>
            <p style=" margin-top: -10px;">t2.start();</p>
            <p >A new thread will be created and responsible for execution of MyRunnable run
               method.</p>
            <p style="font-weight: 500;">Case4 :</p>
            <p style=" margin-top: -10px;">t2.run();</p>
            <p >No new thread will be created and MyRunnable run method will be executed just
               like a
               normal method call.
            </p>
            <p style=" font-weight: 500;">Case5 :</p>
            <p style=" margin-top: -10px;">r.run();</p>
            <p >No new thread will be created and MyRunnable run method will be executed just
               like a
               normal method call.
            </p>
            <p style=" font-weight: 500;">Case6 :</p>
            <p style=" margin-top: -10px;">r.start();</p>
            <p >Compiler Error: MyRunnable doesn’t contain start method.</p>
            <br>
            <p ><b>In which of the following cases a new thread will be started.</b></p>
            <p >
               1) t1.start(); <i class="fa fa-check" style=" margin-left: 10px;color: blue;"></i><br>
               2) t1.start(); <i class="fa fa-check" style=" margin-left: 10px;color: blue;"></i><br>
               3) r.start();<br>
               4) t1.run();<br>
               5) t2.run();<br>
               6) r.run();<br>
            </p>
            <p ><b>Note:-</b>&nbsp;Among 2- approaches of defining a thread – implements
               Runnable is always recommended to<br>
               use in the 1<sup>st</sup> approach as we are already extending thread class. There is no chance of
               extending any<br>
               other class. Hence we are missing the key benefits of oops inheritance(reusability) . hence this<br>
               approach is not recommended to use.
            </p>
            <p style="font-size: 18px;"><b>Hybrid Mechanism To define a thread(not recommended to
                  use)</b></p>
            <textarea rows="26" cols="60" class="textArea" readonly>
         Ex:
         class MyThread extends Thread
         {
         public void run()
         {
         System.out.println("Child Thread");
         }
         }
         class HybridThreadDemo
         {
         public static void main(String arg[])
         {
         MyThread t1 = new MyThread();
         Thread t = new Thread(t1);
         t.start();
         System.out.println("Main Thread");
         }
         }
         O/P:- Child Thread
         Main Thread
         Or
         Main Thread
         Child Thread
         </textarea>
            <p style=" font-size: 17px;"><b>Thread class construtors</b></p>
            <p>
               1) Thread t = new Thread();<br>
               2) Thread t = new Thread(Runnable r);<br>
               3) Thread t = new Thread(String name);<br>
               4) Thread t = new Thread(Runnable r, String name);<br>
               5) Thread t = new Thread(ThreadGroup g, String name);<br>
               6) Thread t = new Thread(ThreadGroup g, Runnable r);<br>
               7) Thread t = new Thread(ThreadGroup g, Runnable r, String name);<br>
               8) Thread t = new Thread(ThreadGroup g, Runnable r, String name, long stacksize);<br>
            </p>
            <p style=" font-size: 17px;"><b>Thread class construtors</b></p>
            <p>Thread class defines the following methods to set and get the name of a
               Thread.<br>
               1) public final void setName(String name);<br>
               2) public final String getName();
            </p>
            <textarea rows="12" cols="60" class="textArea" readonly>
         Ex:
         class Test
         {
         public static void main(String arg[])
         {
         System.out.println(Thread.currentThread().getName());
         Thread.currentThread().setName("New Thread");
         System.out.println(Thread.currentThread().getName());
         }
         }
         </textarea><br>
            <img src="assets/images/setting&getting.PNG" id="setting"><br>
            <p style=" font-size: 17px;"><b>Thread Priorities</b></p>
            <p >Every Thread in java having some priority. The range of valid thread
               priorities is (1-10) (1 is least & 10 is<br>
               Highest). Thread class defines the following constant for representing some standard priorities.
            </p>
            <br>
            <p >Thread.MIN_PRIORITY <i class="fa fa-arrow-right"
                  style="margin-left: 10px;"></i>1<br>
               Thread.NORM_PRIORITY <i class="fa fa-arrow-right" style="margin-left: 10px;"></i>2<br>
               Thread.MAX_PRIORITY <i class="fa fa-arrow-right" style="margin-left: 10px;"></i>3
            </p>
            <br>
            <p >Thread scheduler use these priorities while allocating C.P.U. The Thread which
               is having highest priority
               will get chance first for execution. If two threads having the same priority then which thread will get
               chance
               first for execution is decided by Thread Scheduler, which is vendor dependent i.e we can’t expect
               exactly.
            </p>
            <p>The default priority for the main thread only the 5, but for all the remaining
               threads the priority will be
               inherit from parent i.e what ever the parent has the same priority the child thread also will get.
            </p>
            <p >Thread class contains the following methods to set and get priorities of
               thread.</p>
            <p >1) public final void setPriority(int priority)<br>
               where priority should be from 1-10 other wise R.E: IllegalArgumentException.<br>
               2) public final int getPriority();
            </p>
            <textarea rows="27" cols="60" class="textArea" readonly>
         Ex:
         class MyThread extends Thread
         {
         public void run()
         {
         for (int i=0; i&#60;10 ; i++ )
         {
         System.out.println("Child Thread");
         }
         }
         }
         class ThreadPriorityDemo
         {
         public static void main(String arg[])
         {
         MyThread t = new MyThread();
         System.out.println(t.getPriority());
         t.setPriority(10);
         t.start();
         for(int i =0;i&#60;10;i++)
         {
         System.out.println("Main Thread");
         }
         }
         }
         </textarea><br>
           <img src="assets/images/Thread Priorities.PNG" id="priorities"><br>
            <p >Some Operating Systems may not provide support for thread priorities.</p>
            <p style=" font-size: 17px;"><b>Preventing Thread from execution</b></p>
            <p >We can prevent a thread from execution by using the following methods.</p>
            <p style=" margin-top: -10px; ">1) yield()<br>
               2) join()<br>
               3) sleep()
            </p>
            <br>
            <p style=" font-size: 17px;"><b>yield()</b></p>
            <p style=" margin-top: -10px; ">The thread which is called yield() method temporarily
               pause the execution to give the chance for<br>
               remaining threads of same priority. If there is no waiting thread or all waiting threads having low<br>
               priority. Then the same thread will get the chance immediately for the execution.
            </p>
            <p >public static native void yield();</p>
            <img src="assets/images/yield.PNG" id="yield"><br>
            <br>
            <textarea rows="26" cols="60" class="textArea" readonly>
         Ex:
         class MyThread extends Thread
         {
         public void run()
         {
         for (int i=0; i&#60; 10 ; i++ )
         {
         System.out.println("Child Thread");
         Thread.yield();
         }
         }
         }
         class YieldDemo
         {
         public static void main(String arg[])
         {
         MyThread t = new MyThread();
         t.start();
         for(int i =0;i&#60;i++)
         {
         System.out.println("Main Thread");
         }
         }
         }
         </textarea>
            <p >In this case main thread will get chance more no of times for execution.
               Because child thread<br>
               intentionally calling “yield()” method. As the yield method is native method some Operating system<br>
               may not provide the support for this.
            </p>
            <br>
            <p style=" font-size: 17px;"><b>join()</b></p>
            <p >If a thread wants to wait until some other thread completion then we should go
               for join method.<br>
               Ex:
            </p>
            <p style=" margin-top: -10px;"> If a thread t1 executes t2.join(), then t1 will be
               entered into waiting state until t2
               completion.<br>
               public final void join() throws InterruptedException<br>
               public final void join(long ms) throws InterruptedException<br>
               public final void join(long ms, int ns) throws InterruptedException
            </p>
           <img src="assets/images/join.PNG" id="join"><br>
            <br>
            <textarea rows="35" cols="60" class="textArea" readonly>
         Ex:
         class MyThread extends Thread
         {
         public void run()
         {
         for (int i=0; i&#60;10 ; i++ )
         {
         System.out.println("Child Thread");
         try
         {
         Thread.sleep(1000);
         }
         catch (InterruptedException e)
         {
         }
         }
         }
         }
         class JoinDemo
         {
         public static void main(String arg[])throws InterruptedException
         {
         MyThread t = new MyThread();
         t.start();
         t.join(); --> 1
         //t.join(4000)
         for(int i =0;i&#60;10;i++)
         {
         System.out.println("Main Thread");
         }
         }
         }
         </textarea><br>
            <img src="assets/images/join1.PNG" id="join1"><br>
            <p style=" font-size: 17px;"><b>sleep()</b></p>
            <p >If a method has to wait some predefined amount of time with out execution
               then we should go for<br>
               sleep() method.
            </p>
            <p >public static void sleep(long ms)throws InterruptedException<br>
               public static void sleep(long m, int m)throws InterruptedException
            </p>
           <img src="assets/images/sleep.PNG" id="sleep"><br>
         <textarea rows="30" cols="60" class="textArea" readonly>
         Ex:
         class MyThread extends Thread
         {
         public void run()
         {
         try
         {
         for (int i = 0;i&#60;10;i++)
         {
         System.out.println("This is Lazy Method");
         Thread.sleep(1000);
         }
         }
         catch (InterruptedException e)
         {
         System.out.println(e);
         }
         }
         }
         class SleepDemo
         {
         public static void main(String arg[])throws InterruptedException
         {
         MyThread t = new MyThread();
         t.start();
         System.out.println("Main Thread");
         }
         }
         </textarea><br>
           <img src="assets/images/sleep1.PNG" id="sleep1"><br>
            <p ><b>interrupting a thread</b></p>
            <p style=" margin-top: -10px;">we can interrupt a sleeping or waiting thread by using
               interrupt method of thread class.</p>
            <p >public void interrupt()</p>
            <p >when ever we are calling interrupt() the target thread may not be effected
               immediately. At the time<br>
               of calling interrupt if the target thread is not in sleeping or in waiting state interrupt call will
               wait<br>
               until target thread entered into sleeping or waiting state.
            </p>
           <textarea rows="34" cols="60" class="textArea" readonly>
         Ex:
         class MyThread extends Thread
         {
         public void run()
         {
         try
         {
         for (int i = 0;i&#60;10;i++)
         {
         System.out.println("This is Lazy Method");
         // Thread.sleep(3000); --> 1
         }
         Thread.sleep(3000); --> 2
         }
         catch (InterruptedException e)
         {
         System.out.println(e);
         }
         }
         }
         class InterruptDemo
         {
         public static void main(String arg[])throws InterruptedException
         {
         MyThread t = new MyThread();
         t.start();
         t.interrupt();
         System.out.println("Main Thread");
         }
         }
         </textarea><br>
            <img src="assets/images/interruptingthread.PNG"
                  id="interrupt"><br>
            <p ><b>Synchronization table for yield(), join() & sleep()</b></p>
            <table class="table table-bordered">
               <thead>
                  <tr>
                     <th scope="col">Property</th>
                     <th scope="col">yield()</th>
                     <th scope="col">join()</th>
                     <th scope="col">sleep()</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>Is it overloaded?</td>
                     <td>No</td>
                     <td>Yes</td>
                     <td>Yes</td>
                  </tr>
                  <tr>
                     <td>Is it static?</td>
                     <td>Yes</td>
                     <td>No</td>
                     <td>Yes</td>
                  </tr>
                  <tr>
                     <td>Is it final?</td>
                     <td>No</td>
                     <td>Yes</td>
                     <td>No</td>
                  </tr>
                  <tr>
                     <td>Is it throws
                        InterruptedException?
                     </td>
                     <td>No</td>
                     <td>Yes</td>
                     <td>Yes</td>
                  </tr>
                  <tr>
                     <td>Is it native?</td>
                     <td>Yes</td>
                     <td>No</td>
                     <td>Sleep(long ms) <i class="fa fa-arrow-right" style="margin-left: 10px;"></i>native<br>
                        Sleep(long ms, int ms) <i class="fa fa-arrow-right" style="margin-left: 10px;"></i>not native
                     </td>
                  </tr>
               </tbody>
            </table>
            <p style=" font-size: 22px;"><b>Synchronization</b></p>
            <p >‘synchronized’ is the keyword applicable for the methods and blocks. We can’t
               apply this keyword for<br>
               variables and classes. If a method declared as synchronized at a time only one thread is allowed to
               execute<br>
               that method on the given object. The main advantage of synchronized keyword is we can overcome data<br>
               inconsistency problem. The main limitation of synchronized keyword is it may create preference
               problems.<br>
               Hence if there is no specific requirement it’s not recommended to use synchronized keyword.<br>
               Every object in java has a unique lock. When ever are using synchronized keyword then object level
               lock<br>
               concept will come into picture. If a thread want to execute any synchronized method on the object first
               it<br>
               should require the lock of that object. Once a thread got the lock then it is allowed to execute any<br>
               synchronized method on that object.<br>
               While a thread executing a synchronized method on the object, then the remaining threads are not allowed
               to<br>
               execute any synchronized method on the same object. But the remaining threads are allowed to execute
               any<br>
               non-synchronized method on the same object.
            </p>
            <p >Every object in java has unique lock but a thread can acquire more than one
               lock at a time.</p>
           <textarea rows="55" cols="60" class="textArea" readonly>
         Ex:
         class Display
         {
         public synchronized void wish(String name)
         {
         for(int i =0;i&#60;10;i++)
         {
         System.out.print("Hai.......!");
         try
         {
         Thread.sleep(2000);
         }
         catch (InterruptedException e)
         {
         }
         System.out.println(name);
         }
         }
         }
         class MyThread extends Thread
         {
         Display d;
         String name;
         MyThread(Display d,String name)
         {
         this.d = d;
         this.name = name;
         Property yield() join() sleep()
         Is it overloaded? No Yes Yes
         Is it static? Yes No Yes
         Is it final? No Yes No
         Is it throws
         InterruptedException?
         No Yes Yes
         Is it native? Yes No Sleep(long ms)native
         Sleep(long ms, int ms)not native
         }
         public void run()
         {
         d.wish(name);
         }
         }
         class SynchronizedDemo
         {
         public static void main(String arg[])
         {
         Display d = new Display();
         MyThread t1 = new MyThread(d,"YS");
         MyThread t2 = new MyThread(d,"Babu");
         t1.start();
         t2.start();
         }
         }
         </textarea><br>
           <img src="assets/images/synchronization.PNG"
                  id="synchronization"><br>
            <p >If we are not declaring wish method as “synchronized” we will get irregular
               o/p because both threads will<br>
               execute simultaneously. If we are declaring wish method as synchronized we will get regular o/p because
               at<br>
               a time only one thread is allowed to execute wish method.
            </p>
            <br>
            <p >Display d1 = new Display();<br>
               Display d2 = new Display();<br>
               MyThread t1 = new MyThread(d1,"YS");<br>
               MyThread t2 = new MyThread(d2,"Babu");<br>
               t1.start();<br>
               t2.start();
            </p>
           <img src="assets/images/synchronization1.PNG"
                  id="synchronization1"><br>
            <p >Even though wish method is synchronized we will get irregular o/p only because
               both threads are operating<br>
               on different objects.
            </p>
            <p ><b>Class level lock:</b>&nbsp; If a thread want to execute any static
               synchronized method then compulsory that<br>
               thread should require class level lock. While a thread executing any static system method then the
               remaining<br>
               threads are not allowed to execute any static synchronized method of the same class simultaneously. But
               the<br>
               remaining threads are allowed to execute any non-synchronized static methods, synchronized – instance<br>
               method, non – synchronized instance method simultaneously.
            </p>
            <p >Declare static synchronized in display method and try the above example we
               will get regular p/p because
               there is class level lock.
            </p>
            <p style=" font-size: 20px;"><b>Synchronized Blocks</b></p>
            <p style=" margin-top: -10px;">It is not recommended to declare entire method as
               synchronized if very few lines of code causes the<br>
               problem that code we can declare inside Synchronized Block so that we can improve performance of<br>
               the system.
            </p>
            <p >Syntax:</p>
           <img src="assets/images/synchronizedblock.PNG"
                  id="synchronized"><br>
            <p > Where ‘b’ is an object reference.<br>
               To get the lock for the current object we can define synchronized block as follows
            </p>
         <img src="assets/images/synchronizedblock1.PNG"
                  id="synchronized1"><br>
            <p > We can define synchronized block to get class level as follows<br>
               synchronized(Display.class)<br>
               we can define synchronized block either for object references or for class references But not for<br>
               primitives violation leads to Compile time error.
            </p>
          <img src="assets/images/synchronizedblock2.PNG"
                  id="synchronized2"><br>
            <p > C.E:- unexpected type<br>
               found : int.<br>
               required : reference.
            </p>
            <p ><b>Synchronized statement(Only for Interview Purpose):</b></p>
            <p style=" margin-top: -10px;">The statement which are defined in inside synchronized
               method or synchronized blocks are called<br>
               ‘synchronized statement’.
            </p>
            <p style=" font-size: 20px;"><b>Inter Thread Communication</b></p>
            <p >Two threads can communicate with each other by using wait(), notify(),
               notifyAll().<br>
               These methods are available in object class but not in thread class. Because threads are calling
               these<br>
               methods on any object.
            </p>
            <p >We should call these methods only from synchronized area other wise we get
               runtime exception saying<br>
               IllegalMonitorStateException.
            </p>
            <p >If a thread executes wait() method it immediately releases the lock of that
               object(But not all locks) and<br>
               entered into waiting state.<br>
               After giving the notification also the thread releases the lock but may not be immediately.
            </p>
            <p >public final void wait() throws InterruptedException<br>
               public final void wait(long ms) throws InterruptedException<br>
               public final void wait(long ms, int ns) throws InterruptedException<br>
               public final void notify();<br>
               public final void notifyAll();
            </p>
            <img src="assets/images/interthreadcommunication.PNG"
                  id="threadcommunication"><br>
            <table class="table table-bordered tb1">
               <thead>
                  <tr>
                     <th scope="col">Method</th>
                     <th scope="col">Is lock released</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>yield()</td>
                     <td><i class="fa fa-close" style=" margin-left: 10px;color: red;"></i></td>
                  </tr>
                  <tr>
                     <td>join()</td>
                     <td><i class="fa fa-close" style=" margin-left: 10px;color: red;"></i></td>
                  </tr>
                  <tr>
                     <td>sleep()</td>
                     <td><i class="fa fa-close" style=" margin-left: 10px;color: red;"></i></td>
                  </tr>
                  <tr>
                     <td>wait()</td>
                     <td><i class="fa fa-check" style=" margin-left: 10px;color: blue;"></i></td>
                  </tr>
                  <tr>
                     <td>notify()</td>
                     <td><i class="fa fa-check" style=" margin-left: 10px;color: blue;"></i></td>
                  </tr>
                  <tr>
                     <td>notifyall()</td>
                     <td><i class="fa fa-check" style=" margin-left: 10px;color: blue;"></i></td>
                  </tr>
               </tbody>
            </table>
            <textarea rows="28" cols="60" class="textArea" readonly>
         Ex:
         class ThreadA
         {
         public static void main(String arg[])throws InterruptedException
         {
         ThreadB b = new ThreadB();
         b.start();
         System.out.println("Main Method");
         Thread.sleep(100); -------------------  -->1
         System.out.println(b.total);
         }
         }
         class ThreadB extends Thread
         {
         int total = 0;
         public void run()
         {
         System.out.println("Child Starting calculation");
         for(int i = 1; i&#60;=100; i++)
         {
         if(i == 1)System.out.println("in for loop ");
         total = total + i;
         }
         }
         }
         </textarea><br>
            <p ><b>O/P:-</b></p>
            <img src="assets/images/interthreadcommunication1.PNG"
                  id="threadcommunication1"><br>
            <p >Here we used sleep() method to give chance to child thread. But we can’t say
               child thread will finish his<br>
               work with in given time. So we may get unusually outputs. There is no Guaranteed Output.
            </p>
            <textarea rows="36" cols="60" class="textArea" readonly>
         Ex:
         class ThreadA
         {
         public static void main(String arg[])throws InterruptedException
         {
         ThreadB b = new ThreadB();
         b.start();
         synchronized(b)
         {
         System.out.println("Main Method calling wait method ");
         b.wait();
         System.out.println("Main Got Notification");
         System.out.println(b.total);
         }
         }
         }
         class ThreadB extends Thread
         {
         int total = 0;
         public void run()
         {
         synchronized(this)
         {
         System.out.println("Child Starting calculation");
         for(int i = 1; i&#60;=100; i++)
         {
         total = total + i;
         }
         System.out.println("Child giving notification");
         this.notify();
         }
         }
         }
         </textarea><br>
            <img src="assets/images/interthreadcommunication2.PNG" id="threadcommunication2"><br>
            <p style=" font-size: 22px;"><b>Dead Lock</b></p>
            <p >If two threads are waiting for each other forever, then the threads are said
               to be in “deadlock”.<br>
               There is no deadlock resolution technique but prevention technique are available
            </p>
           <textarea rows="65" cols="60" class="textArea" readonly>
         Ex:
         Banker’s Algorithm.
         Ex:
         class A
         {
         synchronized void foo(B b)
         {
         System.out.println("Threas 1 entered foo() method");
         Using sleep() With out using
         try
         {
         Thread.sleep(600);
         }
         catch (InterruptedException e)
         {
         }
         System.out.println("Thread 1 is trying to call b.last()");
         b.last();
         }
         synchronized void last()
         {
         System.out.println("Inside A, This is last() method");
         }
         }
         class B
         {
         synchronized void bar(A a)
         {
         System.out.println("Threas 2 entered bar() method");
         try
         {
         Thread.sleep(600);
         }
         catch (InterruptedException e)
         {
         }
         System.out.println("Thread 2 is trying to call b.last()");
         a.last();
         }
         synchronized void last()
         {
         System.out.println("Inside B, This is last() method");
         }
         }
         class DeadLock implements Runnable
         {
         A a = new A();
         B b = new B();
         DeadLock()
         {
         Thread t = new Thread(this);
         t.start();
         b.bar(a);
         }
         public void run()
         {
         a.foo(b);
         }
         public static void main(String arg[])
         {
         new DeadLock();
         }
         }
         </textarea> <br>
            <p ><b>O/P:-</b></p>
           <img src="assets/images/deadlock.PNG" id="deadlock"><br>
            <p ><b>DaemonThread</b></p>
            <p >The threads which hare running in the background to provide support for user
               defined threads are called<br>
               “Daemon Thread”. Usually daemon thread are running with low priority but based on our requirement we<br>
               can increase their priority also.
            </p>
            <p >We can check whether the given thread is daemon or not by using the following
               thread class thread.<br>
                public boolean isDaemon()<br>
            </p>
            <p >we can change the daemon nature of a thread by using setDaemon() method of
               thread class.<br>
               void setDaemon(Boolean b)<br>
            </p>
            <p >the daemon nature of a thread is inheriting from the parent. i.e if the parent
               is daemon then the child is also<br>
               daemon and if the parent is non – daemon then the child is also non – daemon.
            </p>
            <p>After starting a thread we are not allowed to change the daemon nature
               violation leads to runtime exception<br>
               saying IllegalThreadStateException.
            </p>
            <textarea rows="20" cols="60" class="textArea" readonly>
         Ex:
         class MyThread extends Thread
         {
         }
         class Test
         {
         public static void main(String arg[])
         {
         System.out.println(Thread.currentThread().isDaemon());
         MyThread t = new MyThread();
         System.out.println(t.isDaemon());
         t.setDaemon(true);
         System.out.println(t.isDaemon());
         t.start();
         //t.setDaemon(false); --> 1
         }
         }
         </textarea><br>
            <p ><b>O/P:-</b></p>
         <img src="assets/images/daemonthread.PNG" id="daemonthread"><br>
            <p >If we don’t comment line 1 we will get the IlleagalThreadStateException, see
               the following o/p.</p>
            <img src="assets/images/daemonthread1.PNG" id="daemonthread1"><br>
            <p >We can’t change the daemon nature of main thread because it has started
               already before main() method only.<br>
               All the daemon threads will be terminated automatically when ever last non – daemon thread terminates.
            </p>
            <textarea rows="30" cols="60" class="textArea" readonly>
         Ex:
         class MyThread extends Thread
         {
         public void run()
         {
         for(int i = 0;i&#60;10;i++)
         {
         System.out.println("Child Thread");
         try
         {
         Thread.sleep(1000);
         }
         catch (InterruptedException e)
         {
         }
         }
         }
         }
         class DaemonThreadDemo
         {
         public static void main(String arg[])
         {
         MyThread t = new MyThread();
         t.setDaemon(true); -->1
         t.start();
         System.out.println("The end of main");
         }
         }
         </textarea><br>
        <img src="assets/images/daemonthread2.PNG" id="daemonthread2"><br>
            <p >If we are commenting line 1, then both child and main threads are non –
               Daemon, hence they will execute<br>
               until their completion.<br>
               If we are not commenting line 1, then the child thread is daemon and hence it will terminate
               automatically<br>
               when ever main() thread terminates.
            </p>
      </div>
      <div class="fundamentalclasses" *ngIf="fundclass">
         <h1 class="mt-4">FUNDAMENTAL CLASSES</h1>
         <h5><b>Introduction</b></h5>
         <p>
            The most commonly used and general purpose classes which are required for any java program are grouped
            into a package which is nothing but a<b>“java.lang.package.”</b>
            All the classes and interfaces which are available in this package are by default available to any java
            program. There is no need to import this class.
         </p>
         <h5><b>Object Class </b></h5>
         <p>
            The most common general methods which can be applicable on any java object are defined in object class.
            Object class is the parent class of any java class, whether it is predefined or programmer defined, hence
            all
            the object class methods are by default available to any java class.
         </p>
         <p>Object class define the following 11 methods</p>
         <ul>
            <li>
               <p style="color:blue"><b><u>clone()</u></b></p>
               <p style="margin-left: 40px; margin-top: -15px;">Creates a new object of the same class as this object.
               </p>
            </li>
            <li>
               <p style="color:blue"><b><u>equals(Object)</u></b></p>
               <p style="margin-left: 40px; margin-top: -15px;">Compares two Objects for equality. </p>
            </li>
            <li>
               <p style="color:blue"><b><u>finalize() </u></b></p>
               <p style="margin-left: 40px; margin-top: -15px;">Called by the garbage collector on an object when
                  garbage
                  collection determines that there
                  are no more references to the object.
               </p>
            </li>
            <li>
               <p style="color:blue"><b><u>getClass() </u></b></p>
               <p style="margin-left: 40px; margin-top: -15px;">Returns the runtime class of an object. </p>
            </li>
            <li>
               <p style="color:blue"><b><u>hashCode() </u></b></p>
               <p style="margin-left: 40px; margin-top: -15px;">Returns a hash code value for the object. </p>
            </li>
            <li>
               <p style="color:blue"><b><u>notify() </u></b></p>
               <p style="margin-left: 40px; margin-top: -15px;">Wakes up a single thread that is waiting on this
                  object's
                  monitor.
               </p>
            </li>
            <li>
               <p style="color:blue"><b><u>notifyAll() </u></b></p>
               <p style="margin-left: 40px; margin-top: -15px;">Wakes up all threads that are waiting on this object's
                  monitor.
               </p>
            </li>
            <li>
               <p style="color:blue"><b><u>toString() </u></b></p>
               <p style="margin-left: 40px; margin-top: -15px;">Returns a string representation of the object. </p>
            </li>
            <li>
               <p style="color:blue"><b><u>wait() </u></b></p>
               <p style="margin-left: 40px; margin-top: -15px;">Waits to be notified by another thread of a change in
                  this
                  object.
               </p>
            </li>
            <li>
               <p style="color:blue"><b><u>wait(long) </u></b></p>
               <p style="margin-left: 40px; margin-top: -15px;">Waits to be notified by another thread of a change in
                  this
                  object.
               </p>
            </li>
            <li>
               <p style="color:blue"><b><u>wait(long, int)
                     </u></b>
               </p>
               <p style="margin-left: 40px; margin-top: -15px;">Waits to be notified by another thread of a change in
                  this
                  object.
               </p>
            </li>
         </ul>
         <p><b>toString()</b></p>
         <textarea rows="35" cols="80" class="textArea" readonly>
   Ex:
      public String toString()
        {
      return getClass.getName() + '@' + Integer.toHexString(HashCode);
        }
       Ex:
          class Student
             {
         
           String name;
           int rollno;
           Student(String name,int rollno)
              {
         
            this.name = name;
            this.rollno = rollno;
         
              }
            public static void main(String arg[])
                                 
              {
            Student s1 = new Student ("raju", 101);
            Student s2 = new Student ("giri", 102);
             System.out.println(s1); ->Student@10b62c9
             System.out.println(s2); ->Student@82ba41
                                    
         
            }
                              
            }
          </textarea>
         <p>To return String representation of an object.</p>
         <p>When ever we are passing object reference as argument to s.o.p() internally JVM will call toString()
            on that object.
         </p>
         <p>If we are not providing toString() then Object class toString() will be executed which is implemented
            as follows
         </p>
         <textarea rows="10" cols="70" class="textArea" readonly>

        public String toString()
           {
        Return getClass.getName() + ‘@’ + Integer.toHexString(hashCode);
           }
         
         </textarea>
         <p>Based on our requirement to provide our own String representation we have to override toString()</p>
         <p>If we are printing Student Object reference to return name & roll no we have to override
            toString() as follows
         </p>
         <textarea rows="11" cols="60" class="textArea" readonly>

           public String toString()
            {
           return name+”--------“+rollno;
            }
            If we can place this toString() in student class then the O/P is
            raju-----101
            giri-----102
            
            </textarea>
         <p>It is highly recommended to override toString() in our classes.</p>
         <p><b>hashCode()</b></p>
         <p>The hashCode of an Object just represents a random number which can be used by JVM while
            saving/adding Objects into Hashsets, Hashtables or Hashmap.
         </p>
         <p>hashCode() of Object class implemented to return hashCode based on address of an object, but based
            on our requirement we can override hashCode() to generate our own numbers as hashCodes
         </p>
         <textarea rows="50" cols="65" class="textArea" readonly>

  Case1:
        class Test
        {
        int i;
        Test(int i)
         {
         this.i = i;
         }
         public int hashCode()
         {
         return i;
         }
         public static void main(String arg[])
         {
         Test t1 = new Test(100);
         Test t2 = new Test(110);
         System.out.println(t1); -> 64
         System.out.println(t2); -> 6e
         }
         }
         Case2:
          class hashCodeDemo
          {
         int i;
         hashCodeDemo(int i)
         {
         this.i = i;
         }
         public int hashCode()
          {
         return i;
         }
         public String toString()
         {
         return i + "";
         }
         public static void main(String arg[])
         {
         hashCodeDemo h1 = new hashCodeDemo(100);
          hashCodeDemo h2 = new hashCodeDemo(110);
          System.out.println(h1); -> 100
          System.out.println(h2); -> 110
           }
           }
               
           </textarea>
         <p><b>equals()</b></p>
         <textarea rows="25" cols="60" class="textArea" readonly>

                                 Ex:
                                 class Student
                                 {
                                 String name;
                                 int rollno;
                                 Student(String name,int rollno)
                                 {
                                 this.name = name;
                                 this.rollno = rollno;
                                 }
                                 public static void main(String arg[])
                                 {
                                 Student s1 = new Student ("raju", 101);
                                 Student s2 = new Student ("giri", 102);
                                 Student s3 = new Student ("giri", 102);
                                 System.out.println(s1.equals(s2)); -> false
                                 System.out.println(s2.equals(s3)); ->false
                                 }
                                 }
                                 r1 == r2 -> reference Comparision.
                                 r1.equals(r2) -> reference.
               
                              </textarea>
         <p>Note: In this case Object class .equals() has executed which is meant for reference comparison but
            based on our requirement it is recommended to override .equals() for content comparison.
            By over loading .equals() we have to consider the following 3 cases
         </p>
         <p style="margin-top:-10px;">Case1: The meaning of equality</p>
         <p>Case2: In the case of heterogeneous objects we have to return false. (i.e) we have to handle
            ClassCastException to return false
         </p>
         <p>Case3: If we are passing null as the argument we have return false. (i.e) we have to handle
            NullPointerException to return false
         </p>
         <p><b>Overridden methods of equals</b></p>
         <textarea rows="55" cols="70" class="textArea" readonly>

  Ex:
     class Student
         {
   String name;
   int rollno;
   Student(String name,int rollno)
   {
   this.name = name;
   this.rollno = rollno;
   }
   public boolean equals(Object obj)
   {
   try
   {
   String name1 = this.name;
   int rollno1 = this.rollno;
   Student s2 = (Student)obj;
   String name2 = s2.name;
   int rollno2 = s2.rollno;
   if(name1.equals(name2) && rollno1 == rollno2)
   {
   return true;
   }
   else
   {
   return false;
   }
   }
   catch (ClassCastException c)
   {
   return false;
   }
   catch (NullPointerException e)
   {
   return false;
   }
   }
   public static void main(String arg[])
   {
   Student s1 = new Student ("raju", 101);
   Student s2 = new Student ("giri", 102);
   Student s3 = new Student ("giri", 102);
   System.out.println(s1.equals(s2)); -> false
   System.out.println(s2.equals(s3)); -> true
   System.out.println(s1.equals(null)); -> false
   }
   }
   
   
   </textarea>
         <p style="margin-left: 100px;">Comparison between ‘==’ operator and ‘.equals()’</p>
         <span style="margin-left: 100px;"><img src="assets/images/tab1.PNG"></span>
         <p><b>Relationship between ‘==’ and .equals()</b></p>
         <p>If r1 == r2 is true then r1.equals(r2) is always true.
            If r1.equals(r2) is true, then r1 == r2 need not to be true.
         </p>
         <p><b>Contract Between .equals() and hashCode() </b></p>
         <ol>
            <li>If two objects are equal by .equals() then their hashcodes must be equal.</li>
            <p>Ex:</p>
            <p style="margin-top: -30px; margin-left: 40px;">If r1.equals(r2) is true then<br>
               r1.hashCode() == r2.hashCode is also true
            </p>
            <li>If two Objects are not equal by .equals() then their hashCode may or may not be same</li>
            <li> If the hashCodes of two Objects are equal then the objects may or may not be equal by .equals()
            </li>
            <li>If the hashCodes of two Objects are not equal then the Objects are always not equal by .equals().</li>
         </ol>
         <p>To satisfy above contract when ever we are overriding .equals it is highly recommended to override
            hashCode() also.
         </p>
         <p><b>clone()</b></p>
         <p>The process of creating exactly duplicate Object is called Clonning.
            Object class contains the clone method to perform this.<br>protected native Object clone() throws
            CloneNotSupportedException
         </p>
         <textarea rows="25" cols="80" class="textArea" readonly>
     Ex:
      class Test implements Cloneable
      {
      int i = 10;
      int j = 20;
      public static void main(String arg[])throws CloneNotSupportedException
      {
      Test t1 = new Test();
      Test t2 = (Test)t1.clone();
      t1.i = 100;
      t1.j = 200;
      System.out.println(t2.i+"----"+t2.j); ->10----20
      }
      }
      r1.equals(r2) -> reference.
      
      </textarea>
         <p>All the Objects can’t have the capability to produce cloned Objects. Only clonaeble objects having
            that capability.
         </p>
         <p>An Object is said to be cloneable iff the corresponding class has to implement java.lang.cloneable
            interface.
         </p>
         <p>It doesn’t contain any methods it is a marker interface.</p>
         <p>Protected members can be accessible from outside package in the child classes but we should invoke
            them by using child class reference only. That is parent class reference is not allowed to invoke
            protected members from outside package.
         </p>
         <span style="margin-left: 100px;"><img src="assets/images/tab2.PNG"></span><br>
         <span style="margin-left: 100px;"><img src="assets/images/tab3.PNG"></span>
         <p>It is highly recommended to override clone() in our class like doGet(), doPost() methods.</p>
         <p><b>Strings Class</b></p>
         <p>Once we created String objects we are not allowed to perform any changes in the existing object. If u r
            trying to perform any changes with those changes a new String object will be created this behavior is
            nothing but ‘immutability’ Of the String Objects.
         </p>
         <span style="margin-left: 100px;"><img src="assets/images/dia.PNG"></span>
         <p>Once we created a StringBuffer object we are allowed perform any changes in the existing object only. This
            behavior is nothing but ‘mutability’ of the StringBuffer object.
         </p>
         <span style="margin-left: 100px;"><img src="assets/images/dia2.PNG"></span>
         <p>Ex:</p>
         <p style="margin-left: 50px;">String s1 = new String("lesto");<br>
            String s2 = new String("lesto");<br>
            System.out.println(s1 == s2); -> false<br>
            System.out.println(s1.equals(s2)); -> true
         </p>
         <p>In String class .equals method is overridden for content comparision. </p>
         <p style="margin-left: 50px;">StringBuffer sb1 = new StringBuffer("lesto");<br>
            StringBuffer sb2 = new StringBuffer("lesto");<br>
            System.out.println(sb1 == sb2) ->false<br>
            System.out.println(sb1.equals(sb2));-> false
         </p>
         <p>In the StringBuffer .equals method is not overridden for content comparison.<br>
            Hence Object class .equals method will be executed which is meant for reference comparison.
         </p>
         <p><b>Difference Between (String s = new String(“raju”)) and (String s = “raju”)?</b></p>
         <p><b>String s = new String(“raju”):-</b></p>
         <p>In this case 2 objects will be created one is on the heap and the second one is on the scp(String
            constant pool) and ‘s’ is referring to heap object.
         </p>
         <span style="margin-left: 100px;"><img src="assets/images/dia3.PNG"></span>
         <p>-> Object Creation in SCP is Optional.</p>
         <p>-> If the object is not available then only a new object will be created.</p>
         <p><b>String s = “raju”:-</b></p>
         <p>In this case only one object will be created if it is not already available and ‘s’ is referring to that
            object. If an object is already available with this can in scp then ‘s’ will refer that existing object only
            instead of creating new object.
         </p>
         <span style="margin-left: 100px;"><img src="assets/images/dia4.PNG"></span>
         <p> <b>Note:-</b>The Object present in the scp is not eligible for garbage collection even though the object
            doesn’t
            have any reference variables.<br>
            All the scp objects will be destroyed at the time of JVM shutdown.
         </p>
         <textarea rows="11" cols="40" class="textArea" readonly>
         Ex:
         String s1 = new String("maha");
         String s2 = new String("maha");
         String s3 = "maha";
         String s4 = "maha";
         </textarea>
         <br>
         <span style="margin-left: 100px;"><img src="assets/images/dia5.PNG"></span>
         <p><b>Note:-</b> In the scp there is no chance of 2 string objects with the same content i.e duplicate string
            objects
            won’t present in scp.
         </p>
         <p>But in the case of heap there may be a chance of duplicate stringObjects</p>
         <textarea rows="11" cols="60" class="textArea" readonly>

         Ex:
         String s1 = new String("maha");
         String s2 = new String("maha");
         String s3 = "maha";
         String s4 = "maha";
         
         O/P:- Sai
         SaiKiran
         
         </textarea>
         <br>
         <span style="margin-left: 100px;"><img src="assets/images/dia6.PNG"></span>
         <p>String s1 = "spring";<br>
            String s2 = s1+"summer";<br>
            s1.concat("fall");<br>
            s2.concat(s1);<br>
            s1=s1+"winter";<br>
            System.out.println(s1)
         </p>
         <p><b>O/P:-</b> springwinter
            springsummer
         </p>
         <span style="margin-left: 100px;"><img src="assets/images/dia7.PNG"></span><br>
         <textarea rows="31" cols="70" class="textArea" readonly>
         Ex:
         class StringTest
         {
         public static void main(String[] args)
         {
         String s1 = new String("You cannot change me");
         String s2 = new String("You cannot change me");
         System.out.println(s1==s2);
         String s3 = "You cannot change me";
         System.out.println(s1==s3);
         String s4 = "You cannot change me";
         System.out.println(s3==s4);
         String s5 = "You cannot"+" change me";
         System.out.println(s4==s5);
         String s6 = "You cannot";
         String s7 = s6 + " change me";
         System.out.println(s4==s7);
         final String s8 = "You cannot";
         String s9 = s8 + " change me";
         System.out.println(s4==s9);
         }
         }
         
         
         </textarea>
         <br>
         <span style="margin-left: 100px;"><img src="assets/images/dia8.PNG"></span>
         <p><b>Importance of String Constant Pool(SCP)</b></p>
         <p>In our program if any string object is repeatedly going to use, we can create only one object in the
            string constant pool and shared by several required references.
         </p>
         <p>Instead of creating several string objects with the same content creating only one object improves
            performance of the system and memory utilization also. This is biggest advantage of SCP.
         </p>
         <p>As the Several references pointing to the same object in SCP by using one reference if u r allowed to
            change the content the remaining references may be effected. Hence once we created a String object.
            We r not allowed to change it’s content. If u r trying to change with those changes a new object will
            be created and there is no impact on the remaining references. This behavior is nothing but
            immutability of the string objects.
         </p>
         <p>SCP is the only reason why the String Objects are immutable.</p>
         <p><b>Interview point of questions:
            </b>
         </p>
         <ol>
            <li>What is the difference Between String and StringBuffer?</li>
            <li> What is the meaning of immutability?
            </li>
            <li> Why the String Objects are declared as immutable?
            </li>
         </ol>
         <p><b>Interning of String Objects
            </b>
         </p>
         <textarea rows="15" cols="60" class="textArea" readonly>

            Ex:
            class StringTest
            {
            public static void main(String[] args)
            {
            String s1 = new String("raju");
            String s2 = s1.intern();
            String s3 = "raju";
            System.out.println(s2 == s3);
            }
            }
            
            </textarea>
         <br>
         <span style="margin-left: 100px;"><img src="assets/images/dia9.PNG"></span>
         <p>At any point of time if we have heap object reference we can find it’s equivalent SCP Object by
            using intern() method.
         </p>
         <p>If the equivalent SCP Object is not already available then intern() method will create a new object in
            the SCP.
         </p>
         <br>
         <textarea rows="17" cols="70" class="textArea" readonly>


         Ex:
         class StringTest
         {
         public static void main(String[] args)
         {
         String s1 = new String("raju");
         String s2 = s1.concat("lesto");
         String s3 = s2.intern();
         String s4 = “rajulesto”;
         System.out.println(s3 == s4);
         }
         }
         
         </textarea>
         <br>
         <span style="margin-left: 100px;"><img src="assets/images/dia10.PNG"></span>
         <p><b>String Class Constructor
            </b>
         </p>
         <span style="margin-left: 100px;"><img src="assets/images/dia11.PNG"></span><br>
         <span style="margin-left: 100px;"><img src="assets/images/dia12.PNG"></span><br>
         <span style="margin-left: 100px;"><img src="assets/images/pa1.PNG"></span><br>
         <span style="margin-left: 100px;"><img src="assets/images/pa2.PNG"></span><br>
         <span style="margin-left: 100px;"><img src="assets/images/pa3.PNG"></span>
         <p><b>Constructors of StringBuffer:</b></p>
         <p>StringBuffer sb = new StringBuffer();</p>
         <p>Creates an empty StringBuffer object with default initial capacity 16.
            If it reaches max capacity then a new StringBuffer object will be created with new capacity is
         </p>
         <span style="margin-left: 100px;"><img src="assets/images/img1.PNG"></span><br>
         <p> Ex:-<br>
            StringBuffer sb = new StringBuffer();<br>
            System.out.println(sb.capacity());<br>
            sb.append("abcdefghijklmnop");<br>
            sb.append("q");<br>
            System.out.println(sb.capacity()); -> 34
         </p>
         <textarea rows="11" cols="60" class="textArea" readonly>
            Ex:-
            StringBuffer sb = new StringBuffer(40);
            System.out.println(sb.capacity());
            sb.append("abcdefghijklmnop");
            .
            .
            .
            </textarea>
         <p>Creates an empty StringBuffer with the required initial capacity.</p>
         <p>StringBuffer sb = new StringBuffer(String s);<br>
            Creates an equivalent StringBuffer object for the given string with
         </p>
         <br>
         <span style="margin-left: 100px;"><img src="assets/images/pic2.PNG"></span>
         <p>Ex:-<br>
            StringBuffer sb = new StringBuffer(“Lesto”);<br>
            System.out.println(sb.capacity()); -> 16 + 5 = 21
         </p>
         <p><b>-> Q) Which of the following is a valid constructor for the StringBuffer but not for the String.</b></p>
         <ol>
            <li>( )</li>
            <li><b>(int capacity)</b></li>
            <li><b>(String s)</b></li>
         </ol>
         <p><b>Important Methods of StringBuffer class</b></p>
         <ol>
            <li>public int length();</li>
            <li>public int capacity();</li>
            <li>public char charAt(int index);</li>
         
         <p> Ex:-<br>
            StringBuffer sb = new StringBuffer(“Lesto”);<br>
            System.out.println(sb.charAt(3));<br>
            System.out.println(sb.chatAt(10)); ->StringIndexOutOfBoundsException.
         </p>
<li>public void set chatAt(int index, char ch);<br>Replaces the character present at specified index with the provided char.<br>
<textarea rows="9" cols="50" class="textArea" readonly>
Ex:-
   StringBuffer sb = new StringBuffer(“”);
   sb.setCharAt(3,’a’);
   System.out.println(sb);
 </textarea>
</li>
<li>public StringBuffer append(String s)<br>Allows all overloaded methods….int, float, byte, boolean, char[], byte[],….etc</li>
<li>public StringBuffer insert(int index, String s)</li>
<textarea rows="9" cols="50" class="textArea" readonly>
Ex:-
   StringBuffer sb = new StringBuffer(“Lesto”);
   sb.insert(2,”raju”);
   System.out.println(sb); StringBuffer sb = new StringBuffer(String s);
    </textarea>
    <li>public StringBuffer delete(int start, int end)<br>
      delete characters from start to (end-1)<br>
      StringBuffer sb = new StringBuffer(“abcdefgh”)<br>
      sb.delete(2,6); O/P:-abgh
      </li>
      <li>public StringBuffer delete charAt(int index)<br>
         deleting Character located at specified index.</li>
<li>public StringBuffer reverse();<br>
   <textarea rows="5" cols="50" class="textArea" readonly>
 Ex:-
    StringBuffer sb = new StringBuffer(“raju”);
    Syetem.out.println(sb.reverse()); O/P:-ujar.
               
  </textarea>

</li>
<li>public void setLength(int requiredlength);</li>
<textarea rows="7" cols="50" class="textArea" readonly>
   Ex:-
      StringBuffer sb = new StringBuffer(“ aishwaryaabhishak”);
      sb.setLength(8);
      System.out.println(sb) O/P:-aishwarya
</textarea>
</ol>
<p><b>Note:-</b>All the methods which are available in the StringBuffer are Sunchronized or it may effect the
   performance of the system.<br>We can overcome this problem by using StringBuilder.</p>
   <p><b>StringBuilder</b></p>
   <p>StringBuilder class exactly similar to StringBuffer (including constructors and methods) Except the
      following.
      </p>
      <span style="margin-left: 100px;"><img src="assets/images/tab5.PNG"></span>
      <p>If the content is not changing frequently then we should go for the <b>string.</b></p>
      <p>If the content will change frequently and thread safety is required then we should go for <b> StringBuffer</b></p>
      <p>If the content is changing frequently and thread safety is not required then we should go for <b>StringBuilder.</b></p>
      <p><b>Chaining of Methods</b></p>
      <p>For most of the methods in String and StringBuffer the returntypes are the same String and StringBuffer
         objects only.
         </p>
         <p>After Applying a method we are allowed to call another method on the result which forms a method change.<br>
            sb.m1().m2().m3().m4().m5()…..;</p>
            <p>All these method calls will execute from left to right.<br>
               StringBuffer sb = new StringBuffer(“raju”);<br>
               sb.append("software").reverse().insert(2,"abc").delete(2,5).append("xyz");</p>
               <p><b>Wrapper Classes</b></p><br>
               <p>The main objectives of wrapper classes are: </p>
<ol>
<li>To Wrap primitives into object form. So that we can handle primitives also just like objects.</li>
<li>To Define several utility functions for the primitives(like converting primitive to the string form etc.)
</li>
</ol>
<p><b>Constructors:</b></p>
<p>valueOf()<br>
   xxxValue()<br>
   parseXxx()<br> 
   toString()</p>
   <p><b>Constructing Wrapper objects by using constructors</b></p>
   <p>Every Wrapper class contains 2 constructors one can take the corresponding primitive as the
      argument and the other can take the corresponding string as the argument.</p>
      <textarea rows="7" cols="50" class="textArea" readonly>
         Ex:
            Integer I = new Integer(10);
            Integer I = new Integer(“10”);
      </textarea> 
      <p>If the String is unable to convert into the number form then we will get runtime exception saying
         “NumberformatException”.</p> 
         <textarea rows="3" cols="50" class="textArea" readonly>
            Ex: Integer I = new Integer(“ten”);
         </textarea>
<p><b>Float</b> class contains 2 constructors which can take double String as argument.
</p>
<p style="margin-left: 50px;">Float f = new Float(10.5f);<br>
   Float f = new Float(“10.5f”);<br>
   Float f = new Float(10.5);<br>
   Float f = new Float(10.5);</p>
   <p><b>Character</b> class contain only one constructor which can take char as the argument i.e character class
      doesn’t contain a constructor which can take string as the argument. </p>
      <textarea rows="6" cols="60" class="textArea" readonly>
   Ex:
         Character ch1 = new Character('a'); ->valid.
         Character ch1 = new Character("a"); -> not valid.
</textarea>
<p>Boolean class contains 2 constructors one can take boolean primitive. Other can take string
   argument. If u r providing boolean primitive as the argument the. The allowed values are true or
   false.<br>
   Case is not important if the content contains ‘TRUE’ then it is considered as true other wise it
   considered as false.</p>
   <p style="margin-left: 50px;"> &#81;&#41;<b>Which of the following are valid ? </b> </p>
   <p style="margin-left: 100px;">Boolean b = new Boolean(true); <i  class="fa fa-check" style="color: black; margin-left: 10px;"></i> O/P:-true</p><br>
   <p style="margin-left: 100px;">Boolean b = new Boolean(FALSE); <i  class="fa fa-close" style="color: black; margin-left: 10px;"></i></p> <br>
   <p style="margin-left: 100px;">Boolean b = new Boolean(“false”); <i  class="fa fa-check" style="color: black; margin-left: 10px;"></i> O/P:-false</p><br>
   <p style="margin-left: 100px;">Boolean b = new Boolean(“TrUE”); <i  class="fa fa-check" style="color: black; margin-left: 10px;"></i>  O/P:-true</p><br>
   <p style="margin-left: 100px;">Boolean b = new Boolean(“raju”);  <i  class="fa fa-check" style="color: black; margin-left: 10px;"></i>O/P:-false</p><br>
   <p style="margin-left: 100px;">Boolean b = new Boolean(“yes”); <i  class="fa fa-check" style="color: black; margin-left: 10px;"></i> O/P:-false</p ><br>
 <p style="margin-left: 50px;"> &#81;&#41;<b>Which of the following are valid ? </b> </p>
 <p>Boolean b1 = new Boolean(“yes”);<br>
   Boolean b2 = new Boolean(“No”);</p>
   <p>System.out.println(b1.equals(b2));  </p> 
   <ol>
<li>C.E</li>
<li>R.E</li>
<li>true</li>

<li>false</li>
 </ol>
 <p>Ans: 3 (true)</p>
 <span style="margin-left: 100px;"><img src="assets/images/tab7.PNG"></span>
 <p><b>valueOf( ) methods</b></p>
 <p><b>version1:</b></p>
 <p>All the wrapper classes<b>except character</b>  class contains the valueOf() method for converting
   <b>string</b> to corresponding Wrapper Object.<br>
   public static wrapper valueOf(String s);
   </p>
   <p>
Ex:
Integer I = Integer.valueOf(‘10’); <i  class="fa fa-check" style="color: black; margin-left: 10px;"></i><br>
Float F = Float.valueOf(“10.5”); <i  class="fa fa-check" style="color: black; margin-left: 10px;"></i><br>
Boolean B = Boolean.valueOf(“raju”); <i  class="fa fa-check" style="color: black; margin-left: 10px;"></i><br>
Character ch = Character.valueOf(“10”); X -> C.E</p>
<p><b>Version2:</b></p>
<p>All Integral wrapper classes “Byte, Short, Long, Integer” Contains the following valueOf()
   method</p>
   <p>public static wrapper valueOf(String s, int radix); </p>
<p>The allowed base of radix is 1 to 36.Because Numerics(10) ,Alphabets(26) finally 10+26 =36 </p>
<p>Ex:<br>
       Integer I = Integer.valueOf(“101011”, 2); <i  class="fa fa-check" style="color: black; margin-left: 10px;"></i><br>
       System.out.println(I); O/P:- 43
   </p>
   <p><b>Version3: </b></p>
   <p>Every Wrapper class including character class contains the following valueOf() method to
      convert <b>primitive</b> to wrapper object form.</p>
      <p>public static wrapper valueOf(primitive p);
      </p>
      <p>
 Ex:<br>
 Integer I = Integer.valueOf(10); <i  class="fa fa-check" style="color: black; margin-left: 10px;"></i>  <br>
 Character ch = Character.valueOf(‘a’); <i  class="fa fa-check" style="color: black; margin-left: 10px;"></i><br>
 Boolean B = Boolean.valueOf(true); <i  class="fa fa-check" style="color: black; margin-left: 10px;"></i><br>
 </p>
 <p> Version1, Version2 -> String to wrapper object.</p>
 <p>Version3 -> primitive to wrapper object.</p>
 <span style="margin-left: 100px;"><img src="assets/images/dia13.PNG"></span>
 <p><b>xxxValue() method</b></p>
 <p>Every wrapper class Except character and Boolean classes contains the following xxxValue() methds
   for converting wrapperObject to primitive.</p>
   <p>public int intValue();<br>
      public byte byteValue();<br>
      public short shortValue();<br>
      public long longValue();<br>
      public float floatValue();<br>
      public int doubleValue();</p>
<textarea rows="11" cols="60" class="textArea" readonly>
 Ex:
   Integer I = Integer.valueOf(130);
   System.out.println(I.byteValue());
   System.out.println(I.shortValue()); -> -126
   System.out.println(I.intValue()); -> 130
   System.out.println(I.langValue()); -> 130
   System.out.println(I.floatValue()); -> 130.0
   System.out.println(I.doubleValue()); -> 130.0
      </textarea>
      <p><b>Character</b> class contain <b>charValue()</b> method to return char primitive for the given character
         wrapper object.
         </p>
         <p>public char charValue();</p>
         <textarea rows="6" cols="60" class="textArea" readonly>
       Ex:
            character ch = new character(‘a’);
            char ch = ch.charValue();
            System.out.println(ch1);   O/P:- a

         </textarea>
         <p><b>Boolean</b> class contains booleanValue() method to return boolean primitive for the given boolean
            objective.</p>
            <p>
   Boolean B = Boolean.valueOf("Tea Break");<br>
   boolean b1 = B.booleanValue();<br>
  System.out.println(b1); O/P:-false</p>
 <p><b>Note:-</b> In total 38 xxxValue methods are possible ((6 X 6) +1 + 1) = 38</p>
 <span style="margin-left: 100px;"><img src="assets/images/round1.PNG"></span>
 <p><b>parseXxx() methods</b></p>
 <p><b><u>Version1:</u></b></p>
 <p>Every wrapper class except character class contains the following parseXxx() method for
   converting String to primitive type
   </p>
   <p>public static primitive parseXxx(String s);
   </p>
   <textarea rows="6" cols="50" class="textArea" readonly>
   Ex:
      int i= Integer.valueOf(“10”);
      Boolean b = Boolean.parseBoolean(“true”);
   </textarea>
   <p><b><u>Version2:</u></b></p>
   <p>Integral wrapper classes(Byte, Short, Integer and long ) contains the following parseXxx()
      method.</p>
      <p>public static primitive parseXxx(String s, int radix );<br>
         int i = Integer.parseInt(“101011”, 2);<br>
         System.out.println(i); O/P:-43
         </p>
         <span style="margin-left: 100px;"><img src="assets/images/round2.PNG"></span>
         <p><b>toSting()methods</b></p>
         <p><b><u>version1:
         </u></b></p>
         <p>All wrapper Classes contains an instance method toString() for converting wrapper object to
            String type. This is overriding method of object class toString() method.</p>
            <p><b>public String toString();</b></p>
   <p>Integer I = new Integer(10);<br>
 String s = I.toString();<br>
 System.out.println(s); O/P:-10</p>
<p>Boolean B = new Boolean(“raju”);<br>
 String s = B.toString();<br>
 System.out.println(s); O/P:-false</p>
 <span style="margin-left: 100px;"><img src="assets/images/round3.PNG"></span>
 <p><b><u>Version2:</u></b></p>
 <p>Every wrapper class contains the following static toString() for converting primitive to String
   representation..
   </p>
   <p><b>public static String toString(primitive p);</b></p>
   <p>String s = Integer.toString(10);<br>
      System.out.println(s); O/P:-10</p>
      <p>String s = Boolean.toString(true);<br>
         System.out.println(s); O/P:-true</p>
  <p><b><u>Version3:</u></b></p>
  <p>Integer and long classes contains the following toString() to return the String in the specified
  radix. </p>
 <p><b>public static String toString(int/long, int radix );</b></p>
 <p>String s = Integer.toString(43, 2);<br>
   System.out.println(s); O/P:-“101011”</p>
   <p>String s = Integer.toString(43, 8);<br>
      System.out.println(s); O/P:-“53”
      </p>
      <p><b><u>Version4:</u></b></p>
      <p>Integer and Long classes contains the following methods to return specified radix String
         form. </p>
         <p><b>public static String toBinaryString(int/long, l);<br>
            public static String toOctalString(int/long, l);<br>
            public static String toHexString(int/long, l);</b></p>
<p>String s = Integer.toBinaryString(43);<br>
   System.out.println(s);<b> O/P:-“101011”</b></p>
   <p>String s = Integer.toOctalString(43);<br>
      System.out.println(s); <b>O/P:-“53”</b></p>
      <p>String s = Integer.toHexString(43);
         System.out.println(s); <b>O/P:-“262”</b> </p>
<h3>Diagrammatic form of wrapper classes</h3>
<span style="margin-left: 100px;"><img src="assets/images/round4.PNG"></span>
<span style="margin-left: 100px;"><img src="assets/images/round6.PNG"></span>
<ul>
<li>Void is also considered as wrapper class.</li>
<li>String, StingBuffer, StringBuilder and all wrapper class are final.</li>
<li>In Addition to String Object all wrapper class objects also immutable.</li>
<li>Boolean and Character wrapper classes are not child classes or Number class</li>
</ul>
     
		 
		 
		 
      </div>
      <div class="ioserialization" *ngIf="ioseriz">
         <h1 class="mt-4">FILE I/O & SERIALIZATION</h1>
		 <p style=" font-size: 20px;"><b>File I/O Introduction</b></p>
<p  >The following is the list methods going to cover in File I/O Concept.</p>
<ol >
   <li>File</li>
   <li>FileWriter</li>
   <li>FileReader</li>
   <li>BufferedWriter</li>
   <li>BufferedReader</li>
   <li>PrintWriter</li>
 </ol> 
<p style=" font-size: 20px;"><b>File</b></p>
<p style=" margin-top: -10px;">A java file object represent just name of the file/directory.</p>
<p >File f = new File(“abc.txt”);</p>
<p >If ‘abc.txt’ is already available then ‘f’ will represent that physical file.<br>
   If it is not already available, It won’t create any new file and ‘f’ simply represents the name of the file.</p>
 <textarea rows="13" cols="60" class="textArea" readonly>
Ex:
   import java.io.*;
   class test
   {
   public static void main(String[] args)
   {
   File f = new File("cba.txt");
   System.out.println(f.exists()); --> false at first time.
   f.createNewFile();
   System.out.println(f.exists()); --> true
   }
   }
 </textarea> 
 <p ><u>I Run:</u></p>
  <p style=" margin-top: -10px;"> false<br>
   true</p>
  <p ><u>II Run:</u> </p>
   <p style="margin-top: -10px;">true<br>
   true</p>
<p >A java file Object can represent directories also</p>
<textarea rows="6" cols="60" class="textArea" readonly>
Ex:
   File f = new File("bbc");
   System.out.println(f.exists());
   f.mkdir();
   System.out.println(f.exists());
</textarea>
<p ><u>I Run:</u></p>
  <p style=" margin-top: -10px;"> false<br>
   true</p>
  <p ><u>II Run:</u> </p>
   <p style=" margin-top: -10px;">true<br>
   true</p>
<p ><b>The constructors of the file class</b></p>
<ol>
<li>File f = new File(String name)</li>
<p >Here name may be file or directory name.</p>
<p >Creates a java file object that represents a file or directory name.</p>
<li >File f = new File(String subdirec, String name)</li>
<p >Creates a java file object that represents file or directory name present in specified
   subdirectory.</p>
<li >File f = new File(File subdir, String name)</li>
   </ol>
   <p style=" font-size: 18px;"><b>Important methods of File Class</b></p>
<ol>
   <li ><u>boolean exists():</u></li>
   <p >returns true if the physical file/directory presents other wise false.</p>
<li ><u>boolean createNewFile():</u></li>
<p>returns ture if it creates a new file, if the required file is already available then<br>
   it won’t create any new file and returns false.</p>
<li ><u>booelan mkdir():</u></li>
<p >For creation of directory.</p>
<li ><u>boolean isFile():</u></li>
<p >returns true if the java file object represents a file.</p>
<li><u>boolean isDirectory():</u></li>
<p >returns true if the java file object represents a directory.</p>
<li ><u>String [] list():</u></li>
<p  >returns the names of files and directories present in the directories represented
   by the file object.<br>
   If the java file object represents a file instead of directory this method returns<br>
   null.</p>
   <li  ><u>Boolean delete():</u></li>
   <p >for deleting the file or directory represented by java file object.</p>
</ol>
<p ><b>write a program to create a file named with ‘xyz.txt’ in the current working directory.</b></p>
<p >File f = new File(“xyz.txt”);<br>
   f.createNewFile();</p>
<p  ><b>Write a program to create a directory ‘raju123’ in the current working directory and create a<br>
   file ‘file1.txt’ in that directory.</b></p>
   <p  >File f = new File(“raju123”);<br>
      f.mkdir();<br>
      // File f1 = new File(“raju123”,”file1.txt”);<br>
      File f1 = new File(f,”file1.txt”);<br>
      F1.createNewFile();</p>
      <p ><b>Write a program to list the names of files and directories in ‘jdk’ directory.</b></p>
      <p >File f = new File(“jdk”);<br>
         String [] s = f.list();<br>
         For(String s1: s)<br>
         &#123;<br>
            System.out.println(s1);<br>
            }</p>
<p style=" font-size: 20px;" ><b>FileWriter</b></p>
<p >This class can be used for writing character data to the file.</p>
<p ><b>Constructors</b></p>
<ol>
<li >FileWriter fw = new FileWriter(String fname)</li>
<li >FileWriter fw = new FileWriter(File f);</li>
   
</ol>
<p >The above 2 constructors creates a file object to write character data to the file.<br>
   If the file already contains some data it will overwrite with the new data.<br>
   Instead of overriding if u have to perform append then we have to use the following constructors</p>
<p >FileWriter fw = new FileWriter(String name, boolean append);<br>
   FileWriter fw = new FileWriter(File f, boolean append);</p>
<p >If the underlying physical file is not already available then the above constructors will create the<br>
   required file also.</p>
<p ><b>Important methods of FileWriter Class</b></p>
<ol>
   <li>void write(int ch) throws IOException</li>
      for writing single character to the file.
     <li>  void write(String s)throws IOException.</li>
     <li> void write(char [] ch) throws IOException.</li>
      <li> void flush():-To guaranteed that the last character of the data should be required to the file.</li>
</ol>
<textarea rows="18" cols="60" class="textArea" readonly>
Ex:-
      class test
      {
      public static void main(String arg[])throws Exception
      {
      File f = new File("pongal.txt");
      System.out.println(f.exists());
      FileWriter fw = new FileWriter(f,true);
      System.out.println(f.exists());
      fw.write(97);
      fw.write("run\nsoftware\n");
      char [] ch1 = {'a','b','c'};
      fw.write(ch1);
      fw.flush();
      fw.close();
      }
      }
</textarea>

<p style=" font-size: 20px;"><b>FileReader</b></p>
<p >This class can be used for reading character data from the file.</p>
<p ><b>Constructors</b></p>
<ol >
   <li>FileReader fr = new FileReader(String name);</li>
   <li>FileReader fr = new FileReader(File f);</li>
</ol>
<p ><b>Important methods of FileReader Class</b></p>
<ol >
   <li>int read():</li>
   <p >for reading next character from the file. If there is no next character this method
      returns -1</p>
      <li>int read(char[] ch):</li>
      <p >to read data from the file into char array.</p>
      <li>void close():</li>
      <p >to close FileReader</p>
</ol>
<textarea rows="18" cols="60" class="textArea" readonly>
Ex:
      class test
      {
      public static void main(String arg[])throws Exception
      {
      File f = new File("pongal.txt");
      FileReader fr = new FileReader(f);
      System.out.println(fr.read());
      char [] ch2 = new char[(int) (f.length())];
      System.out.println(ch2.length);
      fr.read(ch2);
      for(char ch1: ch2)
      {
      System.out.print(ch1);
      }
      }
      }
</textarea>
<p >The usage of FileReader and FileWriter is in efficient because</p>
<p ><i class="fa fa-circle" aria-hidden="true" style="font-size: smaller;"></i> While writing the data by using FileWriter, program is responsible to insert line separators manually.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: smaller;"></i> We can read the data character by character only by using FileReader. If increases the number of I/O<br>
   operations and effect performance.</p>
<p >To overcome these problems sun people has introduced <b>BufferedReader</b> and <b>BufferedWriter</b> classes.</p>
<p style=" font-size: 20px;"><b>BufferedWriter</b></p>
<p >This can be used for writing character data to the file.</p>
<p ><b>Constructors</b></p>
<ol >
   <li>BufferedWriter bw = new BufferedWriter(writer w)</li>
   <li>BufferedWriter bw = new BufferedWriter(writer r, int size)<br>
      BufferedWriter never communicates directly with the file. It should Communicate through<br>
      some writer object only.</li>
   </ol>
   <p><b>&#81;&#41;Which of the following are valid declarations</b></p>
   <ol >
   <li>BufferedWriter bw = new BufferedWriter(“abc.txt”);<i class="fa fa-close" style=" margin-left: 10px; color: red;"></i></li>
   <li>BufferedWriter bw = new BufferedWriter(new File(“abc.txt”)); <i class="fa fa-close" style="margin-left: 10px;color: red;"></i></li>
   <li>BufferedWriter bw = new BufferedWriter(new FileWriter(“abc.txt”)); <i class="fa fa-check" style=" margin-left: 10px;color: blue;"></i></li>
   <li>BufferedWriter bw = new BufferedWriter(new BufferedWriter(new FileWriter(“abc.txt”))); <i class="fa fa-check" style=" margin-left: 10px;color: blue;"></i></li>
 
   </ol>
<p ><b>Important methods of BufferedWriter Class</b></p>
<ol >
   <li>void write(int ch) thorows IOException</li>
   <li>void write(String s) throws IOException</li>
   <li>void write(char[] ch) throws IOException</li>
   <li>void newLine()<br>
      for inserting a new line character.</li>
   <li>void flush()</li>
   <li>void close()</li>
  
</ol>
<p ><b>Which method is available in BufferedWriter and not available in FileWriter</b></p>
<p >Ans: newLine() method</p>
<textarea rows="22" cols="60" class="textArea" readonly>
   Ex:-
         class test
         {
         public static void main(String arg[])throws Exception
         {
         File f = new File("pongal.txt");
         System.out.println(f.exists());
         FileWriter fw = new FileWriter(f);
         BufferedWriter bw = new BufferedWriter(fw);
         bw.write(97);
         bw.newLine();
         char [] ch1 = {'a','b','c','d'};
         bw.write(ch1);
         bw.newLine();
         bw.write("raju");
         bw.newLine();
         bw.write("software");
         bw.flush();
         bw.close();
         }
         }
</textarea>
<p ><b>Note:-</b> When ever we r closing BufferedWriter ,automatically underlying FileWriter object will be
   closed.</p>
 <img src="assets/images/bufferwriterclass.PNG" id="bufferwritter">
 <p style=" font-size: 20px;"><b>BufferedReader</b></p>
<p>By using this class we can read character data from the file.</p>
<p ><b>Constructors</b></p>
<ol >
   <li>BufferedReader br = new BufferedReader(Reader r)</li>
   <li>BufferedReader br = new BufferedReader(Reader r, int buffersize)<br>
      BufferedReader never communicates directly with the file. It should Communicate through<br>
      some reader object only.</li>
</ol>
<p ><b>Important methods of BufferedReader Class</b></p>
<ol >
   <li>int read()</li>
   <li>int read(char [] ch)</li>
   <li>String readLine();<br>
      Reads the next line present in the file. If there is no nextline this method returns null.
   </li>
   <li>void close()</li>
</ol>
<textarea rows="18" cols="60" class="textArea" readonly>
   Ex:
         class test
         {
         public static void main(String arg[])throws Exception
         {
         FileReader fr = new FileReader("pongal.txt");
         BufferedReader br = new BufferedReader(fr);
         String s = br.readLine();
         while(s != null)
         {
         System.out.println(s);
         s = br.readLine();
         }
         br.close();
         }
         }
</textarea>
<p ><b>Note:-</b> When ever we r closing BufferedReader ,automatically underlying FileReader object will be
   closed.</p>
<p style=" font-size: 20px;"><b>PrintWriter</b></p>
<p >The most enhanced writer for writing character data to the file is PrintWriter()</p>
<p ><b>Constructors</b></p>
<ol >
   <li>PrintWriter pw = new PrintWriter(String fname)</li>
   <li>PrintWriter pw = new PrintWriter(File f);</li>
   <li>PrintWriter pw = new PrintWriter(Writer w);</li>
</ol>
<p ><b>Important methods</b></p>
<ol >
   <li>write(int ch)</li>
   <li>write(char [] ch)</li>
   <li>write(String s) </li>
   <li>print(int i)<br>
      print(double d)<br>
      print(char ch)<br>
      print(Boolean b)<br>
      print(char ch[])</li>
      <li>void flush()</li>
      <li>close()</li>
</ol>
<textarea rows="18" cols="60" class="textArea" readonly>
   Ex:
         class test
         {
         public static void main(String arg[])throws Exception
         {
         FileWriter fw = new FileWriter("pongal.txt");
         PrintWriter out = new PrintWriter(fw);
         out.write(97);
         out.println(100);
         out.println(true);
         out.println('c');
         out.println("FDGH");
         out.flush();
         out.close();
         }
         }
</textarea>
<p style=" font-size: 20px;"><b>Serialization Introduction</b></p>
<p ><b>Serialization:</b> The Process of Saving an object to a file is called “serialization”. But strictly speaking<br>
   serialization is the process of converting an object from java supported format to network or file supported<br>
   format.<br>
   By using FileOutPutStream, ObjectOutPutStream classes we can achieve serialization</p>
   <img src="assets/images/writeobject.PNG" id="writeobject"><br> 
   <p ><b>Deserialization:</b> The process of reading an object from a file is called deserialization. But strictly speaking it
      is the process of Converting an object from network supported format or file supported format to java
      supported format.<br>
      By using FileInputStream, ObjectInputStream we can achieve deserialization.</p>
      <img src="assets/images/readobject.PNG" id="readobject"><br> 
<textarea rows="25" cols="70" class="textArea" readonly>
   Ex:-
         class Dog implements Serializable
         {
         int i= 10;
         int j= 20;
         }
         class serializedemo
         {
         public static void main(String arg[])
         {
         Dog d = new Dog();
         FileOutputStream fos = new FileOutputStream("abc.ser");
         ObjectOutputStream oos = new ObjectOutputStream(fos);
         oos.writeObject(d);
         FileInputStream fis = new FileInputStream("abc.ser");
         ObjectInputStream ois = new ObjectInputStream(fis);
         Dog d1 = (Dog)ois.readObject();
         System.out.println(d1.i+"---"+d2.j);
         Dog
         }
         }
</textarea>
<p >We can perform serialization only for serialization objects.<br><br>
   An Object is said to be serializable if and only if the corresponding class should implement serializable<br>
   interface. serializable interface present in java.io package and doesn’t contain any method, it is marker<br>
   interface.<br><br>
   If u r trying to perform serialization of a non serialization Object. we will get runtime exception saying<br>
   NonSerializableException.<br><br>
   If we don’t want to Serialize the value of a particular variable (To meet security constraints) we should<br>
   declare those variables as transient. While performing serialization JVM ignores the value of transient<br>
   variables and saves default values instead of original values.<br><br>
   static variables are not part of object state and hence they won’t participate in serialization process<br>
   Declaring static variables as transient there is no impact similarly declaring final variables as transient<br>
   creates no impact.</p>
  <img src="assets/images/deserialization.PNG" id="deserialization"><br> 
   <p style=" font-size: 20px;"><b>Serialization in the case of Object Graphs</b></p>
<p >When ever we are saving an object to a file all the objects which are reachable from that object will be saved<br>
   by default. This group of objects is called ‘Object Graph’.<br>
   In the Object Graph if any Object is non-Serialzable we will get runtime Exception saying not- serializable<br>
   Exception.</p>
   <textarea rows="34" cols="70" class="textArea" readonly>
   Ex:-
            import java.io.*;
            class Dog implements Serializable
            {
            Cat c = new Cat();
            }
            class Cat implements Serializable
            {
            Rat r = new Rat();
            }
            class Rat implements Serializable
            {
            int j= 20;
            }
            class SerializeDemo
            {
            public static void main(String arg[])throws Exception
            {
            Dog d = new Dog();
            FileOutputStream fos = new FileOutputStream("abc.ser");
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(d);
            FileInputStream fis = new FileInputStream("abc.ser");
            ObjectInputStream ois = new ObjectInputStream(fis);
            Dog d1 = (Dog)ois.readObject();
            System.out.println(d1.c.r.j);
            }
            }
            O/P:- 20
   </textarea>
<p >In the above program among Dog, Cat and Rat classes if any class is not Serializable we will get runtime<br>
   Exception saying java.io.NotSerializableException.</p>
<P style=" font-size: 20px;"><b>Customized Serialization</b></P>
<p >During default Serialization there may be a chance of loss of information because of transient variables.</p>
<textarea rows="28" cols="70" class="textArea" readonly>
Ex:-
         import java.io.*;
         class Dog implements Serializable
         {
         transient Cat c = new Cat();
         }
         class Cat
         {
         int j= 20;
         }
         class SerializeDemo
         {
         public static void main(String arg[])throws Exception
         {
         Dog d = new Dog();
         System.out.println("Before Serialization:"+d.c.j);
         FileOutputStream fos = new FileOutputStream("abc.ser");
         ObjectOutputStream oos = new ObjectOutputStream(fos);
         oos.writeObject(d);
         FileInputStream fis = new FileInputStream("abc.ser");
         ObjectInputStream ois = new ObjectInputStream(fis);
         Dog d1 = (Dog)ois.readObject();
         System.out.println(d1.c.j);
         }
         }   
</textarea><br>
<img src="assets/images/customizedserialization.PNG" id="customized"><br> 
<p ><b>Internal Process in Diagramatic Form</b></p>
<img src="assets/images/customized.PNG" id="customized1"><br> 
<p >In the above program before serialization dog object tell ‘j’ value. But after deserialization dog object can’t<br>
   tell j value(d1.c.j) will rise NullPointerException.<br>
   i.e during Serialization there may be a chance of loss of information. To recover this information we should<br>
   customize Serialization process. which is nothing but “Customized Serialization”<br><br>
   We can implement customized Serialization by using the following two methods.<br>
   private void writeObject(OutputStream os)throws Exception<br>
   &#123;	<br>
   ….<br>
   ….<br>
   ….<br>
   }<br>
   This method will be executed automatically by the JVM at the time of Serialization.<br>
   private void readObject(InputStream is)throws Exception<br>
   &#123;	<br>
   ….<br>
   ….<br>
   ….<br>
   }<br>
   This method will be executed automatically by the JVM at the time of deSerialization.</p><br>
   <textarea rows="50" cols="70" class="textArea" readonly>
    Ex:-
            import java.io.*;
            class Dog implements Serializable
            {
            transient Cat c = new Cat();
            private void writeObject(ObjectOutputStream os)throws IOException
            {
            int x = c.j;
            os.writeInt(x);
            }
            private void readObject(ObjectInputStream is)throws IOException,
            ClassNotFoundException
            {
            is.defaultReadObject();
            c=null
            d
            d
            j=20
            c
            Cat
            c=null
            d
            int k = is.readInt();
            c = new Cat();
            c.j = k;
            }
            }
            class Cat
            {
            int j= 20;
            }
            class SerializeDemo
            {
            public static void main(String arg[])throws Exception
            {
            Dog d = new Dog();
            System.out.println("Before Serialization:"+d.c.j);
            FileOutputStream fos = new FileOutputStream("abc.ser");
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(d);
            FileInputStream fis = new FileInputStream("abc.ser");
            ObjectInputStream ois = new ObjectInputStream(fis);
            Dog d1 = (Dog)ois.readObject();
            System.out.println(d1.c.j);
            }
            }
   </textarea>
<p ><b>O/P:- 20</b></p>
<p ><b>Internal Process in Diagramatic Form:</b></p>
<img src="assets/images/customized1.PNG" id="customized2"><br> 
<p style=" font-size: 20px;"><b>Inheritance in Serialization</b></p>
<p>If the parent class is Serializable bydefault all the child classes also Serializable. i.e Serializable nature is<br>
   inherited from parent to child.</p>
   <textarea rows="25" cols="70" class="textArea" readonly>
    Ex:-
            import java.io.*;
            class Animal implements Serializable
            {
            int i = 10;
            }
            class Dog extends Animal
            {
            int j = 20;
            }
            class SerializeDemo
            {
            public static void main(String arg[])throws Exception
            {
            Dog d = new Dog();
            FileOutputStream fos = new FileOutputStream("abc.ser");
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(d);
            FileInputStream fis = new FileInputStream("abc.ser");
            ObjectInputStream ois = new ObjectInputStream(fis);
            Dog d1 = (Dog)ois.readObject();
            System.out.println(d1.i+"-----"+d1.j);
            }
            }
   </textarea>
<p >If the child class is Serializable and some of the parent classes are not Serializable, Still we are allowed to<br>
   serialize child class Objects. While performing serialization JVM ignores the inherited variables which are<br>
   coming from non-serializable parents.<br>
   While performing de-serialization JVM will check is there any parent class is non-serializable or not.<br>
   If any parent is non-serializable JVM will create an object for every non-serializable parent and share it’s<br>
   instance variables for the current child object.<br><br>
   The non-serializable parent class should compulsory contain no-argument constructor other wise we will get
   runtime error.</p>
  <textarea rows="40" cols="70" class="textArea" readonly>
   Ex:-
            import java.io.*;
            class Animal
            {
            int i = 10;
            Animal()
            {
            System.out.println("Animal Constructor");
            }
            }
            class Dog extends Animal implements Serializable
            {
            int j = 20;
            Dog()
            {
            System.out.println("Dog Constructor");
            }
            }
            class SerializeDemo
            {
            public static void main(String arg[])throws Exception
            {
            Dog d = new Dog();
            d.i = 888;
            d.j = 999;
            System.out.println(d.i+"-----"+d.j);
            System.out.println("Serilization Started");
            FileOutputStream fos = new FileOutputStream("abc.ser");
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(d);
            System.out.println("Deserialization Started");
            FileInputStream fis = new FileInputStream("abc.ser");
            ObjectInputStream ois = new ObjectInputStream(fis);
            Dog d1 = (Dog)ois.readObject();
            System.out.println(d1.i+"-----"+d1.j);
            }
            }
   </textarea><br>
   <img src="assets/images/customized3.PNG" id="customized3"><br>
<p ><b>Internal Process in Diagramatic Form:</b></p>
   <img src="assets/images/customized4.PNG" id="customized4"><br>
      </div>
      <div class="garbagecollector" *ngIf="garbage">
         <h1 class="mt-4">GARBAGE COLLECTION</h1>
         <p><b>Introduction</b></p>
         <p>In ‘C++’ the programmer is responsible for both creation and destruction of objects but usually the
            programmer is giving very much importance for creation of objects and he is ignoring the destruction of
            objects. Due to this at creation point of time there may not be sufficient memory for the creation of new
            objects and entire program may fails. But in java programmer is responsible only for creation of objects but
            sun people has introduced one assistance which is running continuously in the background for destruction of
            objects. Due to this assistance there is no chance of failing the java program due to memory problem, this
            assistance is nothing but “Garbage Collector”.
         </p>
         <p><b>The ways to make an object eligible for Garbage Collector</b></p>
         <p>Even though the programmer is not responsible for destruction of objects it’s good programming practice to
            make an object eligible for Garbage Collector if it is no longer required.
         </p>
         <img src="assets/images/gc1.png"><br>
         <img src="assets/images/gc2.png"><br>
         <p><b>The Objects Created inside a method</b></p>
         <p>The objects which are created in a method are by default eligible for Garbage Collector once the
            method completes
         </p>
         <img src="assets/images/gc3.png"><br>
         <img src="assets/images/gc4.png"><br>
         <img src="assets/images/gc5.png"><br>
         <img src="assets/images/gc6.png"><br>
         <p><b>Note:</b> 1) If an object doesn’t have any reference variable that object is always eligible for Garbage
            Collection.<br>
            2) Even though object having the reference variable still there may be a chance of that object
            eligible for Garbage Collection (Island of Isolation …Here ‘i’ is internal reference)
         </p>
         <br>
         <p><b>The methods to request JVM to run Garbage Collector</b></p>
         <p>We can request JVM to run Garbage Collector but there is no guarantee whether JVM accepts our request or
            not. We can do this by using the following ways.
         </p>
         <p><b>By System class</b></p>
         <p>‘System’ class contains a static ‘gc’ method for requesting JVM to run Garbage Collector<br>
            System.gc();
         </p>
         <p><b>By Using Runtime Class</b></p>
         <p>A java application can communicate with JVM by using Runtime Object. We can get Runtime
            Object as follows.<br>
            Runtime r = Runtime.getRuntime();<br>
            Once we get Runtime Object we can apply the following methods on that object
         </p>
         <p><b>freeMemory():</b> returns the free memory available in the loop</p>
         <p><b>totalMemory():</b> returns heap size</p>
         <p><b>gc():</b> for requesting JVM to run GarbageCollector</p>
         <textarea rows="22" cols="70" class="textArea" readonly>
            Ex:
            import java.util.*;
            class RuntimeDemo
            {
            public static void main(String arg[])
            {
            Runtime r = Runtime.getRuntime();
            System.out.println(r.totalMemory());  2031616
            System.out.println(r.freeMemory());  1870416
            for(int i= 0; i &#60; = 10000; i++)
            {
            Date d = new Date();
            d = null;
            }
            System.out.println(r.freeMemory());  1633032
            r.gc();
            System.out.println(r.freeMemory());  1923992
            }
            }
            
         </textarea>
         <p><b>Note:-</b>gc() method available in the system class is static method but gc() method available in Runtime
            class
            is an instance method.
         </p>
         <p><b>Q) Which of the following is the valid way for requesting JVM to run gc?</b><br>
            System.gc();<i class="fa fa-check" style="margin-left: 10px;"></i>
            Runtime.gc();<i class="fa fa-close" style="margin-left: 10px;"></i> -> not a static
            (new Runtime()).ge(); <i class="fa fa-close" style="margin-left: 10px;"></i> ->we can’t create Object
            Runtime.getRuntime().gc();<i class="fa fa-check" style="margin-left: 10px;"></i>
         </p>
         <p><b>finalization</b><br>
            Just before destroying any object Garbage Collector always calls finalize() to perform clean up activities.
            finalize() is available in the Object class which is declared as follows<br>
            protected void finalize() throws Throwable<br>
            &#123;<br>
            &#125;<br>
         </p>
         <p><b>case1:</b> Garbage Collector always calls finalize() on the Object which is eligible for Garbage
            Collector and
            the corresponding class finalize method will be executed.
         </p>
         <textarea rows="18" cols="70" class="textArea" readonly>
            Ex:
            class Test
            {
            public static void main(String arg[])
            {
            String s = new String("raju");
            //Test s = new Test();
            s = null;
            System.gc();
            System.out.println("end of main method");
            }
            public void finalize()
            {
            System.out.println("finalize method called");
            }
            }              

                     </textarea>
         <p><b>O/P:-</b>end of main method<BR>
            In this case String Object is eligible for G.C and hence String class finalize() method has been executed.
            In the above program if we are replacing String Object with Test Object then Test class finalize() will be
            executed
         </p>
         <P>In this case <b>O/P </b>is end of main method<br>
            finalize method called<br>
            or<br>
            finalize method called<br>
            end of main method
         </P>
         <p><b>case2:</b> we can call finalize() explicitly in that case it will execute just like a normal method and
            object won’t
            be destroyed.<br>
            While executing finalize() method if any exception is uncaught it is simply ignored by the JVM but if we are
            calling finalize method explicitly and if an exceptions is uncaught then the program will be terminated
            abnormally.
         </p>
         <textarea rows="18" cols="70" class="textArea" readonly>
            Ex:
            class Test
            {
            public static void main(String arg[])
            {
            Test s = new Test();
            //s.finalize();
            s = null;
            System.gc();
            System.out.println("End of main method");
            }
            public void finalize()
            {
            System.out.println("finalize method");
            System.out.println(10/0);
            }
            }                      
                              </textarea>
         <p><b>O/P:- </b>finalize method<br>
            end of main method
         </p>
         <p><b>Q) which of the following statements are true</b><br>
            1) JVM ignores all exceptions which are raised while executing finalize()<br>
            2) JVM ignores only uncaught exceptions which are raised during execution of
            finalize()
         </p>
         <p><b>case3:</b> 1) Garbage Collector calls finalize() only once on any object i.e it won’t call more than
            once.<br>
            2) While executing finalize() there maybe a chance of object getting reference variable at that time
            G.C won’t destroy that object after completing finalize()<br>
            3) If the same object is eligible for G.C second time with out executing finalize() method G.C will
            destroy that object..
         </p>
         <textarea rows="20" cols="70" class="textArea" readonly>
            Ex:
            class FinalizeDemo
            {
            //Test s;
            public static void main(String arg[])
            {
            FinalizeDemo f = new FinalizeDemo();
            System.out.println(f.hashcode());
            f = null;
            System.gc();
            Thread.sleep(5000);
            System.out.println(s.hashCode());
            s = null;
            System.gc();
            Thread.sleep(5000);
            System.out.println("End of main method");
            }
            public void finalize()
            {
            System.out.println("finalize method called");
            s = this;
            }
            }                                   
                                          </textarea>
         <p>The behavior of G.C is vendor dependent hence there is no guarantee for the following<br>
            1) Whether the G.C follows mark & sweep algorithm or not<br>
            2) What exact Algorithm followed by Garbage Collector<br>
            3) In which order Garbage Collector destroys Object<br>
            4) Whether Garbage destroys all eligible objects or not<br>
            5) At what time exactly Garbage Collector will run.
         </p>
      </div>
      <div class="collectionfw" *ngIf="collection">
         <h1 class="mt-4">COLLECTIONS FRAME WORK</h1>
		  <p style=" font-size: 20px;"><b>Limitations of Object Arrays</b></p>
         <p >An array is an indexed collection of fixed number of homogeneous data elements.<br>
 The main limitations of Object Arrays are  </p>
     <ol >
        <li>Arrays are fixed in size i.e once we created an array there is no chance of increasing or<br>
         decreasing it’s size based on our requirement.</li>
         <li>Arrays can hold only homogeneous data elements.</li>
         <p>Ex:-<br>
                  Student [] s = new Student [600];<br>
                  s[0] = new Student;<i class="fa fa-check" style="color:blue; margin-left: 30px;"></i><br>
                  s[1] = new Integer(10); <i class="fa fa-close" style="color:red; margin-left: 5px;"></i><br>
                  s[2] = "raju"; <i class="fa fa-close" style="color:red; margin-left: 78px;"></i><br><br>
                  We can resolve this problem by using object Arrays.<br><br>
                  Object [] o = new Object [600];<br>
                  o[0] = new Student;<i class="fa fa-check" style="color:blue;margin-left: 30px;"></i><br>
                  o[1] = new Integer(10);<i class="fa fa-check" style="color:blue;margin-left: 10px;"></i><br>
                  o[2] = "raju";<i class="fa fa-check" style="color:blue; margin-left: 83px;"></i><br>
                  i.e By using Object Arrays we can hold heterogeneous data elements.</p>
                  <li>For the Arrays there is no underlying Data Structure i.e for every requirement we have to code<br>
                     explicitly and there is no default ready made support(like sorting, searching).<br>
                     we can’t represent array elements in some sorting order by default. We can’t prevent duplicate<br>
                     object insertion etc…</li>
     </ol>
     <p >To resolve the above problems of arrays, Sun people has introduced <b>‘collections concept’</b></p>
 <p ><i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>Collections are grow able in nature i.e based on requirement we can increase or decrease the size.<br>
 <span><i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>Collections can hold heterogeneous data elements also.</span><br>
   <span><i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>Every collection class has implemented based on some data structure</span></p> 
<p >  Hence for every requirement ready made method support is possible.<br>
We can represent all the elements in some sorting order. We can prevent duplicate object insertion<br>
by default.</p><br>
<p style="font-size: 22px;"><b>Comparison Between collections and Arrays</b></p>
<img src="assets/images/collections.PNG" id="collections"><br> <br> 
<p style=" font-size: 22px;"><b>Collections Frame Work</b></p>    
 <p >It defines group of classes and interfaces which can be used for representing a collection of Objects as single<br>
   entity.</p>    
   <img src="assets/images/collections1.PNG" id="collections1"><br><br>    
  <p style="font-size: 18px;"><b>7 key Interfaces of collection Frame Work</b></p>   
 <ol>
    <li><b>Collection :</b><br>
      This interface is the root interface for entire collection framework.<br>
      This interface can be used for representing a group of objects as single entity.<br>
      This interface defines the most common general methods which can be applicable for any collection<br>
      object.<br>
      There is no concrete class which implements collection interface directly.<br><br>
     <b> Difference Between Collection and Collections</b><br>
      Collection is an interface available in java.util package for representing a group of objects as single<br>
      entity.<br>
      Collections is an utility class available in java.util package and defines several utility methods for<br>
      collection implemented class object<br><br>
   </li>
  
   <li><b>List interface :</b><br> 
   This can be used for representing a group of individual objects as a single entity where insertion<br>
   order is preserved and duplicate objects allowed. This is child interface of collection.<br>
   The following classes implemented List interface directly.<br>
   ArrayList, LinkedList, Vector and Stack.</li><br>
  <img src="assets/images/keyinterface.PNG" id="keyinterface"><br>  
<p style="margin-left: 80px;">Vector and stack classes are reengineered in 1.2 version to fit into collection frame work.<br>
   By means of Indexes we can preserve insertion order and we can differentiate duplicate objects.</p><br>
 <img src="assets/images/keyinterface1.PNG" id="keyinterface1"><br>

<li><b>Set interface :</b><br>
   This can be used for representing a group of individual objects where <b>duplicate objects are not<br>
   allowed and insertion operation is not preserved.</b><br>
   This is the child interface of collection<br>
  hashset and linkedHashSet are the classes which implements Set interface directly.</li><br>
<li> <b>SortedSet interface :</b><br>
   This can be used for representing a group of individual and unique objects. Where all the objects are<br>
   inserted in some sorting order. It is the child interface of Set interface<br>
   TreeSet is the implemented class of SortedSet</li><br>
   <img src="assets/images/sortedset.PNG" id="sortedset"><br>
<li><b>Queue interface :</b><br>
   It is the child interface of collection it has introduced in 1.5 version this interface can be used for<br>
   representing a group of individual objects prior to processing.<br></li>
  <img src="assets/images/queue.PNG" id="queue"><br>
   <p >All the above interfaces(collection, List, Set, SortedSet, Queue) can be used for representing a group<br>
      of individual objects.<br>
      If u want to represent a group of objects as key value pair than we can’t use above interfaces.<br>
      To handle this requirement sun people has introduced <b>map </b>interface.</p><br>
<li><b>Map :</b><br>
   This can be used for representing a group of objects as key value pairs. Both key and value are<br>
   objects only.<br>
  StudentName  <i class="fa fa-arrow-right" style="margin-left: 18px;"></i> StudentRollNo <br>
  phoneNumber  <i class="fa fa-arrow-right" style="margin-left: 13px;"></i> contactdetails <br>
  word <i class="fa fa-arrow-right" style="margin-left: 80px;"></i> meaning <br>
  IP Address  <i class="fa fa-arrow-right" style="margin-left: 42px;"></i> Domain-name<br>
  Map interface is not child interface of collection.</li><br>
   <img src="assets/images/map.PNG" id="map"><br>
<li><b>SortedMap :</b><br>
   This can be used for representing a group of objects as key value pairs where all the entries are<br>
   arranged in some sorting order of keys.<br>
   TreeMap is the class which implements SortedMap interface.</li><br>
   <img src="assets/images/sortedmap.PNG" id="sortedmap"><br>
   </ol>
  <p style="font-size: 22px;"><b>Collection</b></p>   
  <p >This can be used for representing a group of individual objects as a single entity. This interface defines the<br>
   most common general methods. Which can be applicable for any collection implemented class object.</p> <br>  
  <img src="assets/images/collection.PNG" id="collection"><br>   
 <p ><b>Colletion Interface methods</b></p>    
<ol >
   <li>boolean add(Object obj)</li>
   <li>boolean addAll(Collection c)</li>
   <li>boolean remove(Object obj)</li>
   <li>boolean removeAll(Collection c)<br>
      (Removes particular group of objects.)
   </li>
   <li>boolean retainAll(Collection c)<br>
      (Removes all the elements except those present in ‘c’)</li>
   <li>void clear()<br>
      (Removies all objects.)</li>
   <li>boolean contains(Object obj)<br>
      (Checks object is there or not.)</li>
   <li>boolean contains (Collection c)</li>
   <li>boolean isEmpty()</li>
   <li>int size()</li>
   <li>Object [] toArray()</li>
   <li>Iterator iterator()<br>
      (to retrieve the objects one by one.)</li><br>
</ol>
<p style=" font-size: 20px;"><b>List interface</b></p>
<p >This can be used for representing a group of individual objects where insertion order is preserved and<br>
   duplicate objects are allowed. By means of index we can preserve insertion order and we can differentiate<br>
   duplicate objects.</p><br>
<p ><b>List Interface Defines the following methods</b></p>
<ol >
   <li>boolean add(Object obj)</li>
   <li>boolean add(int index, Object obj)</li>
   <li>boolean addAll(Collection c)</li>
   <li>boolean addAll(int index, Collection c)</li>
   <li>boolean remove(Object obj)</li>
   <li>Object remove(int index)</li>
   <li>Object set(int index, Object new)<br>
      Old object. It replaces with the existing objected located at specified index with the new<br>
      object. And it returns object.</li>
   <li>Object get(int index)</li>
   <li>int indexOf(Object obj)</li>
   <li>int lastIndexOf(Object obj)</li>
   <li>ListIterator listIterator()</li>
</ol>
<p style="font-size: 18px;"><b>ArrayList()</b></p>
<p ><i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i> The underlying data Structure for ArrayList() is resizable Array or “Growable Array”.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i> Duplicate objects are allowed.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i> Insertion order is preserved.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i> Heterogeneous objects are allowed.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i> ‘null’ insertion is possible.</p><br>

<p ><b>Constructors of Array List</b><br>
      ArrayList l = new ArrayList()   <br>
   Creates an empty ArrayList object with default intitial capacity 10.<br>
   When ever ArrayList reaches its max capacity a new ArrayList Object will be created with new<br>
   capacity.<br>
<img src="assets/images/arraylist.PNG" id="arraylist"><br>
 ArrayList l = new ArrayList(int initial capacity)<br>
   Creates an empty ArrayList Object with the specified initial capacity.<br><br>
  ArrayList l = new ArrayList(Collection c) <br>
   For inter conversion between collection objects.</p>
<textarea rows="20" cols="60" class="textArea" readonly>
   Ex:
            import java.util.*;
            class ArrayListDemo
            {
            public static void main(String arg[])
            {
            ArrayList a = new ArrayList();
            a.add("A");
            a.add(new Integer(10));
            a.add("A");
            a.add(null);
            System.out.println(a);
            a.remove(2);
            System.out.println(a);
            a.add(2,"M");
            a.add("N");
            System.out.println(a);
            }
            }
   </textarea><br>
   <img src="assets/images/arraylist1.PNG" id="arraylist1"><br>
<p >ArrayList and vector classes implement RandomAccess interface. So that we can access any element<br>
   with the same speed. Hence ArrayList is best suitable if our frequent operation is retrieval operation.<br><br>
   Usually the collection objects can be used for data transport purpose and hence every collection<br>
   implemented class already implemented serializable and cloneable interfaces.<br><br>
   ArrayList is the worst choice if u want to perform insertion or deletion in the middle.<br><br>
   <img src="assets/images/arraylist2.PNG" id="arraylist2"><br>
  <b>Note:-</b>  ArrayList is not recommended if the frequent operation is insertion or deletion in the middle.<br>
   To handle this requirement we should go for linked list.</p><br>
<p style="font-size: 20px;"><b>LinkedList()</b></p>
<p  >  <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>  The underlying Data Structure for linked list is doubly linked list.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>  Duplicate objects are allowed.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>  Insertion order is preserved.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>  Heterogeneous objects are allowed.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>  ‘null’ insertion is possible.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>  Implements List, Queue, serializable, clonealbe Interfaces But not RandomAccess.</p>
<p  >LinkedList is the bestchoice if our frequent operation is insertion or deletion in the middle(no shift<br>
   operations are required)<br><br>
   LinkedList is the worst choice if our frequent operation is retrieval operation.<br>
   LinkedList class usually used for implementing stacks and Queues to provide support for this<br>
   requirement, LinkedList class contains the following specific methods.</p>
<ol >
<li>void addFirst(Object obj)</li>
<li>void addLast(Object obj)</li>
<li>Object removeFirst()</li>
<li>Object removeLast()</li>
<li>Object getFirst()</li>
<li>Object getLast()</li>
</ol>
<p ><b>Constructors</b></p>
<ol  >
   <li>LinkedList l = new LinkedList()</li>
   <li>LinkedList l = new LinkedList(Collection c)</li>
</ol>
<p >For inter conversion between collection objects</p>
<textarea rows="32" cols="60" class="textArea" readonly>
 Ex:
         import java.util.*;
         class LinkedListDemo
         {
         public static void main(String arg[])
         {
         LinkedList l = new LinkedList();
         l.add("raju");
         l.add(new Integer(10));
         l.add(null);
         l.add("raju");
         l.set(0, "chinna");
         l.add(0, "Kiran");
         l.addFirst("AAAA");
         l.addLast("ZZZZ");
         System.out.println(l);
         }
         }
         Inter conversion between collection objects.
         ArrayList al = new ArrayList();
         l1.add(10);
         l1.add(20);
         l1.add(30);
         System.out.println("l1--->"+l1);
         LinkedList l2 = new LinkedList(l1);
         l2.add(1,5);
         l2.add(3,5);
         l2.add(5,15);
         System.out.println("l2--->"+l2);
         ArrayList l3 = new ArrayList(l2)
         System.out.println("l3--->"+l3);
</textarea><br>
<img src="assets/images/constructors.PNG" id="constructors"><br>
<p style="font-size: 20px;"><b>VectorClass</b></p>
<p  >  <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>  The underlying Data structure for the vector is resizable array or growable array.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>  Insertion order is preserved..<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>  Duplicate objects are allowed.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>  ‘null’ insertion is possible.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>  Heterogeneous objects are allowed.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>  Best choice if the frequent operation is retrieval.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>  Worst choice if the frequent operation is insertion or deletion in the middle.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>  Vector class implemented serializable, cloneable and RandomAccess Interfaces.<br>
</p>
<p ><b>Difference between vector and ArrayList?</b></p>
<img src="assets/images/vector.PNG" id="vector"><br>
<p >We can get synchronized version of ArrayList of by using the following method of collection class.</p>
  <p >Ex:</p> 
  <img src="assets/images/vector1.PNG" id="vector1"><br>
<p >Similarly we can find synchronized versions of set and Map objects by using the collections class<br>
   method.</p>
<p >public static Set synchronizedSet(Set s1)<br>
   public static Map synchronizedMap(Map m1)</p>
<p ><b>Vector methods</b></p>
<p style=" margin-top: -10px;">For adding objects.</p>
<p style=" margin-top: -10px;">add(Object obj)<br>
   add(int index, Object obj)<br>
   addElement(Object obj)</p>
   <p style=" margin-top: -10px;">For removing Objects</p>
<p style=" margin-top: -10px;">remove(Object obj)<br>
   removeElement(Object obj)<br>
   remove(int index)<br>
   removeElementAt(int index)<br>
   clear()<br>
removeAllElements()</p>

   <p style="margin-top: -10px;">For Accessing Elements</p>
<p style=" margin-top: -10px;">Object get(int index)<br>
   Object elementAt(int index)<br>
   Object firstElement();<br>
   Object lastElement();</p>
   <p style=" margin-top: -10px;">OtherMethods</p>
<p style=" margin-top: -10px;">int size();<br>
   int capacity();<br>
   enumaration elements();</p>
 <p><b> constructors</b><br>
  Vector v = new Vector(); <br>
   Creates an empty vector object with default initial capacity 10, when ever vector reaches it’s max<br>
   capacity a new vector object will be created with.<br><br>
   <img src="assets/images/constructors1.PNG" id="constructors1"><br> <br>
    Vector v = new Vector(int initialCapacity)<br>
       Vector v = new Vector(int initialCapacity, int incrementalCapacity)<br>
          Vector v = new Vector(Collection c)</p> 

<textarea rows="25" cols="60" class="textArea" readonly>
Ex:
         import java.util.*;
         class VectorDemo
         {
         public static void main(String arg[])
         {
         Vector v = new Vector();
         System.out.println(v.capacity());
         for (int i = 0;i&#60;10 ;i++ )
         {
         v.addElement(i);
         }
         synchronized
         ArrayList l1 = new ArrayList();
         List l2 = Collections.synchronizedList(l1);
         Non synchronized
         new capacity = 2 * current capacity
         System.out.println(v.capacity());
         v.addElement("Aa");
         System.out.println(v.capacity());
         System.out.println(v);
         }
         }
</textarea><br>
<img src="assets/images/constructors2.PNG" id="constructors2"><br>
<p style="font-size: 18px;"><b>Stack</b></p>
<p >It is the child class of Vector contains only one constructor.</p>
<p >Stack s = new Stack();</p>
<p style="font-size: 18px;"><b>Methods</b></p>
<p >Object push(Object obj);</p>
  <p style="margin-top: -12px;">For inserting an object to the stack</p> 
  <p >Object pop();</p>
  <p style="margin-top: -12px;">It removes and returns top of the stack.</p> 
  <p >Object peak();</p>
  <p style="margin-top: -12px;">Returns the top of the stack with out removal of object.</p> 
  <p >int search(Object obj);</p>
  <p style="margin-top: -12px;">If the specified object is available it returns its offset from top of the stack<br>
   If the object is not available then it returns -1.</p> 
   <p >boolean empty();</p>
   <p style="margin-top: -12px;">returns true if the stack is empty otherwise false.</p> 
<textarea rows="18" cols="60" class="textArea" readonly>
Ex:
         import java.util.*;
         class StackDemo
         {
         public static void main(String arg[])
         {
         Stack s = new Stack();
         s.push("A");
         s.push("B");
         s.push("C");
         System.out.println(s);
         System.out.println(s.search("A"));
         System.out.println(s.search("Z"));
         }
         }
   </textarea><br>
   <img src="assets/images/methods.PNG" id="methods"><br>
<p style="font-size: 22px;"><b>Cursors Available in collection frame work</b></p>
<p >From the collection object to retrieve object we can use the following 3 cursors.</p>
<ol >
   <li>Enumeration</li>
   <li>Iterator</li>
   <li>ListIterator</li>
</ol>
<p style=" font-size: 18px;"><b>Enumeration</b></p>
   <p  style=" margin-top: -10px;">This interface has introduced in 1.0 version it contains the following 2 methods.</p>
  <p >boolean hasMoreElements();<br>
   Object nextElement();</p> 
   <textarea rows="23" cols="60" class="textArea" readonly>
    Ex:
            import java.util.*;
            class EnumaretionDemo
            {
            public static void main(String arg[])
            {
            Vector v = new Vector();
            for (int i =0;i&#60;=10 ;i++ )
            {
            v.addElement(i);
            }
            System.out.println(v);
            Enumeration e = v.elements();
            while (e.hasMoreElements())
            {
            Integer i = (Integer)e.nextElement();
            if((i%2) == 0)
            System.out.println(i);
            }
            System.out.println(v);
            }
            }
   </textarea><br>
  <img src="assets/images/enumeration.PNG" id="enumeration"><br>
<p ><b>Limitations of Enumeration</b></p>
<ol >
   <li>It is applicable only for legacy classes and it is not a universal cursor.</li>
   <li>While iterating the elements by using enumeration we can perform only read operation and we
      can’t perform any modify/removal operations.</li>    
</ol>
<p >To overcome these problems we should go for Iterator interface.</p>
<p style="font-size: 18px;"><b>Iterator</b></p>
<p  ><i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>  Introduced in 1.2 version.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>  We can get Iterator Object for any collection incremented class i.e it is universal cursor.<br>
   <i class="fa fa-circle" aria-hidden="true" style="font-size: 10px;"></i>   By iterating the elements we can perform remove operation also in addition to read operation.</p>
<p >This interface contains the following 3 methods.</p>
<p style="margin-top: -10px;"> boolean hasNext();<br>
   Object next();<br>
   void remove();</p>
   <textarea rows="30" cols="60" class="textArea" readonly>
    Ex:
            import java.util.*;
            class IteratorDemo
            {
            public static void main(String arg[])
            {
            ArrayList al = new ArrayList();
            for (int i =0;i&#60;=10 ;i++ )
            {
            al.add(i);
            }
            System.out.println(al);
            Iterator itr = al.iterator();
            while (itr.hasNext())
            {
            Integer i = (Integer)itr.next();
            if((i%2) == 0)
            {
            System.out.println(i);
            }
            else
            {
            itr.remove();
            }
            }
            System.out.println(al);
            }
            }
   </textarea><br>
   <img src="assets/images/iterator.PNG" id="iterator"><br>
   <p><b>Note:-</b></p>
         <ol>
         <li>
         Enumeration and Iterator are single directional cursors. They can always move to words forward
direction only.</li>
<li>By using Iterator we can perform read and remove operations. And we can’t perform any replace or
addition of new objects

         </li>
       
         </ol>
   <div class="ListIterator">
         <p><b>ListIterator</b></p>
         </div>
           <div class="ListIteratorol">
         <ol>
         <li>It has introduced in 1.2 version and it is child interface of Iterator.</li>
         <li>It is a bidirectional cursor.</li>
         <li>i.e Based on requirement we can move either to the forward or backward direction</li>
         <li>While Iterating we can perform replace and add operation in addition to read and remove this
interface defines the following 9 months.
</li>
        
         </ol>
         </div>
<div class="ListIteratorolnext">
            <ol>
         <li>boolean hasNext();</li>
         <li>boolean hasPrevious();</li>
         <li>Object next();</li>
         <li>Object previous();</li>
         <li>int nextIndex();</li>
         <li>int previousIndex();</li>
         <li>void remove();</li>
         <li>void set(Object new)</li>
         <li>void set(Object new)</li>
         </ol>
     </div> 
<p><b>nextIndex():</b>If there is no next element it returns size of the list.<br/>
<b>previousIndex():</b> If there is no previous element it returns -1.</p>
<textarea rows="25" cols="60" class="textArea" readonly>
   Ex:-
               import java.util.*;
               class ListIteratorDemo
               {
               public static void main(String arg[])
               {
               LinkedList l = new LinkedList();
               l.add("balakrishna");
               l.add("chiru");
               l.add("venky");
               l.add("nag");
               System.out.println(l);
               ListIterator ltr = l.listIterator();
               while (ltr.hasNext())
               {
               String s = (String)ltr.next();
               if(s.equals("nag"))
               {
               ltr.add("chaitanya");
               }
               }
               System.out.println(l);
               }
               }
</textarea>
<br/>
<br/>
<p>The most powerful cursor is listIterator. But it’s main limitation is it is applicable only for list
implemented classes (ArrayList, LinkedList, Vector, Stack).</p>

<p><b>Comparision between All the Three cursors</b></p>

<table align="center">
  <tr>
    <th>Properties</th>
    <th>Enumeration</th>
    <th>Iterator</th>
    <th>ListIterator</th>
  </tr>
  <tr>
    <th>1) It is Legacy?</th>
    <td>Yes</td>
    <td>No</td>
    <td>No</td>
  </tr>
  <tr>
  <th>2) It is applicable</th>
    <td>Only for legacy classes</td>
    <td>For any collection</td>
    <td>Only for list
implemented classes</td>
  </tr>
  <tr>
  <th>3) How to get?</th>
    <td>By using elements()</td>
    <td>By Using iterator() </td>
    <td>By Using ListIterator() </td>
  </tr>
  <tr>
    <th>4) Accessibility</th>
    <td>Only read</td>
    <td>read & remove</td>
    <td>read/remove/replace/add</td>
  </tr>
  <tr>
    <th>5.Movement</th>
    <td>Single direction
(Only Forward)</td>
    <td>Single direction
(Only Forward)</td>
    <td>Biderctional
</td>
  </tr>
  
<tr>
    <th>5.Methods</th>
    <td>hasMoreElements()
nextElements()
</td>
    <td>hasNext()
next()
remove()</td>
<td>hasNext()
hasPrevious()</td>

</tr>

<tr>
<th>
 7.version
</th>
<td>
1.0
</td>
<td>
1.2
</td>
<td>
1.2
</td>
  </tr>

</table>
<br/>
<p><b>SetInterface</b></p>
<p>This can be used for representing a group of Individual objects where insertion order is not preserved and
duplicate objects are not allowed.
<br/>
Set interface is child interface of Collection.<br/>
This interface doesn’t contain any new method and we have to use only collection Interface methods.</p>
<p><b>HashSet</b></p>
&#9827;&nbsp;The underlying Data Structure for HashSet is Hashtable.<br/>
&#9827;&nbsp;Insertion order is not preserved and it is based on has code of the Object.<br/>
&#9827;&nbsp;Duplicate objects are not allowed. Violation leads to no CompileTimeError or RuntimeError, add
method simply returns false.<br/>
&#9827;&nbsp;‘null’ insertion is possible.<br/>
&#9827;&nbsp;Heterogeneous objects are allowed.<br/>
&#9827;&nbsp;HashSet is the best choice if the frequent operation is Search Operation.<br/>

<p><b>Constructors</b></p>

<ol>
<li>HashSet h = new HashSet()
Creates an empty HashSet object with default initial value 16 and default fill ratio 0.75</li>
<li>HashSet h = new HashSet(int initialcapacity)</li>
<li>HashSet h = new HashSet(int initialCapacity, float fillratio)
Here fillratio is 0 or 1.</li>
<li>HashSet h = new HashSet(Collection c)</li>

</ol>
<textarea rows="18" cols="60" class="textArea" readonly>
   Ex:
            import java.util.*;
            class HashSetDemo
            {
            public static void main(String arg[])
            {
            HashSet h = new HashSet();
            h.add("B");
            h.add("C");
            h.add("D");
            h.add("Z");
            h.add(null);
            h.add(new Integer(10));
            System.out.println(h.add("Z"));
            System.out.println(h);
            }
            }
</textarea>
<br/>
<b>O/P:-</b>
<p class="OutPara"><b>false<br/>[&nbsp;Z, &nbsp;D, &nbsp;NULL,&nbsp; C,&nbsp; B,&nbsp; 10&nbsp;]</b></p>


<table align="center">
  <tr>
    <th>HashSet</th>
    <th>LinkedHashSet</th>

  </tr>
  <tr>
    <td>1) The underlying Data Structure is Hashtable</td>
    <td>1) The underlying Data Structures are
Hashtable and LinkedList 
</td>
  
  </tr>
  <tr>
    <td>2) Insertion Order is not preserved</td>
    <td>2) Insertion Order is preserved.</td>
  
  </tr>
  <tr>
    <td>3) Introduced in 1.2 version </td>
    <td>3) Introduced in 1.4 version</td>
  </tr>
</table>
<p>In the above program if u r replacing ‘HashSet’ with ‘LinkedHashSet’ the following is the output.</p>
<p class="OutPara"><b>false<br/>[&nbsp;Z, &nbsp;D, &nbsp;NULL,&nbsp; C,&nbsp; B,&nbsp; 10&nbsp;]</b></p>

<p><b>Mote:-</b><br/>

For implementing caching application the best suitable Data structure is LinkedHashSet and
LinkedHashMap where duplicate objects are not allowed and insertion order Must be preserved.
</p>
<div class="rectangle">
      <div class="icon1">
         <p><b>CacheMemory</b></p>
      </div>
    
 </div>
 <br/>
 <p><b>SortedSet</b><br/>
 

&#9827;&nbsp;This can be used for representing a group of individual objects where duplicate objects are not
allowed.
<br/>
&#9827;&nbsp;Insertion order is not preserved but all the elements are inserted according to some sorting order
of elements. The sorting order may be default natural sorting order or customized sorting order.
SortedSet Interface contains the following more specific methods.
 </p>

<div class="ListIteratorolnext">
            <ol>
         <li>Object first()<br/>
Returns first element in the SortedSet</li>
         <li>Object last()</li>
         <li>SortedSet headSet(Object obj)<br/>
Returns the SortedSet contains the elements which are less than object obj.</li>
         <li>SortedSet tailSet(Object obj)<br/>
Returns the SortedSet whose elements are greater than or equal to object obj</li>
         <li>SortedSet subSet(Object obj1, Object obj2)<br/>
Returns the SortedSet whose elements are >= obj1 but < Obj2</li>
         <li>Comparator comparator();<br/>
Returns the comparator object describes the underlying sorting technique.<br/>
If you are using default(Assending) natural sorting order it returns null.
</li>
         
         </ol>
     </div> 
<p>Observe the following Example.
</p>

<div class="rectangle2">
      <div class="icon2">
         <p><b><br/>100<br/>120<br/>130<br/>140<br/>150<br/>160<br/></b></p>
      </div>
      </div>
      <br/>
      <div class="ListIteratorolnext">
    <p><b>
    
  
    first() &#10140; 100 <br/>
last() &#10140; 160 <br/>
headSet(140) &#10140; &#10100;100,120,130&#10101; <br/>
tailSet(140) &#10140; &#10100;140,150,160&#10101; <br/>
subset(130,150)&#10140;&#10100;130,140&#10101; <br/>
comparator() &#10140; null 
</b>
    
    </p>
    </div>
<p><b>TreeSet</b>
<br/>
&#9827;&nbsp;The underlying Data structure for the TreeSet is Balanced tree.<br/>
&#9827;&nbsp;Duplicate objects are not allowed. If we are trying to insert duplicate object we won’t get any
compile time error or Run time error, add method simply returns false.<br/>
&#9827;&nbsp;Insertion order is not preserved but all the elements are inserted according to some sorting order.<br/>
&#9827;&nbsp;Heterogeneous objects are not allowed, violation leads to Run time error saying class cast
Exception 
</p>
<p><b>Constructors</b>

</p>

 <ol>
         <li>s
1. TreeSet t = new TreeSet();<br/>
Creates an empty TreeSet Object where the sorting order is default natural sorting
order.
</li>
         <li>TreeSet t= new TreeSet(Comparator c)<br/>
Creates an empty TreeSet Object where the Sorting order is specified by comparator
object</li>
         <li>TreeSet t= new TreeSet(Collection c)</li>
         <li>TreeSet t= new TreeSet(SortedSet s)<br/>
Creates TressSet Object for a given SortedSet.</li>
        
         </ol>
<textarea rows="18" cols="72  " class="textArea" readonly>
   EX:-
         import java.util.*;
         class TreeSetDemo
         {
         public static void main(String arg[])
         {
         TreeSet t = new TreeSet();
         t.add("A");
         t.add("B");
         t.add("Z");
         t.add("L");
         //t.add(new Integer(10)); &#10140; ClassCastException.
         //t.add(null); &#10140; NullPointerException.
         t.add("A"); &#10140; false.
         System.out.println(t);
         }
      }
</textarea> 
<p><b>null Acceptance</b>
For the empty TreeSet as the first element null insertion is possible. But after inserting null if we are
trying to insert any other element we will get NullPointerException.
</p>
<p>
If the TreeSet already contains some elements if we are trying to insert null we will get
NullPointerException.
</p>
<textarea rows="15" cols="60" class="textArea" readonly>
   Ex:
         import java.util.*;
         class TreeSetDemo
         {
         public static void main(String arg[])
         {
         TreeSet t = new TreeSet();
         t.add(new StringBuffer("A"));
         t.add(new StringBuffer("B"));
         t.add(new StringBuffer("T"));
         t.add(new StringBuffer("Z"));
         System.out.println(t);
         }
         }
</textArea>
<br/>
<b>O/P:-</b>
<br/>
<p class="OutPara"><b>R.E: ClassCastException</b></p>

<p>If we are depending on natural sorting order compulsory the objects should be homogeneous and
comparable other wise we will get class cast Exception.<br/>
An object is said to be comparable(if and only if) the corresponding class has to implement
comparable interface.<br/>
All wrapper classes and String class already implemented comparable interface. But the String buffer
doesn’t implement comparable interface. Hence in the above program we got class cast exception.</p>


<p><b>Comparable Interface</b>
It is available in java.lang package. This interface contains only one method compareTo()<br/>
public int compareTo(Object obj)<br/>
obj1.compareTo(obj2)<br/>
return –ve if obj1 has to come before obj2.<br/>
+ ve if obj1 has to come after obj2.<br/>
0 if obj1 and obj2 are equal(Duplicate Objects).
</p>

<textarea rows="10" cols="85" class="textArea" readonly>
   Ex:
            System.out.println("A".compareTo("Z")); &#10140; -ve
            System.out.println("K".compareTo("A")); &#10140; _ve
            System.out.println("K".compareTo("K")); &#10140; 0
            System.out.println("a".compareTo("A")); &#10140; +ve
            System.out.println("A".compareTo(new Integer(10))); &#10140; classCastException
            System.out.println("A".compareTo(null)); &#10140; NullPointerException
</textarea>



<br/>
<p><b>Note:</b> while Inserting the objects into the TreeSet JVM internally uses compareTo() method if we are
depending on natural sorting order.
Sometimes we have to define our own customized sorting order, then we should go for comparator Interface.</p>
<p><b>Comparator Iterface</b>
By using comparator object we can define our own customized sorting.
Comparator Interface is available in java.util package. This interface defines the following 2 methods
</p>
 <ol>
         <li>public int compare(Object obj1, Object obj2)<br/>
returns –ve if obj1 has to come before obj2<br/>
+ve if obj1 has to come after obj2<br/>
0 if obj1 and obj2 are equal.</li>
         <li>public boolean equals(Object obj)</li>
    
         </ol>
         <p>When ever we are implementing comparator interface compulsory we should provide
implementation for compare method. Implementing equals method is optional because it is already available
from object class through inheritance.
</p>
<p><b>Write a program to insert integer objects into the Treeset where the sorting order is descending order</b></p>
<textarea rows="30" cols="60" class="textArea" readonly>
   Ex:-
            import java.util.*;
            class TreeSetDemo
            {
            public static void main(String arg[])
            {
            TreeSet t = new TreeSet(new MyComparator());
            t.add(10);
            t.add(5);
            t.add(15);
            t.add(20);
            t.add(0);
            System.out.println(t);
            }
            }
            class MyComparator implements Comparator
            {
            public int compare(Object obj1, Object obj2)
            {
            Integer I1 = (Integer)obj1;
            Integer I2 = (Integer)obj2;
            if(I1<I2)
            return +1;
            else if (I1>I2)
            return -1;
            else
            return 0;
            }
            }
</textarea>
<br/>
<b>op:-</b>
<p class="OutPara"><b>false<br/>[&nbsp;10, &nbsp;15, &nbsp;10,&nbsp; 5,&nbsp; 0&nbsp;]</b></p>
<p>
If we are depending on natural sorting order compulsory the objects should be homogeneous and
comparable other wise we will get class cast Exception.<br/>
An object is said to be comparable(if and only if) the corresponding class has to implement
comparable interface.<br/>
All wrapper classes and String class already implemented comparable interface. But the String buffer
doesn’t implement comparable interface. Hence in the above program we got class cast exception.

</p>
<p><b>Flow of control in MyComparator</b><br/>
compare(10, 5) &#10140; 10, 5<br/>
compare(15, 10) &#10140; 15, 10, 5<br/>
compare(20, 15) &#10140; 20, 15, 10, 5<br/>
compare(0, 20)<br/>
compare(0, 15)<br/>
compare(0, 10)<br/>
compare(0, 5) &#10140; 20, 15, 10, 5, 0
</p>
<p>
if we are not passing comparator object JVM will always call compareTo() method which is meant for
default natural sorting order.
</p>

<p>
<b>Case1:</b> If we implement compare method as follows the outputs are<br/>
public int compare(Object obj1, Object obj2)<br/>
&#10100;<br/>
Integer I1 = (Integer)obj1;<br/>
Integer I2 = (Integer)obj2;<br/>
return I1.compareTo(I2); &#10140; [0,5,10,15,20]<br/>
return I2.compareTo(I1); &#10140; [20,15,10,5,0]<br/>
return -I1.compareTo(I2); &#10140; [20,15,10,5,0]<br/>
return -I2.compareTo(I1); &#10140; [0,5,10,15,20]<br/>
return I2-I1; &#10140; [20,15,10,5,0]<br/>
return I1-I2; &#10140; [0,5,10,15,20]<br/>
&#10101;<br/>
</p>
<p>
<b>Case2:</b> If we implement compare method as follows<br/>
public int compare(Object obj1, Object obj2)<br/>
&#10100;<br/>
return -1; &#10140; [0,20,15,5,10] (reverse of Insertion order)<br/>
return 1; &#10140; [10,5,15,20,0] (Insertion Order)<br/>
return 0; &#10140; [10] (All the remaining elements considered as duplicate objects)<br/>
&#10101;<br/>
<p><b>Write a program to insert String Objects to the TreeSet Where the Sorting order is reverse of
Alphabetical order.</b></p>
<textarea rows="25" cols="60" class="textArea" readonly>
   Ex:-
            import java.util.*;
            class TreeSetDemo
            {
            public static void main(String arg[])
            {
            TreeSet t = new TreeSet(new MyComparator());
            t.add("chiru");
            t.add("venky");
            t.add("nagaruna");
            t.add("balaiah");
            t.add("saikumar");
            t.add("suman");
            System.out.println(t);
            }
            }
            class MyComparator implements Comparator
            {
            public int compare(Object obj1, Object obj2)
            {
            String s1 = (String)obj1;
            String s2 = (String)obj2;
            return s2.compareTo(s1);
            }
            }
</textarea>
<p><b>O/P:-</b></p>
<p class="OutPara1"><b>[&nbsp;venky, &nbsp;suman, &nbsp;saikumar,&nbsp; nagaruna,&nbsp; chiru, &nbsp;balaiah &nbsp;]</b></p>

<p><b>
Map Interface
</b><br/>
The Map interface is not an extension of Collection interface. Instead the interface starts of it’s own
interface hierarchy, for maintaining key-value associations. The interface describes a mapping from keys to
values, without duplicate keys, by defination.<br/>
The Map interface provides three collection views, which allow a map's contents to be viewed as a set of
keys, collection of values, or set of key-value mappings. The order of a map is defined as the order in which
the iterators on the map's collection views return their elements. Some map implementations, like the
TreeMap class, make specific guarantees as to their order; others, like the HashMap class, do not.

</p>
<p><b>Key-Value pairs
</b><br/>Key-value pairs are stored in <span style="font-style:italic">maps</span></p>
<p><b>
Map interfaces</b>
</p>
   <ul>
         <li><span style="font-style:italic">Map</span> implemented by HashMap and TreeMap</li>
         <li><span style="font-style:italic">SortedMap</span> implemented by TreeMap.</li>
         <li><span style="font-style:italic">Map.Entry</span> which describes access methods to the key-value pairs.</li>
        
         </ul>
<p><b>Implementing classes</b><br/>
A number of classes implement the Map interface, including HashMap, TreeMap, LinkedHashMap,
WeakHashMap, ConcurrentHashMap, and Properties. The most generally useful class is HashMap. 
</p>

   <ul>
         <li>java.util.<b>HashMap</b> is implemented with a hash table. Access time is O(1). Entries are unsorted. 
</li>
         <li>java.util.<b>LinkedHashMap</b> is implemented with a hash table. Access time is O(1). Entries are sorted in
either entry order or order of last access, which is useful for implementing a LRU (least recently
used) caching policy. 
</li>
         <li>java.util.<b>TreeMap</b> is implemented as a balanced binary tree. Access time is O(log N). Entries are
sorted.</li>
     
        
         </ul>

         <p><b>Map interface methods</b>

         <br/>

         Here are some of the most useful Map methods. m is a Map, b is a boolean, i is an int, set is a Set, col is a
Collection, key is an Object used as the key used to store a value, val is an Object stored as the value
associated with the key. 
</p>
<div class="Mapinterfacemethods">
<img src="assets/images/Mapinterfacemethods.JPG" style="width:90%;">
<img src="assets/images/Mapinterfacemethods2.JPG" style="width:90%;">
</div>

<p><b>Map.Entry interface methods</b><br/>
Each element is a map has a key and value. Each key-value pair is saved in a java.util.Map.Entry object.
A set of these map entries can be obtained by calling a map's entrySet() method. Iterating over a map is
done by iterating over this set.

</p>
<p>Assume in the following table that me is a Map.Entry object. 
</p>
<div class="Mapinterfacemethods">
<img src="assets/images/Mapinterfacemethods3.JPG" style="width:90%;">

</div>

<p>The interface methods can be broken down into three sets of operations: altering, querying and providing
alternative views</p>
<p>

The alteration operation allows you to add and remove key-value pairs from the map. Both the key and
value can be null. However you should not add a Map to itself as a key or value.<br/>
Object put(Object key, Object value)<br/>
Object remove(Object key)<br/>
void putAll(Map t)<br/>
void clear()<br/>
The query operations allow you to check on the contents of the map<br/>
Object get(Object key)<br/>
boolean containsKey(Object key)<br/>
boolean containsValue(Object value)<br/>
int size()<br/>
boolean isEmpty()<br/>
The set methods allow you to work with the group of keys or values as a collection<br/>
Set keySet()<br/>
Collection values()<br/>
Set entrySet()<br/>
</p>

<div class="Mapinterfacemethods">
<img src="assets/images/Mapinterfacemethods4.JPG" style="width:90%;">

</div>


<p><b>HashMap</b><br/>
HashMap is not sorted or ordered. If you just need a Map, and you don’t care about the order of the elements
while iterating through it, you can use a HashMap. That keeps it simple. The values can be null. But the key
should ne unique, so you can have one null value for key. (Allows only one null key).
</p>
<p><b>HashMap</b><br/>
In addition to implemented the Map interface methods, HashMap has the following constructors. 

</p>
<div class="Mapinterfacemethods">
<img src="assets/images/Mapinterfacemethods6.JPG" style="width:90%;">

</div>

<p><b>LinkedHashMap</b><br/>LinkedHashMap will keep the order in which the elements are inserted into it. If you will be adding and
removing elements a lot, it will be better to use HashMap, because LinkedHashMap will be slower to do
those operations. But, you can iterate faster using LinkedHashMap. So, if you will be iterating heavily, it
may be a good idea to use this.</p>


<p><b>WeakHashMap</b><br/>A map of weak keys that allow objects referred to by the map to be released; designed to solve certain types
of problems. If no references outside the map are held to a particular key, it may be garbage collected.
</p>


<p><b>IdentityHashMap</b><br/>A hash map that uses == instead of equals( ) to compare keys. Only for solving special types of problems;
not for general use.</p>


<p><b>Hashtable</b><br/>
Hashtable is almost the same as HashMap. The main differences are:<br/>
1. Hashtable does not let you have null value for key.<br/>
2. The key methods of Hashtable are synchronized. So, they may take a longer time to execute, compared to
HashMap’s methods.


</p>


<p><b>SortedMap</b><br/>If you have a <b>SortedMap</b> (of which <b>TreeMap</b> is the only one available), the keys are guaranteed to be in
sorted order, which allows additional functionality to be provided with these methods in the SortedMap
interface: 
</p>
<p><b>Comparator comparator( ): </b>Produces the comparator used for this <b>Map</b>, or null for natural ordering</p>
<p><b>Object firstKey( ):</b> Produces the lowest key. </p>
<p><b>Object lastKey( ):</b> Produces the highest key</p>
<p><b>SortedMap subMap(fromKey, toKey): </b>Produces a view of this <b>Map</b> with keys from fromKey, inclusive,
to toKey, exclusive. 
</p>
<p><b>SortedMap headMap(toKey):</b> Produces a view of this <b>Map</b> with keys less than toKey. </p>

<p><b>SortedMap tailMap(fromKey):</b> Produces a view of this <b>Map</b> with keys greater than or equal to <b>fromKey</b>.</p>



<p><b>SortedMap interface methods</b><br/>The SortedMap interface is used by TreeMap and adds additional methods to reflect that a TreeMap is
sorted. 
</p>

<div class="Mapinterfacemethods">
<img src="assets/images/Mapinterfacemethods5.JPG" style="width:90%;">

</div>
<p><b>TreeMap
</b><br/>TreeMap is a sorted Map and will be sorted by the natural order of the elements. If you want, you can define
a custom sort order by means of a Comparator passed to the constructor. So, when you need a custom sort
order, it is clear which class you should be using!
</p>
<p><b>TreeMap class constructors</b><br/>TreeMap implements the <b>Map</b> and <b>SortedMap</b> interface methods. In constrast to HashMap, TreeMap keeps
the balanced binary tree in sorted order by key. If the key has a natural order (eg, String) this is ok, but often
you will supply a Comparator object that tells how two keys compare. It has the following constructors. 
</p>
<div class="Mapinterfacemethods">
<img src="assets/images/Mapinterfacemethods7.JPG" style="width:90%;"><br/>
<img src="assets/images/Mapinterfacemethods8.JPG" style="width:90%;">
</div>
<h3>Generics Introduction</h3>
       <p>Array objects are by default typesafe. i.e we declare String Array we can insert only String Objects. By
         Mistake if we r trying to insert any other elements we will get compile time error.</p>
<p style="margin-left: 150px;">Ex:<br>
      String [] s = new String[100];<br>
      s[0] = "raju";<br>
      s[1] = 10;  ->C.E</p>
<p>But Collection objects are not typesafe by default. If our requirement is to add only String objects to the
   ArrayList , By mistake if we r trying to insert any other element we won’t get any compile time error.
   </p> 
<p style="margin-left: 150px;" >ArrayList l = new ArrayList();<br>
   l.add(“raju”);<br>
   l.add(new Integer(10));   -> No Compile Time Error.</p>
   <p>While retrieving Array elements there is no need to perform typecasting.<br>
      String name = s[0];    -> No typecasting required here</p>
   <p>But while retrieving the elements from ArrayList compulsory we should perform typecasting</p>
   <p style="margin-left: 150px;" >String name = l.get(0); -> C.E<br>
      String name = (String)l.get(0); <i  class="fa fa-check" style="color: blue; margin-left: 10px;"></i>
      </p>
      <p>To resolve the above 2 problems (typesafety, typecasting) sun people introduced generics concept in the 1.5
         version.If we want to create ArrayList object to hold any String Objects we have to define as follows.
         </p>
  
<p>ArrayList&#60;String&#62; 1 = new ArrayList&#60;String&#62; &#40; &#41;</p>
<p>For this ArrayList we have to add only String objects. By mistake if we r trying to add any other type we
   will get compile time error.</p>
   <p style="margin-left: 150px;">l.add(“valid”);<br>
      l.add(new Integer(10)); <i  class="fa fa-close" style="color: red; margin-left: 10px;"></i></p>
<p>C.E:- can’t find the symbol add(Integer)<br>
   At the time of retrieval no need to perform any typecasting.
   </p>
   <p style="margin-left: 150px;">String name = l.get(0); -> No typecasting is required.</p>
   <p>Hence by using generics we can provide typesafety and we can resolve typecasting problems.
   </p>
   <p>By using generics we can define parameter for the collection. These parameterized collection classes are
      nothing but “Generic collection classes”.
      </p>
<p>Polymorphism concept is not applicable for the parameter type but applicable for basetype</p>
<span style="margin-left: 100px;"><img src="assets/images/col1.PNG"></span><br>

      <p style="margin-left: 150px;">List&#60;object&#62; 1= new ArrayList&#60;String&#62; &#40; &#41;; <i  class="fa fa-close" style="color: red; margin-left: 10px;"></i> </p>
      <p style="margin-left: 150px;">C.E:- Incompatable Types<br>
         Found:ArrayList&#60;String&#62;<br>
         Required :List&#60;Object&#62; 
      </p>
<p>The type parameter must be object type(any class or interface name). we can’t apply generic concept for
   primitive datatype.</p>
   
  <p style="margin-left: 150px;">Ex:- ArrayList&#60;int&#62; l = new ArrayList&#60;int&#62; &#40; &#41;;</p> 
  <p style="margin-left: 150px;">C.E:- unexpected type found : int<br>
   Required : Integer</p>
   <p style="margin-left: 150px;"><b>->    Which of the following declarations are valid</b></p>
  <ol style="margin-left: 150px;">
<li>ArrayList&#60;Integer&#62; l = new ArrayList&#60;Integer&#62;&#40; &#41;;  <i  class="fa fa-check" style="color: blue; margin-left: 10px;"></i>
</li>
<li>ArrayList&#60;Number&#62; l = new ArrayList&#60;Integer&#62;&#40; &#41;; <i  class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
<li>ArrayList&#60;Runnable&#62; l = new ArrayList&#60;Runnable&#62;&#40; &#41;; <i  class="fa fa-check" style="color: blue; margin-left: 10px;"></i></li> 
<li>ArrayList&#60;long&#62; l = new ArrayList&#60;Long&#62; &#40;&#41;;  <i  class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>
<li>ArrayList&#60;Object&#62; l = new ArrayList&#60;StringBuffer&#62;&#40; &#41;; <i  class="fa fa-close" style="color: red; margin-left: 10px;"></i></li>


  </ol>
<h3>Generic Classes
</h3>
<p>Until 1.4 version we have ArrayList class with the declarations as follows.</p>
<textarea rows="6" cols="30" class="textArea" style="margin-left: 150px;" readonly>
 Class ArrayList
   {
   add(Object o);
   Object get(int index);
   }
</textarea>
<p>add method contain Object as argument, hence we can add any kind of object.</p>
<p>As a result we can’t get any type safety. The return type of get() method is object hence at the time of
   retrieval we should perform typecasting. </p>
   <p>But in the 1.5 version we have generic ArrayList class with the definition as follows</p>
   <textarea rows="6" cols="30" class="textArea" style="margin-left: 150px;" readonly>
      class ArrayList&#60;T&#62;
         {
         add(T t);
         T get(int);
         }
   </textarea>
   <p>The argument to the add method is String hence we should add only String Object as the result we will get
      type safety.<br>
      The return type of get() method is String. Hence at the time of retrieval no need to perform typecasting.</p>
<p>We can define our own generic classes also
</p>
<textarea rows="35" cols="60" class="textArea" readonly>
   Ex:
   class gen<T>
   {
   T ob;
   gen(T ob)
   {
   this.ob = ob;
   }
   public void show()
   {
   System.out.println("The type of Object is : "+ob.getClass().getName());
   }
   public T getOb()
   {
   return ob;
   }
   }
   class GenericsDemo
   {
   public static void main(String[] args)
   {
   gen<String> g1 = new gen<String>("raju");
   g1.show();
   System.out.println(g1.getOb());
   gen<Integer> g2 = new gen<Integer>(10);
   g2.show();
   System.out.println(g2.getOb());
   }
   }
   O/P:- The type of Object is : java.lang.String
   raju
   The type of Object is : java.lang.Integer
   10
</textarea>

<h4>BoundedTypes</h4>

<p>We can bound the type parameter for a particular range. Such type of types is called bounded types.
   We can achieve this by using extends keyword.</p>

   <textarea rows="5" cols="30" class="textArea" style="margin-left: 150px;" readonly>
      Ex:-
          class Gen<T>
             {
             }
   </textarea>
<p>Here we can pass any types as the type parameter and there are no restrictions</p>

   <p style="margin-left: 150px;">Gen&#60;String&#62; g1 = new Gen&#60;String&#62; &#40; &#41;; <i  class="fa fa-check" style="color: blue; margin-left: 10px;"></i></p>
 <p style="margin-left: 150px;">Gen&#60;Integer&#62; g2 = new Gen&#60;Integer&#62;&#40; &#41;;<i  class="fa fa-check" style="color: blue; margin-left: 10px;"></i></p>
  <p>Ex:<br>
   Class Gen&#60;T extends X&#62;</p>
   <p>If ‘X’ is a class then any type which is the child class of ‘X’ is allowed as the type parameter.<br>
      If ‘X’ is an interface then any type which is the implementation class of ‘X’ is allowed as the type
      parameter.
      </p>
      <textarea rows="5" cols="30" class="textArea" style="margin-left: 150px;"  readonly>
         Ex:
class Gen&#60;T extends Number&#62;
{
}
      </textarea>
      
 <p>In this case as the type parameter we can take either number or it’s child classes</p>
  
   <p style="margin-left: 150px;">Gen&#60;Integer&#62; g2 = new Gen&#60;Integer&#62;&#40; &#41;;<i  class="fa fa-check" style="color: blue; margin-left: 10px;"></i></p>
   <p style="margin-left: 150px;">Gen&#60;String&#62; g1 = new Gen&#60;String&#62; &#40; &#41;; <i  class="fa fa-close" style="color: red; margin-left: 10px;"></i></p>
   <p>Because type parameter String is not with in it’s bound</p>
   <textarea rows="5" cols="30" class="textArea" style="margin-left: 150px;"  readonly>
      class Gen<T extends Runnable>
         {
         }
   </textarea>
 <p>In this case as the type parameter we can take any implementation class of Runnable interface. </p>
<textarea rows="1" cols="60" class="textArea" readonly>
   Gen<Thread> t1 = new Gen<Thread>();
</textarea>
<p>Because Thread is implementation class of Runnable</p>
<textarea rows="1" cols="60" class="textArea" readonly>
   Gen<String> t2 = new Gen<String>(); 
</textarea>
<p>Because String is not implementation class of Runnable interface .</p>
<p>In generics we have only extends keyword and there is no implements keyword. It’s purpose is also survived
   by using extends keyword only.
   </p>
   <textarea rows="28" cols="60" class="textArea" readonly>  
Ex:
      class Gen<T extends Number>
      {
      T ob;
      Gen(T ob)
      {
      this.ob = ob;
      }
      void show()
      {
      System.out.println("The int value is :" + ob.intValue());
      }
      }
      class GenDemo
      {
      public static void main(String arg[])
      {
      Gen<Integer> t1 = new Gen<Integer>(new Integer(10));
      t1.show();
      Gen<Double> t2 = new Gen<Double>(10.5);
      t2.show();
      Gen<String> t3 = new Gen<String>("raju");
      t3.show();
      }
      }
   </textarea>  
<h4>Generic Methods
</h4>
<ol >
<li>m1(ArrayList&#60;String&#62;&#40;
   It is applicable for ArrayList of only String type.</li>
<li> m1&#40;ArrayList&#60;&#63; extends x&#62; l)
   Here if ‘x’ is a class then this method is applicable for ArrayList of either x or it’s child classes.<br>
   If ‘x’ is an interface then this method is applicable for ArrayList of any implementation class of x</li>
   <li> m1&#40;ArrayList &#60;&#63; Super x&#62; l&#41;
      If ‘x’ is a class then this method is applicable for ArrayList of either x or it’s super classes.<br>
      If ‘x’ is an interface then this method is applicable for ArrayList of any super classes of implemented
      class of x.</li>
<li>m1&#40;ArrayList &#60;?&#362; l)
   This method is applicable for ArrayList of any type.<br>
   In the method declaration if we can use ‘?’ in that method we are not allowed to insert any element except
   null. Because we don’t know exactly what type of object is coming.</li>

</ol>
 
<textarea rows="34" cols="60" class="textArea" readonly> 
   Ex:
   import java.util.*;
   class Test
   {
   public static void main(String arg[])
   {
   ArrayList<String> l1 = new ArrayList<String>();
   l1.add("A");
   l1.add("B");
   l1.add("C");
   l1.add("D");
   m1(l1);
   ArrayList<Integer> l2 = new ArrayList<Integer>();
   l2.add(10);
   l2.add(20);
   l2.add(30);
   l2.add(40);
   m1(l2);
   }
   public static void m1(ArrayList<?> l)
   {
   //l.add("D"); -> C.E: Because we can’t expect what type of value
   will come
   l.remove(1);
   l.add(null);
   System.out.println(l);
   }
   }
   O/P:- [A, C, D, null]
   [10, 30, 40, null]
</textarea>
<p><b>Which of the following declarations are valid?</b></p>
<p style="margin-left: 150px;">ArrayList&#60;String&#62; l = new ArrayList&#60;String&#62;&#40; &#41;; <i  class="fa fa-check" style="color: blue; margin-left: 10px;"></i></p>
<p style="margin-left: 150px;">ArrayList&#60;Object&#62; l = new ArrayList&#60;String&#62;&#40; &#41;; <i  class="fa fa-close" style="color: red; margin-left: 10px;"></i></p>
 <p style="margin-left: 150px;">ArrayList&#60;&#63; extends Object&#62; l = new ArrayList&#60;String;&#62;&#40; &#41;;  <i  class="fa fa-check" style="color: blue; margin-left: 10px;"></i></p> 
 <p style="margin-left: 150px;"> ArrayList&#60;&#63; extends String&#62; l = new ArrayList&#60;String;&#62;&#40; &#41;;  <i  class="fa fa-check" style="color: blue; margin-left: 10px;"></i></p>
 <p style="margin-left: 150px;"> ArrayList&#60;&#63; Super String&#62; l = new ArrayList&#60;String;&#62;&#40; &#41;;  <i  class="fa fa-check" style="color: blue; margin-left: 10px;"></i></p>

 <p style="margin-left: 150px;"> ArrayList&#60;&#63; Super Runnable&#62; l = new ArrayList&#60;Object&#62;&#40; &#41;; <i  class="fa fa-close" style="color: red; margin-left: 10px;"></i></p>
 <p style="margin-left: 150px;"> ArrayList&#60;&#63; Super Runnable&#62; l = new ArrayList&#60;Thread&#62;&#40; &#41;; <i  class="fa fa-close" style="color: red; margin-left: 10px;"></i></p>
  <p style="margin-left: 150px;"> ArrayList&#60;&#63;&#62; l = new ArrayList&#60;Integer&#62;&#40; &#41;; <i  class="fa fa-check" style="color: blue; margin-left: 10px;"></i></p>
  <p style="margin-left: 150px;"> ArrayList&#60;&#63;&#62; l = new ArrayList&#60;&#63; extends Number&#62;&#40; &#41;; <i  class="fa fa-close" style="color: red; margin-left: 10px;"></i></p>
  <p style="margin-left: 150px;"> ArrayList&#60;&#63;&#62; l = new ArrayList&#60;&#63; super Number&#62;&#40; &#41;; <i  class="fa fa-close" style="color: red; margin-left: 10px;"></i></p>
  <p style="margin-left: 150px;"> ArrayList&#60;&#63;&#62; l = new ArrayList&#60;&#63;&#62;&#40; &#41;; <i  class="fa fa-close" style="color: red; margin-left: 10px;"></i></p>

<p>We can use Unicode character ‘?’ in the declaration part but not in the construction part.</p>
<h4>Communication with legacy non-generic code
</h4>
<p>To provide compatibility with old non-generic versions sun people compromised the generics concept in
   some places, the following is one such place
   </p>
   <textarea rows="23" cols="60" class="textArea" style="margin-left: 150px;" readonly> 
      Ex:
      import java.util.*;
      class Test
      {
      public static void main(String arg[])
      {
      ArrayList<String> l = new ArrayList<String>();
      l.add("A");
      l.add("B");
      l.add("C");
      //l.add(10);
      m1(l);
      System.out.println(l);
      }
      public static void m1(ArrayList l)
      {
      l.add(new Integer(10));
      l.add(new StringBuffer("raju"));
      }
      }
      O/P:- [A, B, C, 10, raju]
   </textarea>      
<p><b>Note:</b>
   Generics is the concept applicable only at compile time to provide type safety, at runtime there is no
   generic concept at all.
   </p>
  <p style="margin-left: 150px;"> Ex:<br>
         ArrayList l = new ArrayList&#60;String&#62;&#40;&#41;;<br>
         l.add&#40;"A"&#41;;   -><i  class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
         l.add&#40;new Integer&#40;10&#41;&#41;;   -><i  class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
         l.add&#40;new StringBuffer&#40;"raju"&#41;&#41;;<br>
         ArrayList&#60;String&#62;l = new ArrayList&#41;&#41;;<br>
         l.add&#40;"A"&#41;;  -><i  class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
         l.add&#40;10&#41;;  -><i  class="fa fa-close" style="color: red; margin-left: 10px;"></i><br>
         l.add&#40;"B"&#41;; -><i  class="fa fa-check" style="color: blue; margin-left: 10px;"></i> <br>
         l.add&#40;null&#41;; -><i  class="fa fa-check" style="color: blue; margin-left: 10px;"></i><br>
         l.add&#40;20&#41;;  -><i  class="fa fa-close" style="color: red; margin-left: 10px;"></i>
      
      </p>

      </div>
   </div>
</div>

<!-- FOOTER START-->
<footer>
   <div class="footer" id="footer">
       <div class="container">
           <div class="row">
               <div class="col-lg-6 col-md-6 col-sm-6 col-xs-6">
                   <h4> Author Name : Vikas & His Team</h4>
                   <p><img src="assets/images/vikas.jpg"></p>
               </div>
               <div class="col-lg-3 col-sm-2 col-xs-3">
                   <h3> Contact </h3>
                   <ul>
                       <li><a class="email" href="#"> insert email here </a></li>
                       <li>
                           <p> address line one </p>
                       </li>
                       <li>
                           <p> address line two </p>
                       </li>
                   </ul>
               </div>
               <div class="col-lg-3 col-sm-2 col-xs-3">
                   <ul>
                       <li>
                           <h5>
                               <a href="#" style="margin-top: 5em"> ABOUT US</a>
                           </h5>
                       </li>
                       <li>
                           <h5>
                               <a href="#"> CURRENT SERIES </a>
                           </h5>
                       </li>
                       <li>
                           <h5>
                               <a href="#"> THE HOUSE </a>
                           </h5>
                       </li>
                       <li>
                           <h5>
                               <a href="#"> LOOKING BACK </a>
                           </h5>
                       </li>
                   </ul>
               </div>
               <!--/.row-->
           </div>
           <!--/.container-->
       </div>
       <!--/.footer-->
       <div class="footer-bottom">
           <div class="container">
               <p class="pull-left copyright"> @ Copyright 2019 to Today  www.Guruji.com  All right reserved. Develop By Vikas & His Team.</p>
           </div>
       </div>
       <!--footer-bottom-->
   </div>
</footer>

<!-- FOOTER END -->